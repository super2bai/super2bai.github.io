<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mac下Brew安装Tomcat并配置到IntelliJ IDEA</title>
      <link href="/mac/tomcat.html"/>
      <url>/mac/tomcat.html</url>
      
        <content type="html"><![CDATA[<p>更新了一波，配置忘记恢复了，从来！</p><a id="more"></a><ul><li><p>安装Tomcat：<code>brew install tomcat</code></p></li><li><p>根目录：<code>/usr/local/Cellar/tomcat/x.x.x/libexec/</code></p></li><li><p>配置到IntelliJ IDEA时选择上述路径即可</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启用root账号设置密码</title>
      <link href="/Mac/root.html"/>
      <url>/Mac/root.html</url>
      
        <content type="html"><![CDATA[<p>Mac一直用的个人账户，从来没有用过root账户，直到有一天需要切root发现不知道密码。。。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 给root用户设置密码</span></div><div class="line">sudo passwd root</div><div class="line"></div><div class="line"><span class="comment"># 开启root账户</span></div><div class="line">sudo passwd --unlock root </div><div class="line"></div><div class="line"><span class="comment"># 重新锁定root账户</span></div><div class="line">sudo passwd --lock root</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新oh-my-zsh报错</title>
      <link href="/zsh/upgrade.html"/>
      <url>/zsh/upgrade.html</url>
      
        <content type="html"><![CDATA[<p>oh my zsh… oh! my!</p><a id="more"></a><p>提示更新oh my zsh，当然更新！提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Updating Oh My Zsh</div><div class="line">error: cannot pull with rebase: You have unstaged changes.</div><div class="line">error: please commit or stash them.</div><div class="line">There was an error updating. Try again later?</div></pre></td></tr></table></figure><p>尝试手动更新：<code>upgrade_oh_my_zsh</code>，依旧报错。</p><p>原因在报错中已经提示了：<code>You have unstaged changes.</code>，因为修改了git文件。</p><p>如果想保留修改，可以采用如下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cd ~/.oh-my-zsh</div><div class="line">git status</div><div class="line">git stash</div><div class="line">upgrade_oh_my_zsh</div><div class="line">git stash pop</div></pre></td></tr></table></figure><p>不想保留就按照git提交丢弃本地修改的方式即可。</p>]]></content>
      
      
      <categories>
          
          <category> zsh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs快捷键</title>
      <link href="/emacs/shortcut.html"/>
      <url>/emacs/shortcut.html</url>
      
        <content type="html"><![CDATA[<p>macOS大部分的文本编辑功能都绑定了Emacs快捷键，所以在邮件，chrome等地方这些都是通用的。</p><a id="more"></a><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Ctrl + h        向前删除一个字符</div><div class="line">Ctrl + d        向后删除一个字符</div><div class="line">Ctrl + u        删除光标到行首的所有字符</div><div class="line">Ctrl + k        删除光标到行尾的所有字符</div><div class="line"></div><div class="line">Ctrl + a        光标移到行首 Ahead</div><div class="line">Ctrl + e        光标移到行尾 End</div><div class="line">Ctrl + f        光标向前移一个字符 Forward</div><div class="line">Ctrl + b        光标向后移一个字符 Backward</div><div class="line">Ctrl + left     光标向前移一个单词</div><div class="line">Ctrl + right    光标向后移一个单词</div><div class="line">Ctrl + p        调出前一条命令/向上一行 Previous </div><div class="line">Ctrl + n        调出后一条命令/向下一行 Next</div><div class="line"></div><div class="line">Ctrl + c        取消当前行命令 Ctrl + <span class="keyword">Break</span></div><div class="line">Ctrl + l        清屏 clear命令</div><div class="line">Ctrl + r        出现bck-i-search: 输入查找相关历史命令</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置线程池大小</title>
      <link href="/server/threadpool.html"/>
      <url>/server/threadpool.html</url>
      
        <content type="html"><![CDATA[<p>线程池大小多少合适？</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>通常来说，服务分为两种类型：</p><ul><li><a href="https://en.wikipedia.org/wiki/CPU-bound" target="_blank" rel="external">CPU密集型</a></li></ul><blockquote><p>也叫计算密集型，当计算机完成任务的时间主要取决于CPU的速度时，计算机受CPU限制（或计算限制）：CPU利用率很高，可能在100％的使用时间内持续很多秒或分钟。外围设备产生的中断可能会被缓慢处理或无限期延迟处理。</p></blockquote><ul><li>IO密集型</li></ul><blockquote><p>完成计算所花费的时间主要由等待I/O操作完成所花费的时间来确定。 这与CPU密集的任务相反。 当请求数据的速率低于其消耗速率时，或者换句话说，请求数据所花费的时间多于处理数据所花费的时间，就会出现这种情况。</p></blockquote><p>那有没有可以落地的实践方法指导呢？<a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="external">Little’s Law</a>。</p><blockquote><p>一个系统请求数<code>=</code>请求的到到达率<code>*</code>平均每个单独请求花费的时间</p></blockquote><p>利用Little’s Law判定线程池大小，也就是</p><blockquote><p>线程池大小 = (线程IO时间+线程CPU时间) / 线程CPU时间 / CPU数目 </p></blockquote><p>所需数值分别为：</p><ul><li>一个请求所消耗的时间<ul><li>线程IO时间+线程CPU时间</li></ul></li><li>该请求计算时间<ul><li>线程CPU时间</li></ul></li><li>CPU数目</li></ul><h3 id="请求消耗时间"><a href="#请求消耗时间" class="headerlink" title="请求消耗时间"></a>请求消耗时间</h3><p>Web服务中，可以通过Filter来拦截获取该请求前后消耗的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span></span>&#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span>&#123;</div><div class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      <span class="comment">//处理业务</span></div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">      <span class="keyword">long</span> cost = System.currentTimeMillis() - start;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CPU计算时间"><a href="#CPU计算时间" class="headerlink" title="CPU计算时间"></a>CPU计算时间</h3><blockquote><p>CPU计算时间 = 请求总耗时 - CPU IO时间</p></blockquote><p>假设该请求有一个查询DB的操作，只要查询DB的耗时，也就是CPU IO时间，就可以得出CPU计算时间。</p><p>可以通过JDK动态代理或者是CGLIB的方式添加AOP切面，来获取线程IO耗时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</div><div class="line"><span class="meta">@override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">    StopWatch watch = <span class="keyword">new</span> StopWatch();</div><div class="line">    watch.start();</div><div class="line">    Object result = <span class="keyword">null</span>;</div><div class="line">    Throwable t = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">      result = invocation.proceed();</div><div class="line">    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line"><span class="comment">//handle ex</span></div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">      <span class="comment">// 得出时间</span></div><div class="line">      watch.stop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="CPU数目"><a href="#CPU数目" class="headerlink" title="CPU数目"></a>CPU数目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep "processor" | wc -l</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>还是需要通过压测来进行微调，以保证配置的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis解析报错</title>
      <link href="/MyBatis/analysis.html"/>
      <url>/MyBatis/analysis.html</url>
      
        <content type="html"><![CDATA[<p>MyBatis文件解析报错</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>新增一个MyBatis的Plugin，添加到配置文件中后，报错：</p><blockquote><p>Caused by: org.xml.sax.SAXParseException; lineNumber: 99; columnNumber: 17; The content of element type “configuration” must match “(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)”.</p></blockquote><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在<code>mybatis-config.xml</code>配置文件配置节点时，按照如下的顺序配置，即可消除错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;properties&gt;...&lt;/properties&gt;</div><div class="line">&lt;settings&gt;...&lt;/settings&gt;</div><div class="line">&lt;typeAliases&gt;...&lt;/typeAliases&gt;</div><div class="line">&lt;typeHandlers&gt;...&lt;/typeHandlers&gt;</div><div class="line">&lt;objectFactory&gt;...&lt;/objectFactory&gt;</div><div class="line">&lt;objectWrapperFactory&gt;...&lt;/objectWrapperFactory&gt;</div><div class="line">&lt;plugins&gt;...&lt;/plugins&gt;</div><div class="line">&lt;environments&gt;...&lt;/environments&gt;</div><div class="line">&lt;databaseIdProvider&gt;...&lt;/databaseIdProvider&gt;</div><div class="line">&lt;mappers&gt;...&lt;/mappers&gt;</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在<code>mybatis-config.xml</code>的声明中，定义了<code>xml</code>的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE configuration</div><div class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</div><div class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</div><div class="line">&lt;configuration&gt;</div></pre></td></tr></table></figure><p>在MyBatis源码的<a href="https://github.com/mybatis/mybatis-3/blob/master/src/main/java/org/apache/ibatis/builder/xml/mybatis-3-config.dtd" target="_blank" rel="external">mybatis-3-config.dtd</a>文件中，定义了<code>mybatis-config.xml</code>的文件结构，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"></div><div class="line">&lt;!ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure><blockquote><p>DTD：Document Type Definition</p><p>A <strong>DTD</strong> is a Document Type <strong>Definition</strong>. A <strong>DTD</strong> defines the structure and the legal elements and attributes of an XML document.</p></blockquote><p>DTD规则如下，用正则来理解就好：</p><table><thead><tr><th>符号</th><th>用途</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>()</code></td><td>用来给元素分组</td><td>`(A</td><td>B</td><td>C</td><td>D),(E</td><td>F),D`</td><td>分成三组</td></tr><tr><td>`</td><td>`</td><td>在列出的对象中选择一个</td><td>`(A</td><td>B)`</td><td>表示A或者B必须出现，两者选一</td></tr><tr><td><code>+</code></td><td>出现1或N次</td><td><code>(A+)</code></td><td>A必须出现，而且可以出现多个A</td></tr><tr><td><code>*</code></td><td>出现0或N次</td><td><code>(A*)</code></td><td>A可以出现0到多次</td></tr><tr><td><code>?</code></td><td>可以不出现，最多出现一次</td><td><code>(A?)</code></td><td>A可以不出现，可以出现1次</td></tr><tr><td><code>,</code></td><td>必须按指定的顺序出现</td><td><code>(A,B,C,D)</code></td><td>表示ABCD必须出现，而且需要按照这个顺序出现</td></tr></tbody></table><p>结合规则与定义文件来看，则表示，<code>configuration</code>下的的元素都必须按照定义的顺序出现，可以不出现，最多只能出现一次。</p><p>所以，当新添加的<code>plugins</code>节点，如果添加在<code>properties</code>,<code>settings</code>,<code>typeAliases</code>,<code>typeHandlers</code>,<code>objectFactory</code>, <code>objectWrapperFactory</code>这些节点之前，则会报错。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器CPU过高排查</title>
      <link href="/server/cpu.html"/>
      <url>/server/cpu.html</url>
      
        <content type="html"><![CDATA[<p>CPU较高</p><a id="more"></a><ul><li>找出CPU比较高的进程PID</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top</div></pre></td></tr></table></figure><ul><li>打印该进程下线程的CPU占用比较高的tid</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">top -Hp &#123;PID&#125;</div></pre></td></tr></table></figure><ul><li>将该tid进行16进制转换id</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf &quot;%x\n&quot; &#123;tid&#125;</div></pre></td></tr></table></figure><ul><li>打印线程的堆栈信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jstack &#123;PID&#125; |grep &#123;id&#125; -A 100</div></pre></td></tr></table></figure><p>那么既然找到了问题，剩下就只能通过，数据库索引、SQL优化、算法优化、快速返回等方法来最这段代码优化。</p>]]></content>
      
      
      <categories>
          
          <category> server </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL对比表结构</title>
      <link href="/MySQL/diff.html"/>
      <url>/MySQL/diff.html</url>
      
        <content type="html"><![CDATA[<p>对比MySQL不同环境下的表结构。</p><a id="more"></a><ul><li>安装<code>mysql-connector-python</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install mysql-connector-python</div></pre></td></tr></table></figure><ul><li>安装<code>mysql-utilities</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install mysql-utilities</div></pre></td></tr></table></figure><ul><li>安装<code>mysql_config_editor</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install mysql_config_editor</div></pre></td></tr></table></figure><ul><li>配置信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_config_editor set --login-path=name --host=host --port=port --user=user --password</div></pre></td></tr></table></figure><p>要对比至少需要源信息和目标信息</p><ul><li>移除信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_config_editor remove --login-path=name --host=host --port=port --user=user --password</div></pre></td></tr></table></figure><ul><li>查看所有</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql_config_editor print --all</div></pre></td></tr></table></figure><ul><li>Usage</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Usage: mysqldiff --server1=user:pass@host:port:socket --server2=user:pass@host:port:socket db1.object1:db2.object1 db3:db4</div></pre></td></tr></table></figure><ul><li>相同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ mysqldiff --server1=dev5 --server2=uat --difftype=sql profile.profile_note:profile.profile_note</div><div class="line"># server1 on l-ars5.dev.ep.cn0.sgrl.io: ... connected.</div><div class="line"># server2 on l-arsdb1.uat.op.tx3.sgrl.io: ... connected.</div><div class="line"># Comparing profile.profile_note to profile.profile_note           [PASS]</div><div class="line"># Success. All objects are the same.</div></pre></td></tr></table></figure><ul><li>不同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mysqldiff --server1=dev5 --server2=uat --difftype=sql profile.profile_note:profile.profile_note</div><div class="line"># server1 on l-ars5.dev.ep.cn0.sgrl.io: ... connected.</div><div class="line"># server2 on l-arsdb1.uat.op.tx3.sgrl.io: ... connected.</div><div class="line"># Comparing profile.profile_note to profile.profile_note           [FAIL]</div><div class="line"># Transformation for --changes-for=server1:</div><div class="line">#</div></pre></td></tr></table></figure><blockquote><p>注意: <code>--port</code> and <code>--socket</code> options are supported for the <code>set/remove</code> commands as of <strong>MySQL 5.6.11</strong></p></blockquote><p>参考：</p><ul><li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-config-editor.html" target="_blank" rel="external">mysql config editor</a></p></li><li><p><a href="https://docs.oracle.com/cd/E17952_01/mysql-utilities-1.5-en/mysqldiff.html" target="_blank" rel="external">mysqldiff</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Message缩写</title>
      <link href="/github/acronym.html"/>
      <url>/github/acronym.html</url>
      
        <content type="html"><![CDATA[<p>GitHub上一些缩写的Message含义</p><a id="more"></a><p>Here you go:</p><ul><li>LGTM — looks good to me</li><li>ACK — <em>acknowledgement</em>, i.e. agreed/accepted change</li><li>NACK/NAK —<em>negative acknowledgement</em>, i.e. disagree with change and/or concept</li><li>RFC — request for comments, i.e. I think this is a good idea, lets discuss</li><li>WIP — work in progress, do not merge yet</li><li>AFAIK/AFAICT — as far as I know / can tell</li><li>IIRC — if I recall correctly</li><li>IANAL — “I am not a lawyer”, <em>but I smell licensing issues</em></li></ul><p>Many projects in the crypto space also use the following (<em>popularised</em> by <a href="https://github.com/bitcoin/bitcoin/issues/6100" target="_blank" rel="external">Bitcoin</a>’s <a href="https://twitter.com/jgarzik/status/601815506291531776" target="_blank" rel="external"><em>hacker lingo</em></a>):</p><ul><li>Concept ACK — agree with the concept, but haven’t reviewed the changes</li><li>utACK (aka. Untested ACK) — agree with the changes and reviewed them, but didn’t test</li><li>Tested ACK — agree with the changes, reviewed and tested</li><li>ACK - A loose ACK can be confusing. It’s best to avoid them unless it’s a documentation/comment only change in which case there is nothing to test/verify; therefore the tested/untested distinction is not there.</li><li>NACK - Disagree with the code changes/concept. Should be accompanied by an explanation.</li></ul><p>These answers are usually part of the code review process and you would find them in <em>issues</em> or <em>pull requests</em> in Github.</p><p><em>Honorary mention: <strong>+1</strong></em> as the short form of ACK (and in many cases, Concept ACK). After the <a href="https://github.com/dear-github/dear-github" target="_blank" rel="external">famous “Dear Github” letter</a>, the platform has introduced <a href="https://github.com/blog/2119-add-reactions-to-pull-requests-issues-and-comments" target="_blank" rel="external">proper reactions</a> to declutter comments. No, this is not about making Github your next Facebook :)</p><p>You would also see the ACKs be included in commit messages, like how the Linux kernel does it since Git is being used:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Add get_random_long().Signed-off-by: Daniel Cashman &lt;dcashman@android.com&gt;Acked-by: Kees Cook &lt;keescook@chromium.org&gt;Cc: &quot;Theodore Ts&apos;o&quot; &lt;tytso@mit.edu&gt;Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;Cc: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;Cc: Catalin Marinas &lt;catalin.marinas@arm.com&gt;Cc: Will Deacon &lt;will.deacon@arm.com&gt;Cc: Ralf Baechle &lt;ralf@linux-mips.org&gt;Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;Cc: Paul Mackerras &lt;paulus@samba.org&gt;Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;Cc: David S. Miller &lt;davem@davemloft.net&gt;Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;Cc: Ingo Molnar &lt;mingo@redhat.com&gt;Cc: H. Peter Anvin &lt;hpa@zytor.com&gt;Cc: Al Viro &lt;viro@zeniv.linux.org.uk&gt;Cc: Nick Kralevich &lt;nnk@google.com&gt;Cc: Jeff Vander Stoep &lt;jeffv@google.com&gt;Cc: Mark Salyzyn &lt;salyzyn@android.com&gt;Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;</div></pre></td></tr></table></figure><p>Check out the “<a href="https://www.kernel.org/doc/html/v4.17/process/submitting-patches.html" target="_blank" rel="external">How to Get Your Change Into the Linux Kernel</a>” guide for a thorough explanation.</p><p>Similar short answers are used widely in software engineering and the open source community as they make communication more efficient.</p><p>You have surely seen the following in source code — TODO, FIXME, XXX and NOTE — and only wondered what <em>XXX</em> means?</p><p>Interested to see a lot more acronyms with explanation and perhaps a bit of history? Check out <a href="http://www.catb.org/jargon/html/index.html" target="_blank" rel="external">The Jargon File</a>. It is the definitive source since 1975.</p><p><strong>Bonus trivia</strong>: where does ACK/NACK comes from?</p><p>I would say it came from networking/interface protocols, perhaps the popularity of TCP caused widespread usage.</p><blockquote><p>SYN, SYN/ACK, ACK, FIN, ACK, FIN, ACK.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引原理</title>
      <link href="/MySQL/index.html"/>
      <url>/MySQL/index.html</url>
      
        <content type="html"><![CDATA[<p>众所周知，MySQL的InnoDB引擎采用B+树作为索引结构，为什么呢？</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>InnoDB存储引擎支持两种常见的索引：B+树索引、哈希索引。</p><ul><li>哈希索引<ul><li>自适应</li><li>InnoDB存储引擎根据表的使用情况自动为表生成哈希索引，不能人为干预</li></ul></li><li>B+树索引<ul><li>构造类似于二叉树</li><li>根据键值快速找到数据</li><li>B为Balance，因为B+树最早从平衡二叉树演化而来，但是B+树不是一个二叉树</li></ul></li></ul></blockquote><p><strong>B+树索引并不能找到一个给定键值的具体行。找到的只是被查找数据行所在的页。然后数据库通过把页读入内存，再在内存中进行查找，最后得到查找的数</strong>。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><blockquote><p>B+树是由二叉查找树(左&lt;根&lt;右) -&gt; 二叉树(也称AVL树，二叉树的基础上，满足任何节点的左右两个子树共度最大差为1) -&gt; B树，变化而来。</p></blockquote><ul><li>二叉树缺点：只规定了简单结构，存在多种深度可能，导致二叉树的效率低，所以引入了平衡二叉树。</li><li>红黑树与AVL树类似，都是在进行插入和删除时通过特定的操作保持二叉树的平衡，从而获得较高的查找性能。在Java中<a href="https://hg.openjdk.java.net/jdk/jdk/file/34bbd91b1522/src/java.base/share/classes/java/util/TreeSet.java" target="_blank" rel="external">TreeSet</a>、<a href="https://hg.openjdk.java.net/jdk/jdk/file/34bbd91b1522/src/java.base/share/classes/java/util/TreeMap.java" target="_blank" rel="external">TreeMap</a>的底层就是用的这个方法。<ul><li>节点是红色或黑色</li><li>根节点是黑色</li><li>叶子节点（nil,空节点）是黑色</li><li>每个红色节点的两个子节点都是黑色</li></ul></li><li>B通常理解成是Balance的意思，B- tree 就是B树，简称平衡树。<ul><li>B树是平衡多路查找树（有多个查找路径，不止2个），是一种平衡的多叉树。因为B树是平衡树，每个节点到叶子节点的高度都是相同的，这样可以保证B树的查询是稳定的。</li><li>使用B树可以显著减少定位记录时所经历的中间过程，从而快速定位，加快存取速度。</li><li>与二叉树相比，B-tree利用多个分支（二叉树只有2个分支）节点，<strong>减少了获取记录时所经历的节点数</strong>，从而达到节省存取时间的目的。 <ul><li>每个节点的关键字增多了，特别是B树应用到数据库中的时候。</li><li>所有的页节点都在同一层上</li></ul></li></ul></li></ul><blockquote><p>数据库充分利用了磁盘块的原理（磁盘数据的存储采用的是块的形式进行存储，每个块的大小一般为4k,每次去取数据的时候，就是取出这个4k的大小，而不是只取出想要的大小。就是说每次IO的时候，同一磁盘块的数据都是一次性提取出来）。把树的节点关键字增多后，树的层级比原来二叉树的层级少了，这样就可以减少数据查找的次数 ，降低复杂度了。</p></blockquote><ul><li>B+ Tree 是在 B树基础上的优化，使其更适应存储索引结构<ul><li>B树的结构中，每个节点不仅包括数据的key值，也包括data值。而每一页的存储空间都是有限的，如果data数据较大的时候，会导致每一页中存储的key比较少，当存储的数据量比较大时，同样会导致B树的查询深度很大，增加磁盘IO次数，进而影响查询效率</li><li>B+ Tree中，非叶子节点上只存储key的信息，这样可以加大每一页中存储key的数量，降低B+ Tree的高度。<ul><li>非叶子节点只存储key信息</li><li>所有叶子节点之间有一个链指针</li><li>B+树的非叶子节点只进行数据的索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样。</li><li>B+树的应用场景主要是数据库索引结构，数据库的查询有时候可能一次多条，如果分布在不同的层（树的层级），那么在取出数据后，还需要做排序。而在一个层级上，且有指针连接各个叶子节点也使得查询效率更高。</li></ul></li></ul></li></ul><h2 id="B树查找过程"><a href="#B树查找过程" class="headerlink" title="B树查找过程"></a>B树查找过程</h2><p><strong>假设每一个磁盘页正好存放一个B树的节点，而子树的指针就是存放另一个磁盘页的地址。</strong></p><p>那么查找操作就是：</p><ul><li>首先从根节点(从磁盘调出数据，进行第一次磁盘I/O，数据读入内存进行查找)，内存中可以顺序也可以二分，如果找到要查找的那个数则停止，否则要确认指针的位置，也就是确认是那颗子树，然后递归下去。</li></ul><h2 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h2><p>首先要明确，B表示balance，B树是一种多路自平衡的搜索树。</p><blockquote><p>B树的每一个节点最多包含k个孩子，k被称为B树的阶，<strong>k的大小取决于磁盘页的大小。</strong></p></blockquote><p>B树类似于平衡二叉树，不同的是B树允许每个节点有更多的子节点。</p><h3 id="B树特点"><a href="#B树特点" class="headerlink" title="B树特点"></a>B树特点</h3><ul><li>所有键值分布在整棵树中</li><li>任何一个关键字出现且只出现在一个节点中</li><li>搜索有可能在非叶子节点结束</li><li>在关键字全集内做一次查找，性能逼近二分查找</li></ul><p>根据B树的定义，可知检索一次最多需要访问h个节点。根据上面的局部性原理和磁盘预读，B树中用了这个技巧：<strong>每次新建节点时，直接申请一个页的空间，这样就保证了一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需要一次I/O。</strong></p><p>B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在<strong>数据库中基于范围的查询是非常频繁</strong>（比如查询某段时间之内的数据）的，而B树不支持这样的操作或者说<strong>效率太低</strong>（前文已经说明效率低的原因）</p><p>B树中一次检索最多需要<code>h-1</code>次I/O(根节点常驻内存)，渐进复杂度$$O(log_d^N)$$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小(通常不超过3)。红黑树这种结构，h要深的多。逻辑上很近的节点(父子)物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度为O(h)，效率明显比B树差很多。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的变种，也是一种多路搜索树，与B树的不同点在于：</p><ul><li>所有关键字存储在叶子节点出现，内部节点(非叶子节点并不存储真正的data)</li><li>为所有叶子节点增加了一个链指针，就形成了带有顺序访问指针的B+树（提高区间访问性能）</li><li>每个节点的指针上限为2d</li><li>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</li></ul><h3 id="为什么选择B-树"><a href="#为什么选择B-树" class="headerlink" title="为什么选择B+树"></a>为什么选择B+树</h3><ul><li>B+树更适合外部存储，由于内节点无data域(负责索引)，一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确，也意味着B+树单次磁盘I/O的信息量大于B树，I/O效率更高。</li><li>MySQL是一种关系型数据库，区间访问时常见的一种情况，B+树叶节点增加的链指针，加强了区间访问性，可使用在范围区间查询等。而B树每个节点key和data在一起，则无法区间查找，因为需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ul><h2 id="为什么不用二叉查找树实现"><a href="#为什么不用二叉查找树实现" class="headerlink" title="为什么不用二叉查找树实现"></a>为什么不用二叉查找树实现</h2><blockquote><p>MySQL是基于磁盘的数据库系统，索引往往以索引文件的形式存储在磁盘上。因为数据量很大的时候索引文件大小可能达到几个G。所以在利用索引查询时，不能把整个索引全部加载到内存，只能逐一加载每一个磁盘页(对应着索引树的节点)，修改之后又写回到磁盘。索引查找过程就要产生磁盘I/O，比内存操作要高几个数量级，所以MySQL索引的结构就要尽量减少查找过程中磁盘I/O的存取次数。</p></blockquote><p>二叉查找树的时间复杂度为O(longN)，从算法逻辑上讲查找速度和比较速度都是最小的。但是要考虑<strong>磁盘I/O</strong>，节约在磁盘上花的时间，对搜索树的性能提高是最有效的，所以文件系统及数据库系统普遍采用B树或B+树作为索引结构。</p><h2 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h2><p>在使用数据库时，查询是最主要的功能之一。所以需要查询数据的速度尽可能的快，所以数据库的设计者会从查询算法的角度进行优化。</p><p>最基本的查询算法当前是顺序查找，但复杂度为O(n)会使得在数据量很大时效率很差。一些其他查找算法，诸如二分查找或二叉树查找效率更高，但每种算法都只能应用于特定的数据结构之上。例如，二分查找要求被检索的数据有序，而二叉树查找只能应用于二叉查找树。所以，在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种个方式指向数据，这样就可以实现高级查找算法。这种数据结构，就是索引。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1g36ymajdtlj20gc08974w.jpg" alt=""></p><p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条数据，最左边是数据的物理地址（逻辑相邻的记录在磁盘上的物理存储地址并不一定是相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录的物理地址指针，这样就可以运用二叉查找在O(logN)的复杂度内获取到相应数据。虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或红黑树实现的，为什么呢？</p><h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h2><p>磁盘是块设备。也就是说磁盘的读写单位是以块为单位，一般块大小从0.5K到4K。</p><blockquote><p>一个扇区512byte，也就是0.5K，一页是4K，那就是一页是8个扇区的大小。</p></blockquote><p>即使只读取一个字节，磁盘也会将包含该字节的所有数据读取。其中，最占用时间的是磁盘的寻道，也就是磁头在盘片上找到需要读取的块所在的位置，而在磁盘上顺序读取数据所花的时间是占比比较小的。</p><h3 id="磁盘如何读取"><a href="#磁盘如何读取" class="headerlink" title="磁盘如何读取"></a>磁盘如何读取</h3><p>由于磁盘的读取速度与内存之间的鸿沟，为了提高效率，磁盘在读取数据时，每次都会预读。磁盘在读取完需要的数据，会顺序向后读一定长度的数据放入内存，为什么要预读？</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><blockquote><p>当一个数据被用到时，其附近的数据也通常会马上被使用，程序运行期间所需要的数据通常比较集中。</p></blockquote><h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><p>磁盘顺序读取的效率很高(无寻道时间，只需很少的旋转时间)。所以对于有局部性的程度来说，预读可以提高I/O效率。</p><p>预读的长度一般为页(Page)的整倍数。</p><blockquote><p>页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相扽的块，每格存储块称为一页。</p><p>MySQL(默认使用InnoDB引擎)，将记录按页的方式进行管理。<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-physical-structure.html" target="_blank" rel="external">每页大小默认为16K</a>。Linux默认页大小为4K。</p></blockquote><p>要减少磁盘上花的时间，就可以从减少读盘次数以及减少寻道时间着手。<strong>B树采取的方法就是，充分的利用盘块的空间，在一个盘块种尽可能多得存储信息，或者在连续的盘块地址上存储尽可能多的信息。</strong>在数据结构上的变化就是每个节点存储多个key信息以及包含多个子节点。</p><p><strong>磁盘的I/O次数由树的高度决定的。</strong>在最坏的情况下磁盘的I/O数等于索引树的高度。而B树是一颗平衡的m-路查找树，假设高度为h，每一个节点最多容纳m-1个关键字，所以一颗m-路查找树总共可容纳$$m^k-1$$个关键字。与二叉查找树比较，当高度为h，能容$$2^h-1$$个关键字，若高度为3，则二叉查找树只能容纳7个关键字，而对于200-路查找树可容纳$$200^3-1$$个关键字。</p><p>为了减少磁盘的I/O次数，就需要把原来”瘦高”的树结构变得”矮胖”，而这正满足B树的特质之一，内节点出度d越大，索引的性能越好，而出度的上限取决于节点内key和data的大小：$$d_{max}=floor(pagesize/(keysize+datasize+pointsize))$$</p><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，在MySQL中主要为MyISAM和InnoDB两个存储引擎的索引实现。</p><h3 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h3><p>MyISAM引擎使用B+树作为索引结构，叶节点的data域存放的是数据记录的<strong>地址</strong>。索引文件和数据文件分离，索引文件仅保存数据记录的地址。</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1g3eq7vgfgpj20ig0eujs1.jpg" alt=""></p><p>假设以Col1为主键，则上图是MyISAM表的主索引示意。MyISAM的索引文件仅仅保存数据记录的地址。</p><p>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1g3eq7vj9q3j20ig0eu3z6.jpg" alt=""></p><p>同样也是B+树，data域保存数据记录的地址。</p><p>因此，MyISAM中索引检索的算法为：</p><ul><li>按照B+树搜索算法搜索索引，如果指定的key存在，则取出其data域的值</li><li>以data域的值为地址，读取相应数据记录</li></ul><p>MyISAM的索引方式也叫做”非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h3 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h3><p>InnoDB也是用B+树作为索引结构，但实现方式与MyISAM不同。</p><p><strong>InnoDB的数据文件本身就是索引文件。</strong>表数据文件本身就是按B+树组织的一个索引结构，叶节点的data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1g3eq7vg0baj20f306pjrj.jpg" alt=""></p><p>可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。</p><ul><li>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键(MyISAM可以没有)。</li></ul><p>如果没有显式制定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。</p><ul><li>InnoDB的辅助索引data域存储相应记录主键的值而不是地址。<ul><li>InnoDB的所有辅助索引都引用主键作为data域</li></ul></li></ul><blockquote><p>聚集索引Clustered Index</p><ul><li>按照主键构建B+树</li><li>叶子节点：存放的是数据表的行记录的数据<ul><li>数据页</li><li>用双向链表进行关联，按照主键顺序排列</li></ul></li></ul><p>辅助索引Secondary Index(非聚集索引)</p><ul><li>叶子节点除了存储键值信息外，在索引行还包含了bookmark，也就是找到索引对应的行数据</li></ul></blockquote><p><strong>问题：为什么不建议使用过长的字段作为主键？</strong></p><blockquote><p>所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大</p></blockquote><p><strong>问题：为什么不建议使用非单调的字段作为InnoDB的主键</strong></p><blockquote><p>InnoDB数据文件本身是B+树，非单调的主键会造成在插入新纪录时数据文件为了维持B+树的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p></blockquote><h2 id="索引使用及优化"><a href="#索引使用及优化" class="headerlink" title="索引使用及优化"></a>索引使用及优化</h2><blockquote><p>高效使用索引的首要条件是知道什么样的查询会使用到索引</p></blockquote><ul><li>MySQL优化<ul><li>结构优化Scheme optimization</li><li>查询优化Query optimization</li></ul></li></ul><hr><p>MySQL官方提供了<a href="https://dev.mysql.com/doc/employee/en/" target="_blank" rel="external">示例数据库</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> git clone git@github.com:datacharmer/test_db.git</div><div class="line"><span class="meta">$</span> cd test_db</div><div class="line"><span class="meta">$</span> mycli &lt; employees.sql</div></pre></td></tr></table></figure><p>因为是在本地测试，所以用户名和host都可以省略，直接敲密码即可。执行后会有下面的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">INFO</div><div class="line">CREATING DATABASE STRUCTURE</div><div class="line">INFO</div><div class="line">storage engine: InnoDB</div><div class="line">INFO</div><div class="line">LOADING departments</div><div class="line">INFO</div><div class="line">LOADING employees</div><div class="line">INFO</div><div class="line">LOADING dept_emp</div><div class="line">INFO</div><div class="line">LOADING dept_manager</div><div class="line">INFO</div><div class="line">LOADING titles</div><div class="line">INFO</div><div class="line">LOADING salaries</div><div class="line">data_load_time_diff</div><div class="line">NULL</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL概述</title>
      <link href="/MySQL/intro.html"/>
      <url>/MySQL/intro.html</url>
      
        <content type="html"><![CDATA[<p>宏观来看</p><a id="more"></a><ul><li><a href="https://dev.mysql.com/downloads/mysql/8.0.html" target="_blank" rel="external">MySQL 8.0</a>采用GPL协议</li><li>单进程多线程</li><li>查看MySQL查找文件的顺序：<code>mysql --help | grep my.cnf</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mysql --help | grep my.cnf</div><div class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</div><div class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf</div></pre></td></tr></table></figure><p>多个配置文件，以最后为准；缺失配置文件，按照编译时的默认参数设置。</p><ul><li>启动方式：<code>mysqld</code>、<code>mysqld_safe</code>、<code>mysqld_multi</code>(主要用于多实例启动)</li></ul><p>首先当使用<code>service mysqld start</code>或者<code>/etc/init.d/mysqld start</code>这样的方式启动的时候，其实是使用了<code>mysql.server</code>这个脚本，这个脚本默认会调用<code>mysqld_safe</code>来启动<code>mysqld</code>，所以通常我们启动mysql之后查看进程的时候会发现有<code>mysqld</code>和<code>mysqld_safe</code>这两个进程存在。这两种通常都是<strong>单实例</strong>的启动方式，当然也可以使用mysqld来启动多实例的。而<code>mysqld_multi</code>用来启动多实例，也是通过先调用<code>mysqld_safe</code>和<code>mysqld</code>来启动mysql的。参考：<a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-server.html" target="_blank" rel="external">MySQL Server</a></p><ul><li>启动原理：启动程序为<code>mysql.server</code>，用到的程序my_print_defaults、myslqd_safe和函数parse_server_arguments<ul><li>my_print_defaults:读取my.cnf配置文件，输出参数传递给parse_server_arguments，该程序只读my.cnf中[mysqld]中的参数。</li><li>parse_server_arguments：该函数处理my_print_defaults传递过来的参数赋值给–basedir、–datadir、–pid-file、–server-startup-timeout</li><li>myslqd_safe:mysqld_safe程序调用mysqld程序来启动mysql服务,[mysqld_safe]会覆盖mysqld部分中的参数</li><li>mysqld_multi会读取配置文件中的[mysqld_muti],[mysqldN]下面的参数，N需要时一个整数，建议用端口号表示，该部分的配置会覆盖[mysqld]部分中的配置</li><li>在mysqld进程挂掉的时候，mysqld_safe进程会监测到并重新将mysqld启动起来</li></ul></li></ul><p><a href="https://dev.mysql.com/doc/refman/8.0/en/programs-overview.html" target="_blank" rel="external">My SQL Programs Overview</a></p><ul><li>查看数据库存放路径：<code>show variables like &#39;%datadir%&#39;\G</code></li><li>数据库是由 一个个文件组成 （一般来说都是二进制的文件） 的，如果要对这些文件执行诸如 SELECT 、 INSERT 、UPDATE和DETELE 之类的操作 ，不能通过简单的操作文件来更改数据库的内容 ， 需要通过数据库实例来完成对数据库的操作 。</li></ul><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><ul><li>架构<ul><li>连接池组件</li><li>管理服务和工具组件</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓冲（cache）组件</li><li>插件式存储引擎</li><li>物理文件</li></ul></li></ul><p><img src="https://3.bp.blogspot.com/-WllJC9xfxqg/VxTbuAoMm4I/AAAAAAAAHzA/1tF7Sxx8Y34levMmR9fYPZfDQDHVdWzKwCLcB/s1600/MySQL%2BArchitecture.png" alt=""></p><p>MySQL最重要的特点就是其插件式的表存储引擎，这是与其他数据库最重要的区别，它提供了一些列标准的管理和服务支持，这些标准与存储引擎无关，例如SQL分析器和优化器等。存储引擎是基于表的。MySQL的核心是存储引擎。</p><h3 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-introduction.html" target="_blank" rel="external">InnoDB存储引擎</a></h3><blockquote><p>完整支持ACID事务，主要面向在线事务处理(OLTP)方面的应用</p></blockquote><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-architecture.html" target="_blank" rel="external">InnoDB Architecture</a></p><p><img src="https://dev.mysql.com/doc/refman/5.6/en/images/innodb-architecture.png" alt=""></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>行锁设计</li><li>支持外键</li><li>支持非锁定读<ul><li>默认情况下读取操作不会产生锁</li></ul></li><li>InnoDB存储引擎将数据放在一个逻辑的表空间中，由InnoDB自身进行管理。从MySQL4.1版本开始，它可以将每个InnoDB存储引擎的表单独存放到一个独立的<code>ibd</code>文件中。</li><li>InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并实现了SQL标准的4种隔离级别，默认为<code>REPEATABLE</code>级别。同时使用一种被称为<code>next-key locking</code>的策略来避免幻读(phantom)现象的产生。</li><li>InnoDB引擎还提供了插入缓冲(insert buffer)、二次写(double write)、自适应哈希索引(adaptive hash index)、预读(read ahead)等高性能和高可用的功能。</li><li>表中数据的存储，采用聚集(clustered)的方式。每张表的存储都按主键的顺序存放，如果没有显式地在表定义时指定主键，InnoDB存储引擎会为每一行生成一个6字节的ROWID，并以此为主键。</li><li>最有效的利用内存和CPU</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-best-practices.html" target="_blank" rel="external">最佳实践</a></h4><ul><li>指定主键或自增的值</li><li>关闭自动提交</li><li>将一组相关的DML操作分组到事务中</li><li>不使用LOCK TABLES语句<ul><li>InnoDB可以同时处理多个会话，同时读取和写入同一个表，而不会牺牲可靠性或高性能。要获得对一组行的独占写访问权，请使用SELECT … FOR UPDATE语法仅锁定要更新的行。</li></ul></li><li>启用innodb_file_per_table选项或使用通用表空间将表的数据和索引放入单独的文件中，而不是系统表空间。</li><li>在不牺牲读/写功能的情况下压缩InnoDB表</li><li>使用选项–sql_mode = NO_ENGINE_SUBSTITUTION运行服务器，以防止在CREATE TABLE的ENGINE =子句中指定的引擎出现问题时使用其他存储引擎创建表。</li></ul><h3 id="架构模型"><a href="#架构模型" class="headerlink" title="架构模型"></a>架构模型</h3><p><img src="https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/httpatomoreillycomsourceoreillyimages206364.png" alt=""></p><ul><li>InnoDB有很多内存块，这些内存块组成了一个大的内存池，负责<ul><li>维护所有进程/线程需要访问的多个内部数据结构</li><li>缓存磁盘上的数据，方便快速地读取，并且在对磁盘文件的数据进行修改之前在这里缓存</li><li>重做日志(redo log)缓冲</li></ul></li></ul><p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外，将已修改的数据文件刷新到磁盘文件，同时保存在数据库发生异常情况下InnoDB能恢复到正常状态。</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-threads.html" target="_blank" rel="external">后台线程</a></h3><p>InnoDB存储引擎是在master thread的线程上几乎实现了所有功能。默认情况下，InnoDB存储引擎的后台线程有7个：</p><ul><li>IO Thread：4<ul><li>Windows平台可以修改：配置文件中的innodb_file_io_threads，默认为4</li><li>Linux平台不能调整</li></ul></li><li>master thread：1</li><li>锁(lock)监控线程：1</li><li>错误监控线程：1</li></ul><h3 id="查询配置"><a href="#查询配置" class="headerlink" title="查询配置"></a>查询配置</h3><p>当前环境：</p><p>版本：5.7.22</p><p>平台：MacOS</p><ul><li>查询InnoDB引擎状态：show engine innodb status\G;`</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">--------</div><div class="line">FILE I/O</div><div class="line">--------</div><div class="line">I/O thread 0 state: waiting for i/o request (insert buffer thread)</div><div class="line">I/O thread 1 state: waiting for i/o request (log thread)</div><div class="line">I/O thread 2 state: waiting for i/o request (read thread)</div><div class="line">I/O thread 3 state: waiting for i/o request (read thread)</div><div class="line">I/O thread 4 state: waiting for i/o request (read thread)</div><div class="line">I/O thread 5 state: waiting for i/o request (read thread)</div><div class="line">I/O thread 6 state: waiting for i/o request (write thread)</div><div class="line">I/O thread 7 state: waiting for i/o request (write thread)</div><div class="line">I/O thread 8 state: waiting for i/o request (write thread)</div><div class="line">I/O thread 9 state: waiting for i/o request (write thread)</div></pre></td></tr></table></figure><ul><li>查询引擎版本：<code>show variables like &#39;innodb_version&#39;\G</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Variable_name | innodb_version</div><div class="line">Value         | 5.7.22</div></pre></td></tr></table></figure><ul><li>查询IO线程数量：<code>show variables like &#39;innodb_%io_threads&#39;\G</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">***************************[ 1. row ]***************************</div><div class="line">Variable_name | innodb_read_io_threads</div><div class="line">Value         | 4</div><div class="line">***************************[ 2. row ]***************************</div><div class="line">Variable_name | innodb_write_io_threads</div><div class="line">Value         | 4</div></pre></td></tr></table></figure><h3 id="线程调优"><a href="#线程调优" class="headerlink" title="线程调优"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/thread-pool-tuning.html" target="_blank" rel="external">线程调优</a></h3><h4 id="thread-pool-size"><a href="#thread-pool-size" class="headerlink" title="thread_pool_size"></a><code>thread_pool_size</code></h4><blockquote><ul><li>线程池数量决定最佳性能</li><li>在启动时设置</li></ul></blockquote><ul><li>InnoDB<ul><li>建议值24-36</li><li>对于DBT2和Sysbench等工作负载：36左右</li><li>对于非常高写的工作负载，最佳设置有时可能更低。</li></ul></li><li>MyISAM<ul><li>最佳性能：4-8</li><li>较高的值往往会对性能产生轻微负面影响但不会产生显着影响。</li></ul></li></ul><h4 id="thread-pool-stall-limit"><a href="#thread-pool-stall-limit" class="headerlink" title="thread_pool_stall_limit"></a><code>thread_pool_stall_limit</code></h4><blockquote><ul><li>确保服务器不会被完全阻止</li><li>运行时可修改</li></ul></blockquote><ul><li>上限为6秒，以防止出现死锁服务器的风险</li><li>假设服务器执行工作负载，即使服务器加载，99.9％的语句在100ms内完成，其余语句在100ms到2小时之间相当均匀地传播。在这种情况下，将thread_pool_stall_limit设置为10（意味着100ms）是有意义的。</li><li>对于主要执行非常简单的语句的服务器，默认值为60ms是可以的。</li></ul><blockquote><p>如果启用了tp_thread_group_stats表，查询确定已停止的已执行语句的比例：<code>SELECT SUM（STALLED_QUERIES_EXECUTED）/ SUM（QUERIES_EXECUTED）FROM performance_schema.tp_thread_group_stats;</code>这个数字应该尽可能低。要降低语句停顿的可能性，请增加thread_pool_stall_limit的值。</p></blockquote><p>当一个语句到达时，它在实际开始执行之前可以延迟的最长时间是多少？假设以下条件适用：</p><p>在低优先级队列中排队有200个语句。</p><p>在高优先级队列中排队有10个语句。</p><p>thread_pool_prio_kickup_timer设置为10000（10秒）。</p><p>thread_pool_stall_limit设置为100（1秒）。</p><p>在最坏的情况下，10个高优先级语句代表10个持续执行很长时间的事务。因此，在最坏的情况下，没有语句将被移动到高优先级队列，因为它总是已经包含等待执行的语句。 10秒后，新语句有资格移动到高优先级队列。但是，在可以移动它之前，它之前的所有语句也必须移动。这可能需要另外2秒，因为每秒最多100个语句被移动到高优先级队列。现在，当语句到达高优先级队列时，可能会有许多长时间运行的语句。在最坏的情况下，每一个都会陷入停滞状态。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="http://funwithmysql.blogspot.com/2012/08/mysql-scalability-architecture.html" target="_blank" rel="external">MySQL Scalability Architecture</a></p><p><a href="https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch01.html" target="_blank" rel="external">High Performance MySQL</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch查询概述</title>
      <link href="/es/es_query.html"/>
      <url>/es/es_query.html</url>
      
        <content type="html"><![CDATA[<p>就会用多无聊，看点别的</p><a id="more"></a><p><img src="https://github.com/super2bai/super2bai.github.io/blob/master/images/ES_Query_Summary.png?raw=true" alt=""></p><h3 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h3><p><code>GET /blog/_doc/3?pretty</code></p><p>根据<code>index</code>、<code>type</code>、<code>id</code>搜索文档</p><blockquote><p>在任意的查询字符串增加<code>pretty</code>参数，美化输出，但<code>_source</code>字段不会被美化，结果会与输入保持一致。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"_index"</span> : <span class="string">"blog"</span>,</div><div class="line">  <span class="string">"_type"</span> : <span class="string">"_doc"</span>,</div><div class="line">  <span class="string">"_id"</span> : <span class="string">"3"</span>,</div><div class="line">  <span class="string">"_version"</span> : <span class="number">1</span>,</div><div class="line">  <span class="string">"_seq_no"</span> : <span class="number">2</span>,</div><div class="line">  <span class="string">"_primary_term"</span> : <span class="number">1</span>,</div><div class="line">  <span class="string">"found"</span> : <span class="literal">true</span>,</div><div class="line">  <span class="string">"_source"</span> : &#123;</div><div class="line">    <span class="string">"contect"</span> : <span class="number">3</span>,</div><div class="line">    <span class="string">"date"</span> : <span class="string">"2019-07-23"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><p>没有指定任何查询条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /_search</div></pre></td></tr></table></figure><p>返回集群中所有索引下的所有文章</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"><span class="string">"took"</span>: <span class="number">4</span>,</div><div class="line"><span class="string">"timed_out"</span>: <span class="literal">false</span>,</div><div class="line"><span class="string">"_shards"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: <span class="number">1</span>,</div><div class="line"><span class="string">"successful"</span>: <span class="number">1</span>,</div><div class="line"><span class="string">"skipped"</span>: <span class="number">0</span>,</div><div class="line"><span class="string">"failed"</span>: <span class="number">0</span></div><div class="line">&#125;,</div><div class="line"><span class="string">"hits"</span>: &#123;</div><div class="line"><span class="string">"total"</span>: &#123;</div><div class="line"><span class="string">"value"</span>: <span class="number">3</span>,</div><div class="line"><span class="string">"relation"</span>: <span class="string">"eq"</span></div><div class="line">&#125;,</div><div class="line"><span class="string">"max_score"</span>: <span class="number">1.0</span>,</div><div class="line"><span class="string">"hits"</span>: [&#123;</div><div class="line"><span class="string">"_index"</span>: <span class="string">"blog"</span>,</div><div class="line"><span class="string">"_type"</span>: <span class="string">"_doc"</span>,</div><div class="line"><span class="string">"_id"</span>: <span class="string">"1"</span>,</div><div class="line"><span class="string">"_score"</span>: <span class="number">1.0</span>,</div><div class="line"><span class="string">"_source"</span>: &#123;</div><div class="line"><span class="string">"contect"</span>: <span class="number">1</span>,</div><div class="line"><span class="string">"date"</span>: <span class="string">"2019-07-21"</span></div><div class="line">&#125;</div><div class="line">&#125;]</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>took</strong>：执行整个搜索请求耗费的毫秒数</p><p><strong>timed_out</strong>：是否超时。如果响应时间比完成结果更重要，可以指定：<code>10ms</code>十毫秒或<code>1s</code>一秒。在超时之前，会返回已经从每个分片获取的结果。</p><blockquote><p>timeout不是停止执行查询，仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。</p><p><strong>使用超时是因为SLA( 服务等级协议)是更重要的，而不是因为想去中止长时间运行的查询。</strong></p></blockquote><p><strong>_shards</strong>：查询中参与分片的总数，以及这些分片成功、失败的个数，被跳过的(跳过的原因？)</p><p><strong>hits</strong>：</p><p><code>total</code>：匹配到的文档总数，一个hits数组包含所查询结果的前十个文档</p><p><code>source</code>：可以直接从返回的结果中使用整个文档。不像其他的搜索引擎(其他的哪些?)，仅仅返回文档的ID，需要单独去获取文档</p><p><code>_score</code>：匹配度。文档按照_score降序排列。1是中性的</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>当索引一个文档，它被存储在单独一个主分片上。Elasticsearch是如何知道文档属于哪个分片的呢？创建一个新文档时，它是如何知道是应该存储在分片1还是分片2上的呢？</p><p>进程不能是随机的，因为将来要检索文档。事实上，它根据一个简单的算法决定：</p><p><code>shard = hash(routing) % number_of_primary_shards</code></p><p><code>routing</code>：任意字符串，默认是<code>_id</code>，支持自定义。</p><ul><li>logstash中修改output中的routing值，es中不做修改。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">output &#123;</div><div class="line">elasticsearch &#123;</div><div class="line">  hosts =&gt; "http://localhost:9200"</div><div class="line">  index =&gt; "movies"</div><div class="line">  document_id =&gt; "%&#123;id&#125;"</div><div class="line">  routing =&gt; "%&#123;category&#125; ###关键字</div><div class="line">&#125;</div><div class="line">stdout &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>kibana查询时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET /movies/_search?routing=api ###routing指定是字段中具体的值</div></pre></td></tr></table></figure><ul><li>指定routing参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">POST /blog/_doc?routing=2019-01-04</div><div class="line">&#123;  </div><div class="line">&quot;contect&quot;:4,</div><div class="line">&quot;date&quot;:&quot;2019-01-04&quot;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会按照日期将文档置于同一分片上</p><hr><p>其他：</p><ul><li>在所有索引中搜索：<code>/_search</code></li><li>在单索引搜索：<code>/blog/_search</code></li><li>在多索引中搜索：<code>/blog,movie/_search</code></li><li>模糊搜索： <code>/b*/_search</code></li></ul><blockquote><p>搜索一个索引有5个主分片和5个索引各有一个分片事实上是一样的。</p></blockquote><h3 id="document模型设计"><a href="#document模型设计" class="headerlink" title="document模型设计"></a>document模型设计</h3><p>对于MySQL，尽量避免一些复杂查询，在Elasticsearch中，应同样避免复杂查询，会影响性能。</p><p>对于计算的部分，在应用中完成，将计算后的数据直接写入es中。搜索的时候，就不需要利用es的搜索语法来完成复杂查询，比如 join/nested/parent-child 搜索都要尽量避免，性能都很差的。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>如果想看第11个文档，怎么办？</p><p>和SQL使用<code>LIMIT</code>关键字返回只有一页的结果一样，Elasticsearch接受<code>from</code>和<code>size</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">size: 结果数，默认10</div><div class="line">from: 跳过开始的结果数，默认0</div></pre></td></tr></table></figure><p>如果想每页显示5个结果，页码从1到3，那请求如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GET /_search?size=5</div><div class="line">GET /_search?size=5&amp;from=5</div><div class="line">GET /_search?size=5&amp;from=10</div></pre></td></tr></table></figure><p>应该当心分页太深或者一次请求太多的结果。结果在返回前会被排序。但是记住一个搜索请求常常涉及多个分片。每个分片生成自己排好序的结果，它们接着需要集中起来排序以确保整体排序正确。</p><p>假如每页10条数据，查询第100页，实际上是会把每个 shard 上存储的前 <code>1000</code> 条数据都查到一个协调节点上，如果你有个 5 个shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>分布式的，你要查第100页的10条数据，不可能说从5个 shard，每个 shard 就查 2 条数据？最后到协调节点合并成 10 条数据？你必须得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长。非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p><p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10秒 才能查出来一页数据了。</p><blockquote><h3 id="在集群系统中深度分页"><a href="#在集群系统中深度分页" class="headerlink" title="在集群系统中深度分页"></a>在集群系统中深度分页</h3><p>为了理解为什么深度分页是有问题的，让我们假设在一个有5个主分片的索引中搜索。当我们请求结果的第一页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给<strong>请求节点(requesting node)</strong>，它再排序这所有的50个结果以选出顶端的10个结果。</p><p>现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！</p><p>可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何语句不能返回多于1000个结果的原因。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/10115652-df97de55bce2cebf.png?imageMogr2/auto-orient/" alt="img"></p><ul><li><code>filesystem cache</code></li></ul><blockquote><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code>，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file</code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p></blockquote><ul><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.3/_pre_loading_data_into_the_file_system_cache.html" target="_blank" rel="external">数据预热</a></li></ul><blockquote><p>把一些热点数据，提前访问刷到<code>filesystem cache</code>，再次搜索时，直接走内存。 </p></blockquote><ul><li>冷热分离</li></ul><blockquote><p>冷数据写入一个索引中，热数据写入另外一个索引中，这样可以确保热数据在被预热后，尽量都留在<code>filesystem cache</code>中，别让冷数据给冲刷掉。</p></blockquote><hr><p>es建索引写入数据，数据最先是存在内存buffer里的，然后再刷入到lucene的底层文件segment中；<br>写入segment完毕后再执行refresh操作，refresh操作后，数据将commit到磁盘中。<br>数据刷入到了磁盘，就可以执行查询操作了。</p><p>过程简单描述如下：内存buffer–&gt;segment–&gt;refresh–&gt;磁盘</p><p>注意，这些过程，会有translog记录；translog存在的意义就是保证数据刷入的可靠性；<br>es建索引写入数据的过程是内存到磁盘的过程，这个过程有日志的记录，<br>那就是translog，当数据还在内存里没刷到磁盘中时，如果服务器down了又没translog机制的话，<br>那么数据就会丢失，有了translog，服务器down机后再起来，就能很快恢复写入的过程。</p><p>这里要注意的是，translog也是先存在内存里的，然后默认5秒刷一次写到硬盘里。</p><p><a href="https://www.jianshu.com/p/fa510352ce1a" target="_blank" rel="external">那么如何高效的检索大量文档？</a></p>]]></content>
      
      
      <categories>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus介绍</title>
      <link href="/prometheus/intro.html"/>
      <url>/prometheus/intro.html</url>
      
        <content type="html"><![CDATA[<p>请假不用害怕，有东西看着线上。</p><a id="more"></a> <h3 id="监控现状"><a href="#监控现状" class="headerlink" title="监控现状"></a>监控现状</h3><p>​        随着服务器以及服务规模的扩大，监控体系也面临同样的问题，如何更好的在监控层面为日常运营而服务，如何预防并快速定位问题从而解决问题就显得尤为重要。</p><p>​        目前普遍采用的监控方式有：主动监控、被动监控、旁路监控。比如Nagios、Cacti、Zabbix等监控工具以及第三方监控平台。</p><p>​        监控要从公司的业务角度考虑，而不是某种手段，某个服务。对于辅助解决问题，又要细化到服务器、服务、容器甚至是进城，站在服务提供的角度发现、定位、解决问题。</p><p>​        使用者的痛点：配置复杂，可定制化低，组件间耦合度高，数据生涩，展示化程度低，通知信息不完善等。</p><p>​        监控体系的建立离不开功能模块的加入，不能增加监控模块、类别、参数，进行过滤，整合达到合理的产出。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote><p>Prometheus是开源的系统监控和警报工具包。</p><p>已于2016加入云计算本地计算基金会，作为Kubernetes之后的第二个托管项目。</p><p>Prometheus是时间序列化数据库，可以简单理解为将数据打上标签，以时间维度存储。</p></blockquote><p><a href="https://github.com/prometheus/prometheus" target="_blank" rel="external">GitHub - 地址</a></p><p><a href="https://prometheus.io/" target="_blank" rel="external">官网</a></p><p>根据操作系统下载对应的版本，直接运行即可：<code>./prometheus</code>，访问<code>localhost:9090</code>可以查看。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>多维数据模型（时序列数据由metric名和一组key/value组成）</li><li>在多维度上灵活的查询语言(PromQL)</li><li>不依赖分布式存储，单主节点工作</li><li>通过基于HTTP的Pull方式采集时序数据</li><li>可以通过中间网关进行时序列数据推送(pushing)</li><li>目标服务器可以通过发现服务或者静态配置实现</li><li>多种可视化和仪表盘支持</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>每经过一个时间间隔，数据都会从运行的服务中流出，存储到一个时间序列数据库中，这个数据库之后可以通过PromQL语言查询。</li><li>因为数据是以时间序列存储的，当出现问题时，可以根据这些时间间隔进行诊断，另外还可以预测基础设施的长期监控趋势。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li>Prometheus主服务<ul><li>用来抓取和存储时序数据</li></ul></li><li>client library<ul><li>用来构造应用或 exporter 代码 (go,java,python,ruby)</li></ul></li><li>pus<ul><li>网关可用来支持短连接任务</li></ul></li><li>可视化的dashboard<ul><li>(两种选择,promdash 和 grafana.目前主流选择是 grafana.)</li></ul></li><li>实验性的报警管理端<ul><li>(alertmanager,单独进行报警汇总,分发,屏蔽等 )</li></ul></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" target="_blank" rel="external">官方文档</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 常规的全局配置</span></div><div class="line"><span class="attr">global:</span></div><div class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># 每15秒采集一次数据.</span></div><div class="line"><span class="attr">  evaluation_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># 每15秒做一次告警检测.</span></div><div class="line"></div><div class="line"><span class="comment"># 配置alertmanagers</span></div><div class="line"><span class="attr">alerting:</span></div><div class="line"><span class="attr">  alertmanagers:</span></div><div class="line"><span class="attr">  - static_configs:</span></div><div class="line"><span class="attr">    - targets:</span></div><div class="line">      <span class="comment"># - alertmanager:9093</span></div><div class="line"></div><div class="line"><span class="comment"># 指定加载的告警规则文件，根据evaluation_interval设置的告警频率。</span></div><div class="line"><span class="attr">rule_files:</span></div><div class="line">  <span class="comment"># - "first_rules.yml"</span></div><div class="line">  <span class="comment"># - "second_rules.yml"</span></div><div class="line"></div><div class="line"><span class="comment"># 指定Prometheus要监控的目标</span></div><div class="line"><span class="comment"># 每个监控目标是一个job，job的类型有很多种。可以是最简单的static_config，即静态地指定每一个目标</span></div><div class="line"><span class="attr">scrape_configs:</span></div><div class="line">  <span class="comment"># 监控的对象名称，不可重复</span></div><div class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></div><div class="line"></div><div class="line">    <span class="comment"># 监听的服务地址</span></div><div class="line"><span class="attr">    static_configs:</span></div><div class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:9090']</span></div></pre></td></tr></table></figure><h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><blockquote><p>在处理时间序列数据库时，希望对数据进行处理，并对结果给出反馈，这部分工作是用告警来实现。</p></blockquote><p>告警在Grafana中非常常见，Prometheus也通过Alertmanager实现完成的告警系统。Alertmanager是一个独立的工具，可以绑定到Prometheus并运行自定义Alertmanager。告警通过配置文件定义，定义有一组指标定义规则组成，如果数据命中这些规则，则会触发告警并将其发送到预定义的目标。与Grafana类似，Prometheus的告警，可以通过email，Slack webhooks，PagerDuty和自定义HTTP目标等。</p><p>告警规则是单独文件定义，在<code>prometheus.yml</code>中引用，格式如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="string">$</span> <span class="string">cat</span> <span class="string">first_rules.yml</span></div><div class="line"><span class="attr">groups:</span></div><div class="line"><span class="attr">- name:</span> <span class="string">rule1-http_requst_total</span></div><div class="line"><span class="attr">  rules:</span></div><div class="line"><span class="attr">  - alert:</span>  <span class="string">HTTP_REQUEST_TOTAL</span></div><div class="line"><span class="attr">    expr:</span> <span class="string">http_requests_total</span> <span class="string">&gt; 100</span></div><div class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></div><div class="line"><span class="attr">    labels:</span></div><div class="line"><span class="attr">      severity:</span> <span class="string">page</span></div><div class="line"><span class="attr">    annotations:</span></div><div class="line"><span class="attr">      summary:</span> <span class="string">Http</span> <span class="string">request</span> <span class="string">total</span> <span class="string">reach</span> <span class="string">limit</span></div></pre></td></tr></table></figure><p>需要注意的是，还要在<code>prometheus.yml</code>中配置<code>alertmanager</code>的地址</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">alerting:</span></div><div class="line"><span class="attr">  alertmanagers:</span></div><div class="line"><span class="attr">  - static_configs:</span></div><div class="line"><span class="attr">    - targets:</span></div><div class="line">      <span class="comment"># - alertmanager:9093</span></div></pre></td></tr></table></figure><h3 id="Exporters"><a href="#Exporters" class="headerlink" title="Exporters"></a>Exporters</h3><blockquote><p>Exportr负责数据指标的采集。对于自定义应用程序，仪表化非常方便，允许自定义公开的指标以及其随时间的变化方式。</p></blockquote><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li>node_exporter<ul><li>主要用来采集机器的性能指标数据，包括cpu，内存，磁盘，io等基本信息。</li></ul></li><li>mysqld_exporter<ul><li>主要用于监控采集mysql数据库服务器相关指标。</li></ul></li><li>redis_exporter<ul><li>主要用于监控采集redis数据库服务器相关指标。</li></ul></li><li>black_exporter<ul><li>prometheus社区提供的官方黑盒监控解决方案，其允许用户通过：http、https、dns、tcp以及icmp的方式对网络进行探测。</li></ul></li><li>cadvisor<ul><li>google开源的用于监控容器运行的工具。</li></ul></li></ul><p>常见的模版：</p><ul><li>数据库模版<ul><li>用于MongoDB数据，SQL服务器和MySQL服务器的配置</li></ul></li><li>HTTP模版<ul><li>用于HAProxy，Apache或Nginx等Web服务器和代理的配置</li></ul></li><li>Unix模版<ul><li>用来使用构建的节点导出程序监控，可以实现完整的系统指标的监控</li></ul></li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote><p>Prometheus 从根本上所有的存储都是按时间序列去实现的，相同的 metrics(指标名称) 和 label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。</p></blockquote><p>每条时间序列是由唯一的 指标名称 和 一组 标签 （key=value）的形式组成。<br>指标名称 一般是给监测对像起一名字，例如 http_requests<em>total 这样，它有一些命名规则，可以包字母数字</em>之类的的。</p><p>标签 就是对一条时间序列不同维度的识别了，例如 一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了， 最终形成的标识便是这样了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http_requests_total&#123;method=&quot;POST&quot;,endpoint=&quot;/api/tracks&quot;&#125;</div></pre></td></tr></table></figure><p>记住，针对http_requests_total这个metrics name 无论是增加标签还是删除标签都会形成一条新的时间序列。<br>查询语句就可以跟据上面标签的组合来查询聚合结果了。</p><p>如果以传统数据库的理解来看这条语句，则可以考虑 http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。</p><p><a href="https://prometheus.io/docs/practices/naming/" target="_blank" rel="external">命名最佳实践</a></p><h3 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h3><h4 id="计数器Counter"><a href="#计数器Counter" class="headerlink" title="计数器Counter"></a>计数器Counter</h4><blockquote><p>只增不减的计数器。比如记录应用请求的总量(http_requests_total)，cpu使用时间(process_cpu_seconds_total)等。</p><p>对于Counter类型的指标，只包含一个inc()方法，用于计数器+1</p><p>一般而言，Counter类型的metrics指标在命名中我们使用_total结束</p></blockquote><p>使用Counter.build()创建Counter metrics，name()方法，用于指定该指标的名称 labelNames()方法，用于声明该metrics拥有的维度label。在preHandle方法中，我们获取当前请求的，RequesPath，Method以及状态码。并且调用inc()方法，在每次请求发生时计数+1。</p><p>Counter.build()…register(),会像Collector中注册该指标，并且当访问/metrics地址时，返回该指标的状态。</p><p>通过指标io_namespace_http_requests_total我们可以：</p><ul><li>查询应用的请求总量<ul><li><code>sum(io_namespace_http_requests_total)</code></li></ul></li><li>查询每秒Http请求量<ul><li><code>sum(rate(io_wise2c_gateway_requests_total[5m]))</code></li></ul></li><li>查询当前应用请求量Top N的URI<ul><li><code>topk(10, sum(io_namespace_http_requests_total) by (path))</code></li></ul></li></ul><h4 id="计量表Gauges"><a href="#计量表Gauges" class="headerlink" title="计量表Gauges"></a>计量表Gauges</h4><blockquote><p>可增可减的仪表盘，可以用于反应应用的<strong>当前状态</strong>,例如在监控主机时，主机当前空闲的内容大小(node_memory_MemFree)，可用内存大小(node_memory_MemAvailable)。或者容器当前的cpu使用率,内存使用率。</p><p>对于Gauge指标的对象则包含两个主要的方法inc()以及dec(),用户添加或者减少计数。在这里我们使用Gauge记录当前正在处理的Http请求数量。</p></blockquote><ul><li>查询应用当前正在处理中的Http请求数量:<ul><li><code>io_namespace_http_inprogress_requests{}</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Gauge inprogressRequests = Gauge.build()</div><div class="line">            .name(<span class="string">"io_namespace_http_inprogress_requests"</span>).labelNames(<span class="string">"path"</span>, <span class="string">"method"</span>, <span class="string">"code"</span>)</div><div class="line">            .help(<span class="string">"Inprogress requests."</span>).register();</div></pre></td></tr></table></figure><h4 id="直方图Histogram"><a href="#直方图Histogram" class="headerlink" title="直方图Histogram"></a>直方图Histogram</h4><blockquote><p>自带buckets区间用于统计分布统计图</p></blockquote><p>主要用于在指定分布范围内(Buckets)记录大小(如http request bytes)或者事件发生的次数。</p><p>以请求响应时间requests_latency_seconds为例，假如我们需要记录http请求响应时间符合在分布范围{.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10}中的次数时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrometheusMetricsInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Histogram requestLatencyHistogram = Histogram.build().labelNames(<span class="string">"path"</span>, <span class="string">"method"</span>, <span class="string">"code"</span>)</div><div class="line">            .name(<span class="string">"io_namespace_http_requests_latency_seconds_histogram"</span>).help(<span class="string">"Request latency in seconds."</span>)</div><div class="line">            .register();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Histogram.Timer histogramRequestTimer;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">        histogramRequestTimer = requestLatencyHistogram.labels(requestURI, method, String.valueOf(status)).startTimer();</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">        histogramRequestTimer.observeDuration();</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用Histogram构造器可以创建Histogram监控指标。默认的buckets范围为{.005, .01, .025, .05, .075, .1, .25, .5, .75, 1, 2.5, 5, 7.5, 10}。如何需要覆盖默认的buckets，可以使用.buckets(double… buckets)覆盖。</p><p>Histogram会自动创建3个指标，分别为：</p><ul><li>事件发生总次数： basename_count</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 实际含义： 当前一共发生了2次http请求</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_count&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,&#125; 2.0</div></pre></td></tr></table></figure><ul><li>所有事件产生值的大小的总和: basename_sum</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 实际含义： 发生的2次http请求总的响应时间为13.107670803000001 秒</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_sum&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,&#125; 13.107670803000001</div></pre></td></tr></table></figure><ul><li>事件产生的值分布在bucket中的次数： basename_bucket{le=”上包含”}</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 在总共2次请求当中。http请求响应时间 &lt;=0.005 秒 的请求次数为0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.005&quot;,&#125; 0.0</div><div class="line"># 在总共2次请求当中。http请求响应时间 &lt;=0.01 秒 的请求次数为0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.01&quot;,&#125; 0.0</div><div class="line"># 在总共2次请求当中。http请求响应时间 &lt;=0.025 秒 的请求次数为0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.025&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.05&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.075&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.1&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.25&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.5&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;0.75&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;1.0&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;2.5&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;5.0&quot;,&#125; 0.0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;7.5&quot;,&#125; 2.0</div><div class="line"># 在总共2次请求当中。http请求响应时间 &lt;=10 秒 的请求次数为0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;10.0&quot;,&#125; 2.0</div><div class="line"># 在总共2次请求当中。http请求响应时间 10 秒 的请求次数为0</div><div class="line">io_namespace_http_requests_latency_seconds_histogram_bucket&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,le=&quot;+Inf&quot;,&#125; 2.0</div></pre></td></tr></table></figure><h4 id="摘要Summary"><a href="#摘要Summary" class="headerlink" title="摘要Summary"></a>摘要Summary</h4><p>Summary和Histogram非常类型相似，都可以统计事件发生的次数或者发小，以及其分布情况。</p><p>Summary和Histogram都提供了对于事件的计数_count以及值的汇总_sum。 因此使用_count,和_sum时间序列可以计算出相同的内容，例如http每秒的平均响应时间：rate(basename_sum[5m]) / rate(basename_count[5m])。</p><p>同时Summary和Histogram都可以计算和统计样本的分布情况，比如中位数，9分位数等等。其中 0.0&lt;= 分位数Quantiles &lt;= 1.0。</p><p>不同在于Histogram可以通过histogram_quantile函数在服务器端计算分位数。 而Sumamry的分位数则是直接在客户端进行定义。因此对于分位数的计算。 Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。相对的对于客户端而言Histogram消耗的资源更少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrometheusMetricsInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Summary requestLatency = Summary.build()</div><div class="line">            .name(<span class="string">"io_namespace_http_requests_latency_seconds_summary"</span>)</div><div class="line">            .quantile(<span class="number">0.5</span>, <span class="number">0.05</span>)</div><div class="line">            .quantile(<span class="number">0.9</span>, <span class="number">0.01</span>)</div><div class="line">            .labelNames(<span class="string">"path"</span>, <span class="string">"method"</span>, <span class="string">"code"</span>)</div><div class="line">            .help(<span class="string">"Request latency in seconds."</span>).register();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">        requestTimer = requestLatency.labels(requestURI, method, String.valueOf(status)).startTimer();</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">        requestTimer.observeDuration();</div><div class="line">        <span class="comment">//...省略的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用Summary指标，会自动创建多个时间序列：</p><ul><li>事件发生总的次数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 含义：当前http请求发生总次数为12次</div><div class="line">io_namespace_http_requests_latency_seconds_summary_count&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,&#125; 12.0</div></pre></td></tr></table></figure><ul><li>事件产生的值的总和</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 含义：这12次http请求的总响应时间为 51.029495508s</div><div class="line">io_namespace_http_requests_latency_seconds_summary_sum&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,&#125; 51.029495508</div></pre></td></tr></table></figure><ul><li>事件产生的值的分布情况</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 含义：这12次http请求响应时间的中位数是3.052404983s</div><div class="line">io_namespace_http_requests_latency_seconds_summary&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.5&quot;,&#125; 3.052404983</div><div class="line"># 含义：这12次http请求响应时间的9分位数是8.003261666s</div><div class="line">io_namespace_http_requests_latency_seconds_summary&#123;path=&quot;/&quot;,method=&quot;GET&quot;,code=&quot;200&quot;,quantile=&quot;0.9&quot;,&#125; 8.003261666</div></pre></td></tr></table></figure><h3 id="PromQL"><a href="#PromQL" class="headerlink" title="PromQL"></a>PromQL</h3><blockquote><p>内置SQL查询，用于便捷和熟悉的方式从Prometheus查询和检索数据。</p></blockquote><p>除了用来查询数据，告警规则也要用查询语句描述。查询语句直接就是指标的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go_memstats_other_sys_bytes</div></pre></td></tr></table></figure><p>可以通过label筛选</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go_memstats_other_sys_bytes&#123;instance=&quot;192.168.88.10&quot;&#125;</div></pre></td></tr></table></figure><p>label可以使用4个操作符</p><ul><li><code>=:</code>：精准等于的label</li><li><code>!=</code>：不等于的label</li><li><code>=~</code>：符合正则表达式的label</li><li><code>!~</code>：不符合正则表达式的label</li></ul><p>并且可以使用多个标签属性，用<code>,</code>间隔，彼此是与的关系</p><p><code>http_requests_total{environment=~&quot;staging|testing|development&quot;,method!=&quot;GET&quot;}</code></p><p>或者只有标签</p><p><code>{instance=&quot;192.168.88.10&quot;}</code></p><p>对查询出来的结果进行运算也是可以的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 时间范围截取，Range Vector Selectors</span></div><div class="line"><span class="string">http_requests_total&#123;job="prometheus"&#125;[5m]</span></div><div class="line"> </div><div class="line"><span class="comment"># 时间偏移</span></div><div class="line"><span class="string">http_requests_total</span> <span class="string">offset</span> <span class="number">5</span><span class="string">m</span></div><div class="line"> </div><div class="line"><span class="comment"># 时间段内数值累加</span></div><div class="line"><span class="string">sum(http_requests_total&#123;method="GET"&#125;</span> <span class="string">offset</span> <span class="number">5</span><span class="string">m)</span></div></pre></td></tr></table></figure><p>还可以进行<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="external">多元运算</a>，以及<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="external">使用函数</a>。</p><ul><li>sum(求和)</li><li>min(取最小)</li><li>max(取最大)</li><li>avg(取平均)</li><li>count (计数器)</li><li>stddev (计算偏差)</li><li>stdvar (计算方差)</li><li>count_values(每个元素独立值数量)</li><li>bottomk (取倒数几个),topk(取前几位)</li></ul><h3 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h3><p>可以在<code>Status-&gt;rule</code>页面看到告警规则，在alert页面看到触发的告警。</p><blockquote><p>alertmanager需要单独部署。用来接受prometheus发出的告警，然后按照配置文件的要求，将告警用用对应的方式发送出去。</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建一个Demo来展示Prometheus的功能。Spring Boot + Pushgateway + Prometheus。</p><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p><a href="https://start.spring.io/" target="_blank" rel="external">创建Spring Boot项目</a></p><ul><li><code>pom.xml</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.prometheus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>simpleclient_pushgateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><ul><li><code>Controller</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrometheus</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Counter REQUEST_COUNTER = Counter.build()</div><div class="line">            .name(<span class="string">"test_counter_name"</span>).help(<span class="string">"test_counter_help."</span>).register();</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/push"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">push</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        CollectorRegistry registry = <span class="keyword">new</span> CollectorRegistry();</div><div class="line">        REQUEST_COUNTER.inc();</div><div class="line"><span class="comment">//pushgateway地址</span></div><div class="line">        PushGateway pg = <span class="keyword">new</span> PushGateway(<span class="string">"127.0.0.1:9091"</span>);</div><div class="line">        <span class="comment">//collector,jobName</span></div><div class="line">        pg.push(REQUEST_COUNTER, <span class="string">"test_push"</span>);</div><div class="line">        <span class="keyword">return</span> String.valueOf(REQUEST_COUNTER.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Pushgateway"><a href="#Pushgateway" class="headerlink" title="Pushgateway"></a>Pushgateway</h3><ul><li><p><a href="https://github.com/prometheus/pushgateway/releases" target="_blank" rel="external">下载对应系统版本</a></p></li><li><p>解压运行：<code>./pushgateway</code></p><ul><li>默认端口：<code>9091</code></li></ul></li><li>修改<code>prometheus</code>配置文件</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">###以下内容为SpringBoot应用配置</span></div><div class="line"><span class="attr">  - job_name:</span> <span class="string">'springboot_prometheus'</span></div><div class="line"><span class="attr">    metrics_path:</span> <span class="string">'/actuator/prometheus'</span></div><div class="line"><span class="attr">    static_configs:</span></div><div class="line"><span class="attr">      - targets:</span> <span class="string">['127.0.0.1:8080']</span></div><div class="line"><span class="comment">### 以下内容为配置pushgateway</span></div><div class="line"><span class="attr">  - job_name:</span> <span class="string">'push-metrics'</span></div><div class="line"><span class="attr">    static_configs:</span></div><div class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:9091']</span></div></pre></td></tr></table></figure><ul><li>启动<code>prometheus</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./prometheus</div></pre></td></tr></table></figure><ul><li>访问页面：<code>http://localhost:8080/push</code><ul><li>因为每访问一次<code>push</code>接口，Counter计数器<code>REQUEST_COUNTER</code>就会自增1，并将结果显示在页面中，所以页面会显示此次应用启动后，此接口的访问次数</li></ul></li><li>访问页面：<code>http://localhost:9090/graph</code>，输入Counter的<code>name</code>值<code>test_counter_name</code>，点击<code>Execute</code>，将会看到下方输出：</li></ul><table><thead><tr><th><strong>Element</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>test_counter_name{exported_job=”test_push”,instance=”localhost:9091”,job=”push-metrics”}</td><td>1</td></tr></tbody></table><p>其中：</p><ul><li><code>exported_job</code>：代码中定义的<code>PushGateWay</code>的<code>job</code>名称</li><li><code>instance</code>：实例</li><li><code>job</code>：在<code>prometheus</code>中配置的job名称</li><li><code>Value</code>：Counter计数器的数值</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><blockquote><p>influxdb、openTSDB等，是专门时间序列数据库，不是一套完整的监控告警系统，缺少告警功能。</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>如果应用程序运行在容器上并由Kubernetes负责调度，在此环境中它们是高度自动化并且动态的。传统的监控工具一般是基于服务器，只监控静态的服务，所以当要在这种动态环境监控应用程序时，传统的监控工具往往很难满足这一需求，这时就需要Prometheus出马了。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/lijiaocn/article/details/81865120" target="_blank" rel="external">李佶澳博客</a></p><p><a href="https://blog.csdn.net/mingongge/article/details/89507202" target="_blank" rel="external">Prometheus 使用总结：我踩过得那些坑</a></p><p><a href="https://blog.csdn.net/mingongge/article/details/89507202" target="_blank" rel="external">Prometheus时间序列监控方案</a></p>]]></content>
      
      
      <categories>
          
          <category> prometheus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES的基本概念</title>
      <link href="/es/basis.html"/>
      <url>/es/basis.html</url>
      
        <content type="html"><![CDATA[<p>认识认识七大姑八大姨</p><a id="more"></a><h3 id="文档Document"><a href="#文档Document" class="headerlink" title="文档Document"></a>文档Document</h3><ul><li>Elaticsearch是面向文档的，文档时所有可搜索数据的最小单元<ul><li>日志文件中的日志项</li><li>一个电影的具体信息/一张唱片的详细信息</li></ul></li><li>文档会被序列化成JSON格式，保存在Elasticsearch中<ul><li>JSON对象由字段组成</li><li>每个字段都有对应的字段类型<ul><li>字符串、数值、布尔、日期、二进制、范围</li></ul></li></ul></li><li>每个文档都有一个Unique ID<ul><li>可以指定</li><li>Elasticsearch自动生成</li></ul></li></ul><h3 id="JSON文档"><a href="#JSON文档" class="headerlink" title="JSON文档"></a>JSON文档</h3><ul><li>一篇文章包含了一系列的字段。类似数据库表中一条记录</li><li>JSON文档，格式灵活，不需要预先定义格式<ul><li>字段的类型可以指定或者通过Elasticsearch自动推算</li><li>支持数组/支持潜逃</li></ul></li></ul><h3 id="文档的元数据"><a href="#文档的元数据" class="headerlink" title="文档的元数据"></a>文档的元数据</h3><ul><li>元数据，用于标注文档的相关信息<ul><li><code>_index</code>：文档所属的索引名</li><li><code>_type</code>：文档所属的类型名</li><li><code>_id</code>：文档的唯一ID</li><li><code>_source</code>：文档的原始Json数据</li><li><del><code>_all</code>：整合所有文档内容到该字段，已废除</del></li><li><code>_version</code>：文档的版本信息</li><li><code>_score</code>：相关性打分</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>Index - 索引时文档的容器，是一类文档的结合<ul><li>Index体现了逻辑空间的概念：每个索引都有自己的Mapping定义，用于定义包含的文档的字段名和字段类型</li><li>Shard体现了物理空间的概念：索引中的数据分散在Shard上</li></ul></li><li>索引的Mapping与Settings<ul><li>Mapping定义文档字段的类型</li><li>Setting定义不同的数据分布</li></ul></li></ul><h3 id="索引的不同语意"><a href="#索引的不同语意" class="headerlink" title="索引的不同语意"></a>索引的不同语意</h3><ul><li>名词<ul><li>一个Elasticsearch集群汇总，可以创建很多个不同的索引</li><li>一个B输索引，一个倒排索引</li></ul></li><li>动词：保存一个文档到Elasticsearch的过程也叫索引(Indexing)<ul><li>ES中，创建一个倒排索引的过程</li></ul></li></ul><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><ul><li>在7.0之前，一个Index可以设置多个Types</li><li>6.0开始，Type已经被Deprecated。7.0开始，一个索引只能创建一个Type - “_doc”<ul><li><a href="https://www.elastic.co/cn/blog/moving-from-types-to-typeless-apis-in-elasticsearch-7-0" target="_blank" rel="external">为什么不再支持单个Index下，多个Types</a></li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>传统关系型数据库和Elasticsearch的区别<ul><li>Elasticsearch - Schemaless/相关性/高性能全文检索</li><li>RDMS - 事务性 / Join</li></ul></li></ul><h3 id="简单的API"><a href="#简单的API" class="headerlink" title="简单的API"></a>简单的API</h3><p>可以在kibana的Dev Tools中执行以下请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#查看索引相关信息</div><div class="line">GET kibana_sample_data_ecommerce</div><div class="line"></div><div class="line">#查看索引的文档总数</div><div class="line">GET kibana_sample_data_ecommerce/_count</div><div class="line"></div><div class="line">#查看前10条文档，了解文档格式</div><div class="line">POST kibana_sample_data_ecommerce/_search</div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#_cat indices API</div><div class="line">#查看indices</div><div class="line">GET /_cat/indices/kibana*?v&amp;s=index</div><div class="line"></div><div class="line">#查看状态为绿的索引</div><div class="line">GET /_cat/indices?v&amp;health=green</div><div class="line"></div><div class="line">#按照文档个数排序</div><div class="line">GET /_cat/indices?v&amp;s=docs.count:desc</div><div class="line"></div><div class="line">#查看具体的字段</div><div class="line">GET /_cat/indices/kibana*?pri&amp;v&amp;h=health,index,pri,rep,docs.count,mt</div><div class="line"></div><div class="line">#How much memory is used per index?</div><div class="line">GET /_cat/indices?v&amp;h=i,tm&amp;s=tm:desc</div></pre></td></tr></table></figure><h3 id="可用性与扩展性"><a href="#可用性与扩展性" class="headerlink" title="可用性与扩展性"></a>可用性与扩展性</h3><ul><li>高可用<ul><li>服务可用性 - 允许有节点停止服务</li><li>数据可用性 - 部分节点丢失，不会丢失数据</li></ul></li><li>可扩展<ul><li>请求量提升/ 数据的不断增长(将数据分布到所有节点上)</li></ul></li></ul><h3 id="分布式特性"><a href="#分布式特性" class="headerlink" title="分布式特性"></a>分布式特性</h3><ul><li>Elasticsearch的分布式架构的好处<ul><li>存储的水平扩容</li><li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li></ul></li><li>Elasticsearch的分布式架构<ul><li>不同的集群通过不同的名字来区分<ul><li>默认：<code>elasticsearch</code></li></ul></li><li>通过修改配置文件，或者在命令行中执行<code>-E cluster.name=修改后的名字</code></li><li>一个集群可以有一个或者多个节点</li></ul></li></ul><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>节点是一个Elasticsearch的实例<ul><li>本质上就是一个Java进程</li><li>一台机器上可以运行多个Elasticsearch进程，但是生产环境一般建议一台机器上只运行一个实例</li></ul></li><li>每一个节点都有名字，通过配置文件修改，或者启动时通过命令指定<code>-E node.name=修改后的名称</code></li><li>每一个节点在启动之后，会分配一个UID，保存在data目录下</li></ul><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ul><li>每个节点启动后，默认就是一个Master eligible节点<ul><li>可以设置<code>node.master:false</code>禁止</li></ul></li><li>Master-eligible节点可以参加选主流程，成为Master节点</li><li>当第一个节点启动时，它会将自己选举成Master节点</li><li>每个节点上都保存了集群的状态，只有Master节点才能修改集群的状态信息<ul><li>集群状态Cluster State，维护了一个集群中，必要的信息<ul><li>所有的节点信息</li><li>所有的索引和其相关的Mapping与Setting信息</li><li>分片的路由信息</li></ul></li><li>任意节点都能修改信息会导致数据的不一致性</li></ul></li></ul><h3 id="Data-Node"><a href="#Data-Node" class="headerlink" title="Data Node"></a>Data Node</h3><ul><li>可以保存数据的节点</li><li>负责保存分片数据</li><li>在数据扩展上起到了至关重要的作用</li></ul><h3 id="Coordinating-Node"><a href="#Coordinating-Node" class="headerlink" title="Coordinating Node"></a>Coordinating Node</h3><ul><li>负责接收Client的请求，将请求分发到合适的节点，最终把节点汇集到一起</li><li>每个节点默认都起到了Coordinating Node的职责</li></ul><h3 id="其他节点类型"><a href="#其他节点类型" class="headerlink" title="其他节点类型"></a>其他节点类型</h3><ul><li>Hot &amp; Warm Node<ul><li>不同硬件配置的Data Node</li><li>用来实现Hot &amp; Warm架构，降低集群部署的成本</li><li>分别存储热数据和冷数据的节点</li></ul></li><li>Machine Learning Node<ul><li>负责跑机器学习的Job</li><li>发现数据的异常，用来做异常检测</li></ul></li><li>Tribe Node<ul><li>未来版本将会淘汰，替代为5.3开始使用Cross Cluster Search</li><li>Tribe Node连接到不同的Elasticsearch集群</li><li>并且支持将这些集群当成一个单独的集群处理</li></ul></li></ul><h3 id="配置节点类型"><a href="#配置节点类型" class="headerlink" title="配置节点类型"></a>配置节点类型</h3><ul><li>开发环境中一个节点可以承担多种角色</li><li>生产环境中，应该设置单一的角色的节点(dedicated node)</li></ul><table><thead><tr><th>节点类型</th><th>配置参数</th><th>默认值</th></tr></thead><tbody><tr><td>master eligible</td><td>node.master</td><td>true</td></tr><tr><td>data</td><td>node.data</td><td>true</td></tr><tr><td>ingest</td><td>node.ingest</td><td>true</td></tr><tr><td>coordinating only</td><td>无</td><td>每个节点默认都是coordinating节点。设置其他类型全部为false</td></tr><tr><td>machine learning</td><td>node.ml</td><td>true(需要enable x-pack)</td></tr></tbody></table><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><h4 id="Primary-Shard"><a href="#Primary-Shard" class="headerlink" title="Primary Shard"></a>Primary Shard</h4><ul><li>主分片</li><li>用以解决数据水平扩展的问题。</li><li>通过主分片，可以将数据分布到集群内的所有节点之上<ul><li>一个分片时一个运行的Lucene的实例</li><li>主分片数载索引创建时指定，后续不允许修改，除非Reindex<ul><li>和倒排索引有关</li></ul></li></ul></li></ul><h4 id="Replica-Shard"><a href="#Replica-Shard" class="headerlink" title="Replica Shard"></a>Replica Shard</h4><ul><li>副本</li><li>用以解决数据高可用的问题</li><li>副本是主分片的拷贝<ul><li>副本分片数，可以动态调整</li><li>增加副本数，还可以在一定程度上提高服务的可用性(读取的吞吐)</li></ul></li></ul><h3 id="分片的设置"><a href="#分片的设置" class="headerlink" title="分片的设置"></a>分片的设置</h3><ul><li>对于生产环境中分片的设置，需要提前做好容量规划<ul><li>分片数设置过小<ul><li>导致后续无法增加节点实现水平扩展</li><li>单个分片的数据量太大，导致数据重新重新分配耗时</li></ul></li><li>分片数设置过大<ul><li>影响搜索结果的相关性打分，影响统计结果的准确性</li><li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li></ul></li></ul></li></ul><blockquote><p>7.0开始，默认主分片设置成1，解决了<code>over-sharding</code>的问题</p></blockquote><h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p><code>http://localhost:9200/_cluster/health</code></p><ul><li>Green：主分片与副本都正常分配</li><li>Yellow：主分片全部正常分配，有副本分片未能正常分配</li><li>Red：有主分片未能分配<ul><li>例如：当服务器的磁盘容量超过85%时，去创建一个新的索引</li></ul></li></ul><h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><p>在Dev Tools中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#查看集群状态</div><div class="line">GET _cluster/health</div><div class="line">#查看节点</div><div class="line">GET _cat/nodes?v</div><div class="line">#查看分片</div><div class="line">GET _cat/shards</div><div class="line"></div><div class="line">GET /_nodes/es7_01,es7_02</div><div class="line">GET /_cat/nodes?v&amp;h=id,ip,port,v,m</div><div class="line"></div><div class="line"></div><div class="line">GET _cluster/health</div><div class="line">GET _cluster/health?level=shards</div><div class="line">GET /_cluster/health/kibana_sample_data_ecommerce,kibana_sample_data_flights</div><div class="line">GET /_cluster/health/kibana_sample_data_flights?level=shards</div><div class="line"></div><div class="line">#### cluster state</div><div class="line">The cluster state API allows access to metadata representing the state of the whole cluster. This includes information such as</div><div class="line">GET /_cluster/state</div><div class="line"></div><div class="line">#cluster get settings</div><div class="line">GET /_cluster/settings</div><div class="line">GET /_cluster/settings?include_defaults=true</div><div class="line"></div><div class="line">GET _cat/shards</div><div class="line">GET _cat/shards?h=index,shard,prirep,state,unassigned.reason</div></pre></td></tr></table></figure><h4 id="cerebro"><a href="#cerebro" class="headerlink" title="cerebro"></a>cerebro</h4><blockquote><p>Cerebro 是使用 Scala，Play Framework，AngularJS 和 Bootstrap 构建的开源（MIT 许可证）的基于 Elasticsearch Web管理工具。</p></blockquote><p><strong>Java 1.8以上运行</strong></p><ul><li><a href="https://cerebrohq.com/en/download/" target="_blank" rel="external">下载地址</a></li><li>运行：<code>bin/cerebro</code></li><li>访问：<code>http://localhost:9000</code></li><li><p>输入：<code>http://localhost:9200</code></p></li><li><p>其他</p><ul><li>配置文件：<code>conf/application.conf</code></li></ul></li></ul><blockquote><ul><li><p>行为不同的节点，列为索引，实线的代表为主分片，虚线为副本分片</p></li><li><p>节点名称前的星号代表该节点是master eligible节点，可以被选为master节点</p></li><li>上方的长条代表集群的状态<ul><li>如果停止一个主节点运行，颜色将会变成黄色</li></ul></li></ul></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cat-shards.html" target="_blank" rel="external">cat Shards</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cluster.html" target="_blank" rel="external">Cluster APIs</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.1/cat-nodes.html" target="_blank" rel="external">cat nodes</a></p>]]></content>
      
      
      <categories>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logstash介绍</title>
      <link href="/es/logstash_intro.html"/>
      <url>/es/logstash_intro.html</url>
      
        <content type="html"><![CDATA[<p>也跑起来了，也瞅了，干点啥吧</p><a id="more"></a><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><blockquote><p><strong>Logstash</strong>作为Elasicsearch常用的实时数据采集引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源，是Elastic Stack 的重要组成部分。</p></blockquote><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><ul><li>下载数据集：<a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="external">Grouplens的movie数据集</a></li></ul><h3 id="下载Logstash"><a href="#下载Logstash" class="headerlink" title="下载Logstash"></a>下载Logstash</h3><p><strong>保持与elasticsearch版本一致</strong></p><ul><li><a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="external">Logstash下载地址</a></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>将文件创建在/logstash-7.2.0/bin目录下</p></li><li><p>文件开头的input/file/path需要修改为数据集文件地址</p></li></ul><p>配置文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">  file &#123;</div><div class="line">    path =&gt; &quot;/Users/userName/dataSource.csv&quot;</div><div class="line">    start_position =&gt; &quot;beginning&quot;</div><div class="line">    sincedb_path =&gt; &quot;/dev/null&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">filter &#123;</div><div class="line">  csv &#123;</div><div class="line">    separator =&gt; &quot;,&quot;</div><div class="line">    columns =&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  mutate &#123;</div><div class="line">    split =&gt; &#123; &quot;genre&quot; =&gt; &quot;|&quot; &#125;</div><div class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  mutate &#123;</div><div class="line"></div><div class="line">    split =&gt; [&quot;content&quot;, &quot;(&quot;]</div><div class="line">    add_field =&gt; &#123; &quot;title&quot; =&gt; &quot;%&#123;[content][0]&#125;&quot;&#125;</div><div class="line">    add_field =&gt; &#123; &quot;year&quot; =&gt; &quot;%&#123;[content][1]&#125;&quot;&#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">#  mutate &#123;</div><div class="line"></div><div class="line">#    gsub =&gt; [</div><div class="line">#      </div><div class="line">#      &quot;year&quot;, &quot;\\)&quot;, &quot;&quot;</div><div class="line">#    ]</div><div class="line">#  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  mutate &#123;</div><div class="line">    convert =&gt; &#123;</div><div class="line">      &quot;year&quot; =&gt; &quot;integer&quot;</div><div class="line">    &#125;</div><div class="line">    strip =&gt; [&quot;title&quot;]</div><div class="line">    remove_field =&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">   elasticsearch &#123;</div><div class="line">     hosts =&gt; &quot;http://localhost:9200&quot;</div><div class="line">     index =&gt; &quot;movies&quot;</div><div class="line">     document_id =&gt; &quot;%&#123;id&#125;&quot;</div><div class="line">   &#125;</div><div class="line">  stdout &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>运行：<code>sudo bin/logstash -f bin/logstash.conf</code></li><li>控制台将持续输出json格式的数据就是运行成功</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="external">Logstash参考文档</a></p>]]></content>
      
      
      <categories>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kibana介绍</title>
      <link href="/es/kibana_intro.html"/>
      <url>/es/kibana_intro.html</url>
      
        <content type="html"><![CDATA[<p>跑起来了再瞅瞅</p><a id="more"></a><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>保持与elasticsearch版本一致</p><p><a href="https://www.elastic.co/downloads/kibana" target="_blank" rel="external">kibana下载地址</a></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>启动：<code>bin/kibana</code></p><p>查看：<code>http://localhost:5601/</code> </p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>查看：<code>bin/kibana-plugin list</code></li><li>移除：<code>bin/kibana remove</code></li><li>安装：<code>bin/kibana-plugin install plugin_location</code></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><p>配置文件地址：<code>sudo vi config/kibana.yml</code></p></blockquote><ul><li>修改kibana中的elaticseach地址：<code>elasticsearch.hosts:http://localhost:9200</code></li><li>汉化：修改配置文件：取消注释：<code>i18n.locale: &quot;en&quot;</code></li><li>Dev Tools：执行ES API</li><li>快捷键：点击Help，右侧会出现快捷键命令<ul><li><code>Ctrl/Cmd + Option + 0</code>：是数字零，不是字母</li><li><code>Ctrl/Cmd + I</code>：自动缩进</li><li><code>Ctrl/Cmd + /</code>：查看帮助文档</li><li><code>Ctrl + Space</code>：开启自动完成</li><li><code>Ctrl/Cmd + Entere</code>：提交请求</li><li><code>Ctrl/Cmd + Up/Down</code>：跳转请求/开始结尾</li><li><code>Ctrl/Cmd + Alt + L</code>：展开缩起请求内容</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch介绍</title>
      <link href="/es/es_intro.html"/>
      <url>/es/es_intro.html</url>
      
        <content type="html"><![CDATA[<p>先跑起来再说</p><a id="more"></a><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>Elasticsearch是一个基于<a href="https://lucene.apache.org/core/" target="_blank" rel="external">Apache Lucene(TM)</a>的开源搜索引擎。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>Elasticsearch使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<code>RESTful API</code>来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>Elasticsearch不仅仅是Lucene和全文搜索，还支持：</p><ul><li>分布式的实时文件存储，每个字段都被索引并可被搜索</li><li>分布式的实时分析搜索引擎</li><li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li></ul><p>Elasticsearch在<a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank" rel="external">Apache 2 license</a>下许可使用，可以免费下载、使用和修改。</p><p>定制高级特性，都一切都是可以灵活配置的。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><p><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">Mac安装Elasticsearch</a></p><h4 id="homebrew-方式安装："><a href="#homebrew-方式安装：" class="headerlink" title="homebrew 方式安装："></a><code>homebrew</code> 方式安装：</h4><ul><li>To install with Homebrew, you first need to tap the Elastic Homebrew repository:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew tap elastic/tap</div></pre></td></tr></table></figure><ul><li>Once you’ve tapped the Elastic Homebrew repo, you can use <code>brew install</code> to install the default distribution of Elasticsearch:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install elastic/tap/elasticsearch-full</div></pre></td></tr></table></figure><blockquote><ul><li>有可能会报错：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Install the Command Line Tools:</div><div class="line">&gt; xcode-select --install</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>那就执行对应命令就可以啦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; xcode-select --installs</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><ul><li>还有可能会报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; future versions of Elasticsearch will require Java 11; your Java version from [/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home] does not meet this requirement</div><div class="line">&gt; Exception in thread &quot;main&quot; java.lang.RuntimeException: starting java failed with [1]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>那就安装高版本的JDK咯：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; brew cask install java</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="路径说明"><a href="#路径说明" class="headerlink" title="路径说明"></a>路径说明</h3><p><strong>以下为brew安装的对应路径，如果直接下载的安装包，则进入根路径下查看所有目录</strong></p><p><strong>home</strong>：Elasticsearch 根目录 -&gt; <code>$ES_HOME</code></p><p><code>/usr/local/var/homebrew/linked/elasticsearch-full</code></p><p><strong>bin</strong>：启动一个节点或安装插件的二进制脚本</p><p><code>/usr/local/var/homebrew/linked/elasticsearch-full/bin</code></p><p><strong>config</strong>：配置文件(<code>elasticsearch.yml</code>)</p><p><code>/usr/local/etc/elasticsearch</code></p><p><strong>data</strong>：每一个索引的数据文件/在节点上分配的分片。可以容纳多个位置</p><p><code>/usr/local/var/lib/elasticsearch</code></p><p><strong>logs</strong>：日志文件</p><p><code>/usr/local/var/log/elasticsearch</code></p><p><strong>plugin</strong>：插件目录。每一个插件都有一个子目录。</p><p><code>/usr/local/var/homebrew/linked/elasticsearch/plugins</code></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li>如果用<code>homebrew</code>方式安装，直接输入<code>elasticsearch</code>即可启动。</li><li>安装包方式： <code>bin/elasticsearch</code></li></ul><p>启动成功后，访问<code>http://localhost:9200</code>，会输出：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"username"</span>,</div><div class="line">    <span class="attr">"cluster_name"</span>: <span class="string">"elasticsearch_username"</span>,</div><div class="line">    <span class="attr">"cluster_uuid"</span>: <span class="string">"dca-l0K_QF2xP_JHi5iqtA"</span>,</div><div class="line">    <span class="attr">"version"</span>: &#123;</div><div class="line">        <span class="attr">"number"</span>: <span class="string">"7.2.0"</span>,</div><div class="line">        <span class="attr">"build_flavor"</span>: <span class="string">"default"</span>,</div><div class="line">        <span class="attr">"build_type"</span>: <span class="string">"tar"</span>,</div><div class="line">        <span class="attr">"build_hash"</span>: <span class="string">"508c38a"</span>,</div><div class="line">        <span class="attr">"build_date"</span>: <span class="string">"2019-06-20T15:54:18.811730Z"</span>,</div><div class="line">        <span class="attr">"build_snapshot"</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">"lucene_version"</span>: <span class="string">"8.0.0"</span>,</div><div class="line">        <span class="attr">"minimum_wire_compatibility_version"</span>: <span class="string">"6.8.0"</span>,</div><div class="line">        <span class="attr">"minimum_index_compatibility_version"</span>: <span class="string">"6.0.0-beta1"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"tagline"</span>: <span class="string">"You Know, for Search"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>说明Elasticsearch集群已经启动并且正常运行，接下来就可以进行各种试验了。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="查看插件列表"><a href="#查看插件列表" class="headerlink" title="查看插件列表"></a>查看插件列表</h4><p><code>elasticsearch-plugin list</code></p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p><code>elasticsearch-plugin install pluginName</code></p><h4 id="移除插件"><a href="#移除插件" class="headerlink" title="移除插件"></a>移除插件</h4><p><code>elasticsearch-plugin remove pluginName</code></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>安装分词插件：<code>bin/elasticsearch-plugin install analysis-icu</code></li><li>运行：<code>bin/elasticsearch</code></li><li>查看：<code>http://localhost:9200/_cat/plugins</code></li><li>输出：<code>username analysis-icu 7.2.0</code></li></ul><h4 id="集群运行"><a href="#集群运行" class="headerlink" title="集群运行"></a>集群运行</h4><ul><li>执行命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/elasticsearch -E node.name=节点名称 -E cluster.name=集群名称 -E path.data=节点对应数据 -d</div></pre></td></tr></table></figure><ul><li>查看节点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:9200/_cat/nodes?v</div></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.elastic.co/support/matrix#matrix_jvm" target="_blank" rel="external">Elasticsearch and JVM</a></p><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/brew.html" target="_blank" rel="external">Directory layout for Homebrew installs</a></p>]]></content>
      
      
      <categories>
          
          <category> es </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消除mapper中的黄线</title>
      <link href="/idea/eliminateYellowLine.html"/>
      <url>/idea/eliminateYellowLine.html</url>
      
        <content type="html"><![CDATA[<p>写个Mapper文件也要像输入验证码一样一堆干扰线嘛</p><a id="more"></a><p>IntelliJ IDEA 打开 MyBatis的mapper文件时，总有黄色的警告。警告有<code>No data sources configure</code>和<code>SQL dialect is not configured</code>，按照下列步骤操作即可消除。</p><ul><li>Settings</li><li>Editor</li><li>Inspections</li><li>右侧搜索SQL</li><li>取消No data sources configured勾选</li><li>取消SQL Dialect detection勾选</li><li>Apply</li><li>OK</li></ul>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我与地坛》读书笔记</title>
      <link href="/book/wydt.html"/>
      <url>/book/wydt.html</url>
      
        <content type="html"><![CDATA[<p>有过我的车辙的地方也都有过母亲的脚印</p><a id="more"></a><h2 id="第1章-我与地坛"><a href="#第1章-我与地坛" class="headerlink" title="第1章 我与地坛"></a>第1章 我与地坛</h2><ul><li><p>恐慌日甚一日，随时可能完蛋的感觉比完蛋本身可怕多了</p></li><li><p>你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。它们不能变成语言，它们无法变成语言，一旦变成语言就不再是它们了。</p></li></ul><h2 id="第2章-我二十一岁那年"><a href="#第2章-我二十一岁那年" class="headerlink" title="第2章 我二十一岁那年"></a>第2章 我二十一岁那年</h2><ul><li><p>还是看看书吧，你不是爱看书吗？人活一天就不要白活。将来你工作了，忙得一点儿时间都没有，你会后悔这段时光就让它这么白白地过去了。</p></li><li><p>他不知道，他还不懂，命运中有一种错误是只能犯一次的，并没有改正的机会，命运中有一种并非是错误的错误（比如淘气，是什么错误呢），但这却是不被原谅的。</p></li></ul><h2 id="第3章-合欢树"><a href="#第3章-合欢树" class="headerlink" title="第3章 合欢树"></a>第3章 合欢树</h2><ul><li>有时候只想独自静静地待一会儿。悲伤也成享受。 </li></ul><h2 id="第5章-墙下短记"><a href="#第5章-墙下短记" class="headerlink" title="第5章 墙下短记"></a>第5章 墙下短记</h2><ul><li>一些当时看去不太要紧的事却能长久扎根在记忆里。它们一向都在那儿安睡，偶尔醒一下，睁眼看看，见你忙着（升迁或者遁世）就又睡去，很多年里它们轻得仿佛不在。千百次机缘错过，终于一天又看见它们，看见时光把很多所谓人生大事消磨殆尽，而它们坚定不移固守在那儿，沉沉地有了无比的重量。</li></ul><h2 id="第10章-记忆与印象2"><a href="#第10章-记忆与印象2" class="headerlink" title="第10章 记忆与印象2"></a>第10章 记忆与印象2</h2><ul><li><p>快乐的日子里做人不能太小气。</p></li><li><p>但是，没人跟她玩了。这才是真正的恐惧。<br>她盼望着有人来跟她玩。但她盼望的并不是游戏的快乐，而是孩子们能够转变对她的态度。这才是真正的疑难。<br>一颗七岁的心，正在学会着根据别人的脸色来判断自己的处境。<br>一颗七岁的心已经懂得，要靠赢得别人对你的好感，来改善自己的处境。<br>但是，有什么办法吗？ </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《创华为：任正非传》读书笔记</title>
      <link href="/book/rzf.html"/>
      <url>/book/rzf.html</url>
      
        <content type="html"><![CDATA[<p>筚路蓝缕，以启山林</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>什么叫成功？是像日本那些企业那样，经过九死一生还能好好地活着，这才是真正的成功</li></ul><h2 id="毕业了，该何去何从"><a href="#毕业了，该何去何从" class="headerlink" title="毕业了，该何去何从"></a>毕业了，该何去何从</h2><ul><li>一个人再有本事也得通过所在社会的主流价值认同，才能有机会”</li></ul><h2 id="列强肆虐，任正非拍案而起"><a href="#列强肆虐，任正非拍案而起" class="headerlink" title="列强肆虐，任正非拍案而起"></a>列强肆虐，任正非拍案而起</h2><ul><li>在市场上，企业家的使命则是捍卫企业的市场地位。而现代商战中，只有技术自立才是根本，没有自己的科研支撑体系，企业地位就是一句空话</li></ul><h2 id="破釜沉舟，背水一战"><a href="#破釜沉舟，背水一战" class="headerlink" title="破釜沉舟，背水一战"></a>破釜沉舟，背水一战</h2><ul><li>企业的一把手跟下级员工之间的关系，就是大发动机跟小发动机的关系，你所带动的不是齿轮，不是螺丝钉。员工也可以成为一个发动机，而且能跟你同步。如果能够做到这样，这个企业活力就非常大</li></ul><h2 id="失之东隅，得之桑榆"><a href="#失之东隅，得之桑榆" class="headerlink" title="失之东隅，得之桑榆"></a>失之东隅，得之桑榆</h2><ul><li>理想再好，止步于竞争对手</li></ul><h2 id="决战亚非拉，重点突破"><a href="#决战亚非拉，重点突破" class="headerlink" title="决战亚非拉，重点突破"></a>决战亚非拉，重点突破</h2><ul><li>成则举杯相庆，败则拼死相救</li></ul><h2 id="技高一筹让德国人心服口服"><a href="#技高一筹让德国人心服口服" class="headerlink" title="技高一筹让德国人心服口服"></a>技高一筹让德国人心服口服</h2><ul><li>现代商业的成败，在很大程度上已经由细节决定了。大笔的金钱投入下去，往往只为了赚取百分之几的利润，而任何一个细节的失误，就可能将这些利润完全吞噬掉</li></ul><h2 id="大雨欲来风满楼"><a href="#大雨欲来风满楼" class="headerlink" title="大雨欲来风满楼"></a>大雨欲来风满楼</h2><ul><li>中国许多企业喜欢息事宁人，怕惹上官司。但是，在国际市场上退避三舍是没有用的，只能说明我们很自卑，因此应该挺起腰板据理力争，方可赢得认可。</li></ul><h2 id="思科向华为“出招”了"><a href="#思科向华为“出招”了" class="headerlink" title="思科向华为“出招”了"></a>思科向华为“出招”了</h2><ul><li>这起案件引燃了烟，虽然并未酿成火势，但你需要知道烟从何而来。</li></ul><h2 id="合纵连横，构建防线"><a href="#合纵连横，构建防线" class="headerlink" title="合纵连横，构建防线"></a>合纵连横，构建防线</h2><ul><li>首先要打破自我封闭，主动走上前台展示自己。</li></ul><h2 id="全面出击，逼和为胜"><a href="#全面出击，逼和为胜" class="headerlink" title="全面出击，逼和为胜"></a>全面出击，逼和为胜</h2><ul><li><p>管理层要淡化英雄色彩，实现职业化的流程管理。即使需要一个人去接受鲜花，他也仅仅是代表，而不是真正的英雄。</p></li><li><p>“价格战”是立不住脚的，海外市场拒绝机会主义，要拿实力来说话，只有独立开发自己的核心技术才是根本。</p></li></ul><h2 id="用美国的方式，在美国打赢官司"><a href="#用美国的方式，在美国打赢官司" class="headerlink" title="用美国的方式，在美国打赢官司"></a>用美国的方式，在美国打赢官司</h2><ul><li><p>你到别人家做客，就不能抠脚丫子</p></li><li><p>这场“世纪之讼”是华为全球化战略的转折点，不能硬打硬拼，走间接路线，寻找同盟者是最好的选择。</p></li><li><p>首先要加强知识产权保护意识。</p></li><li><p>专门成立了知识产权部，建立了相应的知识产权管理体系。</p></li><li><p>其次要加强合作伙伴建设。</p></li><li><p>就好比北京律师不能到深圳去打官司一样，要提前做好应对准备，要有一些合作伙伴。”</p></li><li><p>最后一定要以实力证明自己。</p></li></ul><h2 id="执行力提高竞争力"><a href="#执行力提高竞争力" class="headerlink" title="执行力提高竞争力"></a>执行力提高竞争力</h2><ul><li><p>一点就是强有力的执行力团队。</p></li><li><p>执行力就是竞争力。</p></li><li><p>华为今日的成功，正是依靠着华为人强大的执行力才完成的。华为贯彻执行力只有一个原则：万众一心。方法、手段只是形式，重要的是统一思想，使上下级相互认同，真正走出执行力实现难的瓶颈，实现共赢。</p></li></ul><h2 id="不达目的誓不罢休"><a href="#不达目的誓不罢休" class="headerlink" title="不达目的誓不罢休"></a>不达目的誓不罢休</h2><ul><li>狼是难缠的，不达目的永远不会罢休，它会想尽各种招数，实现自己的目的。在一个企业就要培养员工的这种顽强拼搏和锲而不舍的精神，只有这样，不管员工遇到多大的困难都会去克服，去战胜，找出办法寻求企业的发展。</li></ul><h2 id="打造一支众志成城的“狼团队”"><a href="#打造一支众志成城的“狼团队”" class="headerlink" title="打造一支众志成城的“狼团队”"></a>打造一支众志成城的“狼团队”</h2><ul><li><p>狼猎食时通常不会单独行动，而是依靠群体的力量共同奋斗。</p></li><li><p>在管理上，任正非也认识到靠一个人的决策难免会出问题，所以管理决策需要一个班子，要靠集体的智慧。</p></li><li><p>管理团队的能力比一把手的领导能力更重要，管理团队更能有效预示公司的绩效。</p></li></ul><h2 id="让每个员工都成为冲锋陷阵的“狼”"><a href="#让每个员工都成为冲锋陷阵的“狼”" class="headerlink" title="让每个员工都成为冲锋陷阵的“狼”"></a>让每个员工都成为冲锋陷阵的“狼”</h2><ul><li><p>生存下去的必要条件就是必须拥有市场份额，否则就没有一切。</p></li><li><p>一是敏锐的嗅觉，二是不屈不挠、奋不顾身的进攻精神，三是群体奋斗的意识。因此他提出“胜者举杯相庆，败者拼死相救”，不一而足。</p></li><li><p>先将事情干起来，不能裹足不前，贻误商机。</p></li></ul><h2 id="合纵连横打天下"><a href="#合纵连横打天下" class="headerlink" title="合纵连横打天下"></a>合纵连横打天下</h2><ul><li>为了建立稳定的市场关系，尽快了解客户的需求，任正非开始探索新形式：与客户“联姻”，建立合资公司，形成利益共同体，以此巩固市场，拓展市场。</li></ul><h2 id="要“狼性”，更要“人性”"><a href="#要“狼性”，更要“人性”" class="headerlink" title="要“狼性”，更要“人性”"></a>要“狼性”，更要“人性”</h2><ul><li><p>“狼性文化”是战争文化，给华为自身也带来了不少麻烦，“狼”跑到哪里，都会引起对手的高度警惕。</p></li><li><p>另一方面是一种人性的缺失。</p></li><li><p>狼性”只是手段，人性才是根本。</p></li><li><p>现代企业管理的重大责任，就在于谋求企业目标与个人目标两者的一致，两者越一致管理效果就越好。</p></li><li><p>狼性”最终还要回归人性，只有散发着人性光芒的企业才能基业长青。</p></li><li><p>企业凭借强大的执行力、战斗力和凝聚力跃过了生存线，开始了向大企业迈进的过程，这就需要减少文化中的刚性，这是企业保持长久活力的关键。</p></li><li><p>随着社会的进步，和平共赢成为时代要求，人的作用和价值日益彰显。</p></li><li><p>海纳百川，有容乃大。”对跨国大企业而言，需要有一套全球化的标准和规则，在制定和执行的时候就要考虑到文化的包容性和共生性。</p></li><li><p>真正成为一个国际化的大公司，首先就要有一种兼容并蓄的大企业文化。</p></li><li><p>企业跨国经营，要实现商业目标需要融合三种文化：企业文化、自己国家的文化、目标市场国家的文化。</p></li><li><p>遵循国际共同的商业价值取向，与国际巨头为友，有了真正的“绅士”风度，人性越来越浓。</p></li></ul><h2 id="第八章-人才兴企业兴，以奋斗者为本"><a href="#第八章-人才兴企业兴，以奋斗者为本" class="headerlink" title="第八章 人才兴企业兴，以奋斗者为本"></a>第八章 人才兴企业兴，以奋斗者为本</h2><ul><li><p>一个企业要取得长足的发展，最缺乏的不是别的，正是人才！</p></li><li><p>任正非的人才战略与众不同，不唯学历不唯经验，而是看能力和潜力，完全是西方式的人才管理理念，这形成了华为的一大特色</p></li></ul><h2 id="花大本钱培训员工"><a href="#花大本钱培训员工" class="headerlink" title="花大本钱培训员工"></a>花大本钱培训员工</h2><ul><li>员工培训是企业风险最小、收益最大的战略性投资。</li></ul><h2 id="为人才创造发展环境"><a href="#为人才创造发展环境" class="headerlink" title="为人才创造发展环境"></a>为人才创造发展环境</h2><ul><li><p>华为在招聘过程中最注重员工有无发展培养的潜力，其次才是经验。</p></li><li><p>首先是平台效应。华为按公司组织目标与事业机会的要求，依据制度性甄别程序，对有突出才干和突出贡献者实现破格晋升。</p></li><li><p>其次是集体氛围。</p></li></ul><h2 id="“鲇鱼效应”的极致运用"><a href="#“鲇鱼效应”的极致运用" class="headerlink" title="“鲇鱼效应”的极致运用"></a>“鲇鱼效应”的极致运用</h2><ul><li><p>这种被对手激活的现象在经济学上被称作“鲇鱼效应”。</p></li><li><p>烧不死的鸟才是凤凰</p></li></ul><h2 id="高薪酬是第一推动力"><a href="#高薪酬是第一推动力" class="headerlink" title="高薪酬是第一推动力"></a>高薪酬是第一推动力</h2><ul><li>众所周知，一个好的薪酬结构体系将有效地保证企业发展中的动态合理性，并促进企业的竞争力与提升员工的成就感。能否在士气上与员工的归属感上创造价值，是一个好的薪酬体系的评价标准。</li></ul><h2 id="绝不让“雷锋”吃亏"><a href="#绝不让“雷锋”吃亏" class="headerlink" title="绝不让“雷锋”吃亏"></a>绝不让“雷锋”吃亏</h2><ul><li>外部的竞争力则主要是通过薪酬的调整与支付来进行分析。具体的评价标准是：第一看是否能有助于实现企业战略，第二看能否帮助提升企业战略，最后看能否促进组织成长。</li></ul><h2 id="华为拒绝“富二代”"><a href="#华为拒绝“富二代”" class="headerlink" title="华为拒绝“富二代”"></a>华为拒绝“富二代”</h2><ul><li><p>有五成人其实是不适合接班的。主要原因有二：一是创业者后代的成长环境与父辈有很大的差别，他们更倾向于从事新兴的职业；二是因与父辈之间存在明显的文化差异，担心二者在企业之后的经营管理过程中频繁出现分歧，影响家族感情。</p></li><li><p>在任正非看来，这种“富二代现象”产生的根源主要有以下两个原因：<br>第一，公司确实底子厚了，资源丰富了，一些人对于小生意看不上了。<br>第二，现有的分配和激励机制，使得主管对人均效率提升没有任何动力。</p></li></ul><h2 id="第九章-以市场为先导，以客户为主导"><a href="#第九章-以市场为先导，以客户为主导" class="headerlink" title="第九章 以市场为先导，以客户为主导"></a>第九章 以市场为先导，以客户为主导</h2><ul><li><p>任何一个不起眼的细节和一个不起眼的角色都有可能决定在某一个项目中华为的去留。所以华为规定：在处理客户关系的时候，必须一视同仁，不能轻视订单量小的普遍客户，不能只重复地接触个别的高层领导，对于其他的一些中层领导甚至是普通员工都要“奉为上宾”</p></li><li><p>生存下来的理由是为了客户</p></li></ul><h2 id="“最小的客户我都要见”"><a href="#“最小的客户我都要见”" class="headerlink" title="“最小的客户我都要见”"></a>“最小的客户我都要见”</h2><ul><li>李嘉诚说：“保持低调，才能避免树大招风，才能避免成为别人进攻的靶子。如果你不过分显示自己，就不会招惹别人的敌意，别人也就无法捕捉你的虚实。”</li></ul><h2 id="以宗教般的虔诚感动客户"><a href="#以宗教般的虔诚感动客户" class="headerlink" title="以宗教般的虔诚感动客户"></a>以宗教般的虔诚感动客户</h2><ul><li><p>在国际上，成功的企业都懂得倾听顾客的心声，将顾客的抱怨变成最有价值的建议。虽然顾客并非全是对的，但一定要站在顾客的立场来思考问题，也就是要有同理心。</p></li><li><p>基于客户需求导向的组织建设。</p></li><li><p>基于客户需求导向的产品投资决策和产品开发决策。</p></li><li><p>在产品开发过程中构筑客户关注的质量、成本、可服务性、可用性及可制造性</p></li><li><p>基于客户需求导向的人力资源及干部管理。</p></li><li><p>其实比技能更重要的是毅力，比毅力更重要的是品德，比品德更重要的是胸怀，要让客户找到感觉。</p></li></ul><h2 id="以客户满意度为标准"><a href="#以客户满意度为标准" class="headerlink" title="以客户满意度为标准"></a>以客户满意度为标准</h2><ul><li><p>我们只有瞄准业界最佳才有生存的余地。</p></li><li><p>判断产品好与不好，必须要让客户来下断定，客户满意了才是好产品。不然技术含量再高，但是客户不满意，都不能算是好产品。</p></li></ul><h2 id="客户需要什么就做什么"><a href="#客户需要什么就做什么" class="headerlink" title="客户需要什么就做什么"></a>客户需要什么就做什么</h2><ul><li><p>客户需要什么我们就做什么。卖得出去的东西，或领先市场一点的产品，才是客户真正的技术需求。超前太多的技术，当然也是人类的瑰宝，但必须以牺牲自己来完成。</p></li><li><p>新技术一定要满足质量好、服务好、成本低的要求，不然就没有商业意义。</p></li><li><p>华为要瞄准世界顶尖技术，建立一流的研发团队，但不研发“卖不掉的世界顶尖水平”，而且最好是比别人领先半步研制成功。</p></li><li><p>其次，不做技术崇拜者，要做工程商人。</p></li><li><p>一切以市场需求为导向，包括技术开发。</p></li><li><p>再次，要积极听取客户、同事的意见。</p></li></ul><h2 id="以气势压倒对手的营销策略"><a href="#以气势压倒对手的营销策略" class="headerlink" title="以气势压倒对手的营销策略"></a>以气势压倒对手的营销策略</h2><ul><li>一个营销战术就是营造气势，不惜一切代价，集中优势兵力猛攻</li></ul><h2 id="从销售向营销转变"><a href="#从销售向营销转变" class="headerlink" title="从销售向营销转变"></a>从销售向营销转变</h2><ul><li><p>一个企业的发展从来就不是一帆风顺的，在低谷中认真地检视自身的不足就显得格外重要。</p></li><li><p>穷则变，变则通，通则久。</p></li><li><p>遇到了问题绞尽脑汁也找不着头绪，不如换个思路试试。</p></li><li><p>华为的营销理念真正确立起来了。华为不只是拿到合同，建好网络走人，更重要的是为客户提供好的服务：不是要帮客户解决短期问题，而是要建立长期的友好合作。</p></li></ul><h2 id="营销要走外交路线"><a href="#营销要走外交路线" class="headerlink" title="营销要走外交路线"></a>营销要走外交路线</h2><ul><li><p>个人再有本事，也要得到主流价值的认同，否则就没有发展的机会。</p></li><li><p>华为依照外交路线设计营销路线，是非常明智的选择。好处有两点：一是可以在国家外交的背景下，长期稳定海外发展方向；二是在为经济外交做贡献的同时，可以优先获得国家的支持。此外，紧跟外交，有国家强大的实力做后盾，为企业的发展提供了政治支持，也容易在目标市场所在国赢得好感和认同，也保证了投资的稳定，受政治波动的影响小，降低了风险。</p></li></ul><h2 id="第十章-我是一个百分之百的偏执狂"><a href="#第十章-我是一个百分之百的偏执狂" class="headerlink" title="第十章 我是一个百分之百的偏执狂"></a>第十章 我是一个百分之百的偏执狂</h2><ul><li><p>企业存在的意义是最大化每股的中期收益。</p></li><li><p>我们必须吃饭才能活下去，这不是没有道理，但是如果我们活着就是为了吃饭，那就大错特错了。</p></li><li><p>创造利润是一个公司非常重要的任务，但绝不是它的最终目的。利润只是公司的一个手段，是为了更好地、更充分地开展工作或制造产品（提供服务），最终目的是让企业发展得更平稳、活得更长久。</p></li><li><p>企业要一直活下去，不要死掉，这才是一个真正的企业家该有的心态。</p></li></ul><h2 id="狂人也有柔情的一面"><a href="#狂人也有柔情的一面" class="headerlink" title="狂人也有柔情的一面"></a>狂人也有柔情的一面</h2><ul><li><p>它需要所有的员工必须坚持合作，走集体奋斗的道路。否则个人的聪明才智就会很难发挥，并有所成就，企业也难以获得成就，甚至影响生存。</p></li><li><p>领导要有温情，与员工打成一片。在华为，领导请下属吃饭是司空见惯的事情，也是从公司创业之始就流传下来的传统之一。</p></li></ul><h2 id="个人智慧的极限"><a href="#个人智慧的极限" class="headerlink" title="个人智慧的极限"></a>个人智慧的极限</h2><ul><li><p>企业高层人才的培养，最重要的就是通过实践的锻炼，不断地独立完成战略决策，</p></li><li><p>一个人的战略所造成的另外一个致命的问题，就是华为的战略决策缺乏透明度。</p></li><li><p>华为内部缺乏自上而下和自下而上的双向沟通交流机制，上司的意图，经过几层传递后就会完全走样。</p></li></ul><h2 id="独一无二的“灰度管理者”"><a href="#独一无二的“灰度管理者”" class="headerlink" title="独一无二的“灰度管理者”"></a>独一无二的“灰度管理者”</h2><ul><li>任正非的经营管理思想的核心就是均衡，均衡是其最高的经营管理哲学。</li></ul><h2 id="第十一章-华为没有成功，只有成长"><a href="#第十一章-华为没有成功，只有成长" class="headerlink" title="第十一章 华为没有成功，只有成长"></a>第十一章 华为没有成功，只有成长</h2><ul><li>管理进步的基本手段最简单讲有两个方面：一是向他人学习，二是自我反思。</li></ul><h2 id="独一无二的矩阵管理体系"><a href="#独一无二的矩阵管理体系" class="headerlink" title="独一无二的矩阵管理体系"></a>独一无二的矩阵管理体系</h2><ul><li><p>权力过于集中于“全能”管理者，而当这个“全能”管理者离职时，难以找到替代者；另外，也容易导致部门间协调工作难做。</p></li><li><p>形成了一套属于并且只适合自身发展的独一无二的组织管理体系：矩阵结构（二维组织结构），即按战略性事业划分的事业部和按地区战略划分的地区公司，由事业部和地区公司承担实际盈利的责任。</p></li><li><p>首先是确立事业部制。</p></li><li><p>其次是建立地区公司。</p></li></ul><h2 id="引入IBM先进的管理理念"><a href="#引入IBM先进的管理理念" class="headerlink" title="引入IBM先进的管理理念"></a>引入IBM先进的管理理念</h2><ul><li><p>IPD作为先进的产品开发理念，其核心思想概括如下：①新产品开发是一项投资决策。IPD强调要对产品开发进行有效的投资组合分析，并在开发过程设置检查点，通过阶段性评审来决定项目是继续、暂停、种植还是改变方向。②基于市场的开发。IPD强调产品创新一定是基于市场需求和竞争分析的创新。为此，IPD把正确定义产品概念、市场需求作为流程的第一步，开始就把事情做正确。③跨部门、跨系统的协同。采用跨部门的产品开发团队（PDT:Product Development Team），通过有效的沟通、协调以及决策，达到尽快将产品推向市场的目的。④异步开发模式，也称并行工程。就是通过严密的计划、准确的接口设计，把原来的许多后续活动提前进行，这样可以缩短产品上市时间。⑤重用性。采用公用构建模块（CBB:Common Building Block）提高产品开发的效率。⑥结构化的流程。产品开发项目的相对不确定性，要求开发流程在非结构化与过于结构化之间找到平衡。</p></li><li><p>过去的10年间，华为之所以能够在与国际对手的竞争中发展起来，主要依靠两个方面的比较优势：一是人力资源的成本优势；二是基于中国市场特点的营销能力。相对的成本优势也是绝大多数中国企业在参与国际竞争中的基本优势。</p></li><li><p>所谓成本优势大多建立在人力成本或其他自然资源的基础之上。</p></li><li><p>而是在保证产品质量的前提之下缩短产品的上市时间（ITM, Time To Market）</p></li><li><p>IPD流程强调的是产品从市场调研、需求分析、预研与立项、系统设计、产品开发、中间实验、制造生产、营销、销售、工程安装、培训与服务到用户信息反馈的完整流程意义上的产品线管理。每一条产品线必须对自己的产品是否响应市场需求和销售效益负责，克服了研发部门片面追求技术而忽视市场反馈的单纯技术观点，也克服了市场部门只顾当前销售而不关心产品战略的短视倾向</p></li><li><p>ISC流程的概念就是，企业之间的竞争其实也是供应链之间的竞争。ISC要求把公司运作的每个环节都看成是供应链上的一部分，不管是在公司内部，还是在公司以外的合作伙伴那里，都需要对每个环节进行有效管理，以提高供应链运作效率和经济效益。</p></li><li><p>IBM顾问指出，华为的供应链管理仅仅发挥了20%的效率，还存在很大的提升空间。他们认为华为的核心竞争力在于技术的领先和市场的优势。在供应链管理的过程中只要牢牢把握住核心竞争力，其余非核心部分完全可以外包出去，让那些专业公司分包。</p></li></ul><h2 id="加长企业的每一块短板"><a href="#加长企业的每一块短板" class="headerlink" title="加长企业的每一块短板"></a>加长企业的每一块短板</h2><ul><li><p>我们不重视体系的建设，就会造成资源上的浪费。要减少木桶的短木板，就要建立均衡的价值体系，要强调公司整体核心竞争力的提升</p></li><li><p>关于如何解决华为不均衡发展的问题，任正非在多次讲话中谈道：首先要进行岗位轮换制度。我们的干部轮换有两种，一种是业务轮换，如研发人员去搞中试、生产、服务，使他真正理解什么叫作商品，那么他才能成为高层资深技术人员，如果没有相关经验，他就不能叫资深。因此，资深两字就控制了他，使他要朝这个方向努力。另一种是岗位轮换，让高中级干部的职务发生变动，一是有利于公司管理技巧的传播，形成均衡发展，二是有利于优秀干部快速成长。</p></li><li><p>所以，产品线还是要考核和核算，但不要说哪个产品赚钱，哪个产品不赚钱，赚钱的就趾高气扬，不赚钱的就垂头丧气，这样，公司很快就崩溃了。</p></li><li><p>公司对于整个研发流程的考核一是考潜力的增长，二是考对公司的贡献。</p></li></ul><h2 id="《华为基本法》诞生"><a href="#《华为基本法》诞生" class="headerlink" title="《华为基本法》诞生"></a>《华为基本法》诞生</h2><ul><li>华为只有无比专注地通过来自竞争的压力来不断提升自己，才能最终成长为世界级的企业，而这是唯一的道路，没有捷径。</li></ul><h2 id="防范危机，未雨绸缪"><a href="#防范危机，未雨绸缪" class="headerlink" title="防范危机，未雨绸缪"></a>防范危机，未雨绸缪</h2><ul><li><p>忧患和质量控制意识被任正非时常提及。</p></li><li><p>华为公司不管社会上怎么攻击我们，我们从不解释，因为我们没有工夫，我们的重心是建设自己。”</p></li></ul><h2 id="第十二章-成功就是和自己的较量"><a href="#第十二章-成功就是和自己的较量" class="headerlink" title="第十二章 成功就是和自己的较量"></a>第十二章 成功就是和自己的较量</h2><ul><li><p>成功就是和自己的较量</p></li><li><p>低调，低调，再低调；老老实实做人，踏踏实实做事</p></li><li><p>穷困是有大作为的人的第一桶金，饥饿感就是一个人不竭的动力源。</p></li><li><p>凡是战略，都是专注，凡是执行，都是坚持。</p></li></ul><h2 id="神龙见首不见尾"><a href="#神龙见首不见尾" class="headerlink" title="神龙见首不见尾"></a>神龙见首不见尾</h2><ul><li>那些有足够定力的孤独者，才有可能成为中国商界的孤独英雄，也才有可能造就中国级世界级的相对长寿的商业帝国。</li></ul><h2 id="心如止水的恬静"><a href="#心如止水的恬静" class="headerlink" title="心如止水的恬静"></a>心如止水的恬静</h2><ul><li><p>伟大的人物淡泊名利，恬静的心境，谦卑的心态，对真理的无止境的追求，构成了他们的全部。</p></li><li><p>专家专家，懂一点叫专家，懂得很多叫什么专家呢？为什么会出现专家的名词呢？就是因为人的生命有限，只可能懂得一点。</p></li></ul><h2 id="没有不带着汗水和心血的成功"><a href="#没有不带着汗水和心血的成功" class="headerlink" title="没有不带着汗水和心血的成功"></a>没有不带着汗水和心血的成功</h2><ul><li>任正非的成功不在于他个人拥有多少财富，而在于他建立起来了一个什么样的企业，他在这个企业以及现在社会中的精神影响力。</li></ul><h2 id="成功永无止境"><a href="#成功永无止境" class="headerlink" title="成功永无止境"></a>成功永无止境</h2><ul><li>成功只能说明过去，只有在思想中保持艰苦奋斗的优良传统，才能不为过去的成就所束缚，才能站在更高的层次获得更大的进步。</li></ul>]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《褚时健传》读书笔记</title>
      <link href="/book/csj.html"/>
      <url>/book/csj.html</url>
      
        <content type="html"><![CDATA[<p>世上无难事，只怕有心人</p><a id="more"></a><h2 id="推荐序一-我自己的一点总结"><a href="#推荐序一-我自己的一点总结" class="headerlink" title="推荐序一 我自己的一点总结"></a>推荐序一 我自己的一点总结</h2><ul><li><p>一个人如果庸庸碌碌地活，我相信是不会有什么人生经验的。</p></li><li><p>一个人不虚度时光，要对国家对社会有贡献，人生才有价值。</p></li><li><p>我这个人，做事讲求踏实和认真。我从来不认为自己是个天才。但我一直是个实实在在做事的人，而且我有十分的认真态度，做哪一行就尊重哪一行的规律。学习多、了解多、实践多，心里就有足够的谱气。</p></li><li><p>我人生里没有服过输的时候，但我都是和自己较劲。我希望我的人生价值都体现在当下，而不是昨天曾经如何。</p></li></ul><h2 id="推荐序二-企业家的尊严"><a href="#推荐序二-企业家的尊严" class="headerlink" title="推荐序二 企业家的尊严"></a>推荐序二 企业家的尊严</h2><ul><li><p>个人并不是生来要被打败的，你尽可以把他消灭掉，可就是打不败他。</p></li><li><p>敌人的枪炮再厉害，却只能伤害你的身体，而自己人的訾议再微弱，却句句砍在心上</p></li><li><p>能在自己的家庭中寻求到安宁的人是最幸福的人。</p></li></ul><h2 id="推荐序三-看褚时健如何走出“哀牢山”"><a href="#推荐序三-看褚时健如何走出“哀牢山”" class="headerlink" title="推荐序三 看褚时健如何走出“哀牢山”"></a>推荐序三 看褚时健如何走出“哀牢山”</h2><ul><li>正如尼采所言，一个伟大的人格，可以在自己的身上克服这个时代。</li></ul><h2 id="前言-这本书是这样的……"><a href="#前言-这本书是这样的……" class="headerlink" title="前言 这本书是这样的……"></a>前言 这本书是这样的……</h2><ul><li>当下被互联网裹挟的一代人，习惯于在虚拟生活中获得慰藉的一代人，充满朝气地生活、具备脚踏实地的精神对他们而言显得多么重要。</li></ul><h2 id="第一章-起始"><a href="#第一章-起始" class="headerlink" title="第一章 起始"></a>第一章 起始</h2><ul><li>有时想想，所谓“见识”无非就是见过好东西，然后能判断什么是好东西，进而能做出好东西。</li></ul><h2 id="第二章-童年浪花"><a href="#第二章-童年浪花" class="headerlink" title="第二章 童年浪花"></a>第二章 童年浪花</h2><ul><li>无论在任何一个生活阶段，他在睡前都要看几十页书。</li></ul><h2 id="第三章-少年故事"><a href="#第三章-少年故事" class="headerlink" title="第三章 少年故事"></a>第三章 少年故事</h2><ul><li><p>纷乱年代，谁都没有安全感，也无法得到安全感。</p></li><li><p>不管什么事，你要先搞懂才做，不懂的事，先向别人学习。不然你亏本了都不知道为什么。”</p></li><li><p>做什么事都琢磨一下</p></li><li><p>做事、把事做好，就会快乐，就会有成就感。</p></li><li><p>多了解大事，才能做大事……</p></li></ul><h2 id="褚时健自述-我的1943"><a href="#褚时健自述-我的1943" class="headerlink" title="褚时健自述 我的1943"></a>褚时健自述 我的1943</h2><ul><li><p>死意味着永远离开，意味着你本来正在做、应该做的事情再也没有办法去做了。有些人本来可以因为你活着，可以生活得平平静静，但死会让这个平静永永远远丧失掉。</p></li><li><p>从那以后我就懂得了，做什么事都要会观察，会总结，找到规律。万事万物都有自己的规律，规律搞清楚了，办法就出来了。闷着头做事不动脑子，力气用尽了也不一定有好收获。</p></li><li><p>做事情找规律就是你心里要有一本清清楚楚的账，莫糊涂。</p></li></ul><h2 id="第二章-战火纷飞"><a href="#第二章-战火纷飞" class="headerlink" title="第二章 战火纷飞"></a>第二章 战火纷飞</h2><ul><li>80年代时他曾趁着出差到战友们的家乡去见故人，可惜一个也没有见到。“都死了。”他说。</li></ul><h2 id="第三章-解放"><a href="#第三章-解放" class="headerlink" title="第三章 解放"></a>第三章 解放</h2><ul><li>做事做实事，说话说实话，大家都信任你。哪个服你的强迫？一杆枪顶上去逼人家听话，白天听你的话，晚上他就暴动了。事情做公平了，利益平衡了，他心里舒服，你喊他暴动他也不暴动。”</li></ul><h2 id="第六章-波澜骤起"><a href="#第六章-波澜骤起" class="headerlink" title="第六章 波澜骤起"></a>第六章 波澜骤起</h2><ul><li>满地鸡毛蒜皮的生活对于普通人其实是幸事，起码这意味着生活无大事。</li></ul><h2 id="褚时健自述-我的1958"><a href="#褚时健自述-我的1958" class="headerlink" title="褚时健自述 我的1958"></a>褚时健自述 我的1958</h2><ul><li>人哪，打击是经常的，你自己心里要有谱气，不然什么都干不了。</li></ul><h2 id="第三章-到了另一个农场"><a href="#第三章-到了另一个农场" class="headerlink" title="第三章 到了另一个农场"></a>第三章 到了另一个农场</h2><ul><li>都说良善的环境激发人的美德，充满恶意和怀疑的环境则把人的负面能量引发出来。</li></ul><h2 id="第四章-新平，新平"><a href="#第四章-新平，新平" class="headerlink" title="第四章 新平，新平"></a>第四章 新平，新平</h2><ul><li><p>其实不难，是他们脑子里没那根弦，不想往前一步，不钻研，不认真。</p></li><li><p>目标清晰——瞄准目标——聚精会神——拿下。他喜欢这种干脆利落、心无旁骛、凭技术说话的工作。</p></li></ul><h2 id="第五章-迅速进入角色"><a href="#第五章-迅速进入角色" class="headerlink" title="第五章 迅速进入角色"></a>第五章 迅速进入角色</h2><ul><li><p>没有技术搞不成伙食。</p></li><li><p>要想做成一件事情，必须让相关各方能够利益平衡，都能从中获利。</p></li><li><p>做生意不能只想着让自己赚钱，适当让利，常常会获得更大的利益。</p></li></ul><h2 id="第八章-希望的光就要来了"><a href="#第八章-希望的光就要来了" class="headerlink" title="第八章 希望的光就要来了"></a>第八章 希望的光就要来了</h2><ul><li><p>企业的人不管利润，不管企业前途，不管职工生活，不如回家卖红薯！</p></li><li><p>最单调的生活是最安全的。</p></li></ul><h2 id="褚时健自述-我的1966——1976"><a href="#褚时健自述-我的1966——1976" class="headerlink" title="褚时健自述 我的1966——1976"></a>褚时健自述 我的1966——1976</h2><ul><li><p>一个人，别人把你打倒了不要紧，总有事情是自己控制不了的；但自己不要把自己打倒，不然就真的是彻底倒了翻不了身了。</p></li><li><p>患过难的一家人，在一起才是最重要的，其他都可以被消化掉。</p></li><li><p>老是有人问我，工作和家庭哪个更重要？其实这么比很没有意义，工作和家庭各自承担的作用不一样。干工作，必须对社会责任，不搞不行。回到家，家庭是个避风港，放松最重要。</p></li></ul><h2 id="第二章-万事开头难"><a href="#第二章-万事开头难" class="headerlink" title="第二章 万事开头难"></a>第二章 万事开头难</h2><ul><li>业务一定要好。</li></ul><h2 id="褚时健自述-我的1979"><a href="#褚时健自述-我的1979" class="headerlink" title="褚时健自述 我的1979"></a>褚时健自述 我的1979</h2><ul><li><p>我这个人，有事情做就有干劲得很，不要让我闲着，闲着我就要生病。而且如果事情在眼前，要么彻底不做，要么就做到最好。沾了自己手的事情，做不好不好意思。</p></li><li><p>做过了你就知道原来可以，你不做就永远都不进步。</p></li><li><p>如果你叫我来负责做什么事情，就应该完全放权给我。失误了，我改进，我做检讨，我自己把后果承担起来。</p></li><li><p>挑一个人，就看他做事是好还是坏，一定要看事情，不要看他说得怎么样。</p></li><li><p>要建立某一种制度，总是要经历各路人的不接受，关键是你自己想好了就要坚持。一旦制度确立，以后的事情就好办了。制度还是非常重要的。</p></li><li><p>没有一个良好的激励机制、奖惩制度，人的积极性发挥不出来。</p></li></ul><h2 id="第三章-启动改革"><a href="#第三章-启动改革" class="headerlink" title="第三章 启动改革"></a>第三章 启动改革</h2><ul><li><p>员工生活福利其实是搞好生产的前提和后续保证。这种实实在在的收益比做几个月的思想工作管用得多。</p></li><li><p>细节是魔鬼。</p></li><li><p>企业的本质就是逐利。</p></li><li><p>有竞争才能带来利润。</p></li><li><p>做任何事情都要讲个本分。企业的本分就是要赢利。</p></li><li><p>两个竞争概念，一个是市场竞争，一个是内部竞争</p></li></ul><h2 id="第四章-出手改革"><a href="#第四章-出手改革" class="headerlink" title="第四章 出手改革"></a>第四章 出手改革</h2><ul><li>对于后排企业而言，此时就是谁脑子快、动手快，谁就赢。</li></ul><h2 id="第六章-烟叶的故事"><a href="#第六章-烟叶的故事" class="headerlink" title="第六章 烟叶的故事"></a>第六章 烟叶的故事</h2><ul><li>无论什么标准，唯一有价值、有意义的标准应该是消费者的钱包。</li></ul><h2 id="褚时健自述-我的1986"><a href="#褚时健自述-我的1986" class="headerlink" title="褚时健自述 我的1986"></a>褚时健自述 我的1986</h2><ul><li>做事就是要苦干、实干，用人就是要用好人、能人。</li></ul><h2 id="第七章-内部管理大小事"><a href="#第七章-内部管理大小事" class="headerlink" title="第七章 内部管理大小事"></a>第七章 内部管理大小事</h2><ul><li><p>对于企业强人向来有一种说法，就是个人能力太强，企业的管理便弱化了。强人的个人威权可以淡化管理和制度，也能使企业良性运转</p></li><li><p>现代企业实际上是摈弃强人的，制度才是保证企业发展的最好武器。</p></li><li><p>一个企业家起码要具备两种能力，一是引导自己的能力，二是帮助他人的能力。</p></li><li><p>管人不在表面上，你要自己内功过关，自己在业务上成熟，才能服众。</p></li><li><p>“管理员工，自己的业务要强，不然人家给你考试，三回两回你被考倒了，就不好管理了。”</p></li></ul><h2 id="第一章-名烟翻番"><a href="#第一章-名烟翻番" class="headerlink" title="第一章 名烟翻番"></a>第一章 名烟翻番</h2><ul><li><p>或许时势造英雄，不过成为英雄何其壮烈。这几乎是一种想撞开橡皮门的勇气，不仅要勇敢，还要有一种霸蛮的执着。</p></li><li><p>作为一个优秀的企业家，当把企业发展到一定高度，进一步要做行业的执话语权者，行业的真正领袖，还要懂得平衡行业利益，抑强扶弱。</p></li></ul><h2 id="第二章-关索坝工程"><a href="#第二章-关索坝工程" class="headerlink" title="第二章 关索坝工程"></a>第二章 关索坝工程</h2><ul><li>作为一名特殊行业的国企领导，需要具备的最大能力也许不是搞生产提高利润，而是协调、申请、周旋、权衡……</li></ul><h2 id="褚时健自述-我的1994"><a href="#褚时健自述-我的1994" class="headerlink" title="褚时健自述 我的1994"></a>褚时健自述 我的1994</h2><ul><li><p>做事情哪，有所为有所不为。投资的多元化项目，我们不懂行，只投资不参加具体管理。烟草配套的生产项目，我们懂，就参与管理，发挥自己的长处，藏起自己的短处，这样你才不吃亏。</p></li><li><p>我以前顾着工作太多，对家庭比较忽略。到现在我是明白了，实际上一个人的人生乐趣最终都是从家庭里找。</p></li></ul><h2 id="第一章-是结束，也是开始"><a href="#第一章-是结束，也是开始" class="headerlink" title="第一章 是结束，也是开始"></a>第一章 是结束，也是开始</h2><ul><li>“做什么事情，如果心里没有把握，就不要去做。</li></ul><h2 id="第二章-土地、水和树"><a href="#第二章-土地、水和树" class="headerlink" title="第二章 土地、水和树"></a>第二章 土地、水和树</h2><ul><li><p>做事一定要有七八成的把握后才去做，这样心里才有谱气，事情才有可能成功。</p></li><li><p>要得到他的放心何其难？在他眼皮底下做事，唯有认真，没有第二条出路。</p></li><li><p>老板做事总是留余地的，不像年轻人那样莽撞。</p></li></ul><h2 id="第三章-橙树在长大"><a href="#第三章-橙树在长大" class="headerlink" title="第三章 橙树在长大"></a>第三章 橙树在长大</h2><ul><li>人哪，做什么事都是有因为所以的。现在的一些收获，一定是因为以前有积累，</li></ul><h2 id="第四章-一年比一年丰收"><a href="#第四章-一年比一年丰收" class="headerlink" title="第四章 一年比一年丰收"></a>第四章 一年比一年丰收</h2><ul><li><p>走两圈土地，你总要有点问题看出来，然后还要有解决问题的能力。不然，草都被你踩死了，一点问题没解决，有什么用？”</p></li><li><p>公司里人多了，事情就少了，人会懒</p></li><li><p>要让人做事，叫他多负点责任。不然他吃闲饭还要骂人</p></li></ul><h2 id="第六章-江山无限"><a href="#第六章-江山无限" class="headerlink" title="第六章 江山无限"></a>第六章 江山无限</h2><ul><li>你开个馆子，好朋友可以第一天来，第二天来，来个四五天送钱给你没关系。要是你做的东西不好吃，谁也不会来了。”</li></ul><h2 id="褚时健自述-种橙十年"><a href="#褚时健自述-种橙十年" class="headerlink" title="褚时健自述 种橙十年"></a>褚时健自述 种橙十年</h2><ul><li><p>你要做管理工作，首先生产业务就要熟悉，不然话说出来都不对路。</p></li><li><p>无论做什么事情，人哪，都要有一颗敬畏心，自然规律、市场规律都要遵守。人当然要努力，要全心全力达到自己的目的，但同时也要实事求是，走得两步，停下来想一想，以后的路才不会走错。</p></li><li><p>不要陶醉人家怎么夸你怎么捧你，做好自己的本分</p></li><li><p>不然，人家的口水等着喷你。</p></li><li><p>心里要知道感激，更要学会让大家利益都得到平衡</p></li><li><p>做人做事要随时随地都在检查，做这件事我朋友亏了没有？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> book </category>
          
      </categories>
      
      
        <tags>
            
            <tag> book </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql修改用户名和密码</title>
      <link href="/MySQL/update.html"/>
      <url>/MySQL/update.html</url>
      
        <content type="html"><![CDATA[<p>首先，登录，MySQL。</p><a id="more"></a><p><strong>修改用户名：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">use</span> mysql;</div><div class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> <span class="keyword">user</span>=<span class="string">"newUserName"</span> <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">"oldUserName"</span>;</div></pre></td></tr></table></figure><p><strong>修改密码：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> 用户名@localhost = <span class="keyword">password</span>(<span class="string">'新密码'</span>);</div></pre></td></tr></table></figure><p><strong>修改端口：</strong></p><p>在MySQL安装目录找到<code>my.ini</code>配置文件</p><p>找到<code>port=3306</code>，修改为想要改成的端口号，重启MySQL服务即可生效。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支操作</title>
      <link href="/git/branch.html"/>
      <url>/git/branch.html</url>
      
        <content type="html"><![CDATA[<p>一个需求一个分支，需求无穷尽，分支无穷尽。</p><a id="more"></a><ul><li><p>重命名分支</p><ul><li>重命名本地分支：<code>git branch -m oldBranchName newBranchName</code></li><li>删除远程分支：<code>git push origin :oldBranchName</code></li><li>将重命名过的分支提交：<code>git push origin newBranchName</code></li></ul></li><li><p>查看本地分支及追踪的分支：<code>git branch -vv</code></p></li><li>查看远程分支：<code>git branch -a</code></li><li>设置远程跟踪分支：<code>git branch --set-upstream-to=origin/newBranchName</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac没有声音</title>
      <link href="/mac/audio.html"/>
      <url>/mac/audio.html</url>
      
        <content type="html"><![CDATA[<p>想听歌，插上耳机，还是一片安静</p><a id="more"></a><ul><li>检查音乐软件是否为静音，调整声音</li><li><p>检查电脑音量</p></li><li><p>检查输出设备是否为耳机</p><ul><li>点击屏幕上方小喇叭图标，查看Output device，显示Headphones</li><li>如果输出设备是显示器，修改为耳机</li></ul></li><li>一切皆正常</li></ul><p>解决办法一：</p><ul><li>电源线、耳机插拔一下</li></ul><p>解决办法二：</p><ul><li>控制台执行命令：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo killall coreaudiod</div></pre></td></tr></table></figure><blockquote><p>有时候 Mac 从睡眠状态恢复之后没有声音，这是 Mac OS X 系统的一个 Bug。这是因为 Mac OS X 的核心音频守护进程「coreaudiod」出了问题，虽然简单的重启电脑就能解决，但是如果此时开启了很多程序后者有其他情况不想重启电脑的话，可以按照上面的方法解决此问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何覆盖equals方法</title>
      <link href="/JDK/equals.html"/>
      <url>/JDK/equals.html</url>
      
        <content type="html"><![CDATA[<p>如果在List中存放了一个对象，然后用contains方法判断该对象是否存在，contains方法返回了false，气不气！</p><a id="more"></a><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><ul><li>类具有自己特有的“逻辑相等”概念(不同于对象等同的概念)</li><li>超类没有覆盖equals以实现期望的行为</li></ul><blockquote><p>值类(value class)：仅仅表示一个值的类，例如Integer。</p><p>程序员在利用equals方法来比较值对象的引用时，希望知道它们在逻辑上是否相当，而不在意是否指向同一个对象。</p></blockquote><p>覆盖equal方法：可以满足程序员的要求，也可以把类的实例当作map的key，或者是set的元素。</p><blockquote><p>单例类、枚举类型不需要覆盖，逻辑相同与对象等同是一回事。</p></blockquote><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><h4 id="自反性reflexive"><a href="#自反性reflexive" class="headerlink" title="自反性reflexive"></a>自反性reflexive</h4><p><code>x != null</code> ， <code>x.equals(x)</code>：<code>true</code></p><h4 id="对称性symmetric"><a href="#对称性symmetric" class="headerlink" title="对称性symmetric"></a>对称性symmetric</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x!=<span class="keyword">null</span>,y!=<span class="keyword">null</span></div><div class="line">    <span class="keyword">if</span>(y.equals(x))&#123;</div><div class="line">        x.equals(y)：<span class="keyword">true</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="传递性transitive"><a href="#传递性transitive" class="headerlink" title="传递性transitive"></a>传递性transitive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">x!=<span class="keyword">null</span>,y!=<span class="keyword">null</span>,z!=<span class="keyword">null</span></div><div class="line">    <span class="keyword">if</span>(x.equals(y))&#123;</div><div class="line">        <span class="keyword">if</span>(y.equals(z))</div><div class="line">            x.equals(z)：<span class="keyword">true</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="一致性consistent"><a href="#一致性consistent" class="headerlink" title="一致性consistent"></a>一致性consistent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x!=<span class="keyword">null</span>,y!=<span class="keyword">null</span></div><div class="line">当equals比较时所用的信息没有被修改，多次调用x.equals(y)，返回值相同</div></pre></td></tr></table></figure><h4 id="x-null-，-x-quals-null-：-false"><a href="#x-null-，-x-quals-null-：-false" class="headerlink" title="x != null ， x.quals(null) ： false"></a><code>x != null</code> ， <code>x.quals(null)</code> ： <code>false</code></h4><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><h4 id="自反性"><a href="#自反性" class="headerlink" title="自反性"></a>自反性</h4><blockquote><p>把类的实例添加到集合中，该集合的contains方法将返回false</p></blockquote><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String s;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.s = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString) &#123;</div><div class="line">            <span class="keyword">return</span> s.equalsIgnoreCase(((CaseInsensitiveString) o).s);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String) &#123;</div><div class="line">            <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>String类中的equals方法不知道不区分大小写的字符串。如果将这两个对象都放在集合中，结果将不可预料，true? false? runtime exception?</p><p>需要将equals方法修改为下面的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> o <span class="keyword">instanceof</span> CaseInsensitiveString &amp;&amp;</div><div class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><blockquote><p>使用子类时，超类中如果新添加了一个属性，将会影响equals结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Point p = (Point) o;</div><div class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>ColorPoint没有实现equal方法，比较时，颜色信息将被忽略，不是所期望的结果。</p></blockquote><p>如果将ColorPoint中增加equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Point p = (Point) o;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>比较Point和ColorPoint，以及相反的情形时，可能会得到不同的结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"red"</span>);</div><div class="line">System.out.println(p.equals(cp));<span class="comment">//true</span></div><div class="line">System.out.println(cp.equals(p));<span class="comment">//false</span></div></pre></td></tr></table></figure><p>修改ColorPoint的equals方法，在进行父子类比较时，忽略颜色信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</div><div class="line">            <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color == color;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ok,对称性有保证了，但是却牺牲了传递性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"red"</span>);</div><div class="line">    Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">    ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"blue"</span>);</div><div class="line">    System.out.println(p1.equals(p2)); <span class="comment">//true,不考虑颜色</span></div><div class="line">    System.out.println(p2.equals(p3)); <span class="comment">//true,不考虑颜色</span></div><div class="line">    System.out.println(p1.equals(p3)); <span class="comment">//false,考虑颜色</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是面向对象语言中关于等价关系的一个基本问题。<strong>无法在扩展可实例化的类的同时，即增加新的属性，同时又保留equals约定。</strong></p><p>那尝试用<code>getClass</code>代替<code>instanceof</code>？可以扩展可实例化的类和增加新的属性，同时保留equals约定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;   </div><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || o.getClass() != getClass()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        Point p = (Point) o;</div><div class="line">        <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只有当对象具有相同的实现时，才能使对象等同。但是实际情况如何呢？</p><p>假设要编写一个方法，检验某个整值点是否处于单位圆中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Point&gt; unitCircle;</div><div class="line"></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    unitCircle = <span class="keyword">new</span> HashSet&lt;Point&gt;();</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point(-<span class="number">1</span>, <span class="number">0</span>));</div><div class="line">    unitCircle.add(<span class="keyword">new</span> Point(<span class="number">0</span>, -<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onUnitCircle</span><span class="params">(Point p)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> unitCircle.contains(p);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过不添加属性的方式扩展Point，判断创建的实例个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger COUNTER = <span class="keyword">new</span> AtomicInteger();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(x, y);</div><div class="line">        COUNTER.incrementAndGet();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberCreated</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> COUNTER.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>假设讲CounterPoint的实例传给了onUnitCircle方法。如果Point类使用了基于getClass的equals方法，无论CounterPoint实例的x和y值是什么，onUnitCircle方法都会返回false。因为在onUnitCircle方法所用的HashSet这样的集合，是利用equals方法检验包含条件，没有任何CounterPoint实例与任何Point对应。但是，如果在Point上使用适当的基于instanceof的equals方法，当遇到CounterPoint时，相同的onUnitCircle方法就会工作得很好。</p><blockquote><p><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="external">里氏替换原则Liskov subsitution principle</a>：一个类型的任何重要属性也将适用于它的子类型，因此为该类型编写的任何方法，在它的子类型上上也应该同样运行得很好。</p></blockquote><p>虽然没有一种令人满意的办法既可以扩展不可实例化的类，又增加属性，但有一种权宜之计：复合优先于继承。改造ColorPoint：取消扩展，增加Point属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String color;</div><div class="line">    <span class="keyword">private</span> Point point;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, String color)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(color)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        &#125;</div><div class="line">        Point point = <span class="keyword">new</span> Point(x, y);</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> point;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        ColorPoint cp = (ColorPoint) o;</div><div class="line">        <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在JDK中，有一些类扩展了可实例化的类，并添加了新的属性。例如<code>java.sql.Timestamp</code>对<code>java.util.Date</code>进行了扩展，并增加了<code>nanoseconds</code>属性。<code>Timestamp</code>的<code>equals</code>实现确实为了对称性，如果Timestamp和Date对象被用于同一个集合中，或者以其他方式被混合在一起，则会引起不正确的行为。Timestamp类有一个免责声明，告诫程序员不要混合使用Date和Timestamp对象。只要不混合使用，就不会有麻烦，除此之外没有其他的措施可以防止，导致的错误也很难调适。这种行为是错误的，不建议效仿。</p><hr><p><strong>用类层次代替标签类</strong></p><p>可以在一个抽象类的子类中增加新的值组件，而不会违反equals约定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</div><div class="line"></div><div class="line">    Circle(<span class="keyword">double</span> radius) &#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.PI * radius;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> length;</div><div class="line"></div><div class="line">    Rectangle(<span class="keyword">double</span> width, <span class="keyword">double</span> length) &#123;</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">        <span class="keyword">this</span>.length = length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> width * length;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>只要<code>Shape</code>类不能被实例化，则上述问题均不可能发生。</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>在写一个类的时候，应该仔细考虑它是否是不可变的。如果认为它应该是不可变的，就必须保证equals方法满足：相等的对象永远相等，不想等的对象永远不想等。</p><p><strong>无论类是否可变，都不要使equals方法依赖于不可靠的资源</strong></p><p>equals方法都应该对驻留在内存中的对象执行确定性的计算。</p><p><code>java.net.URL</code>的<code>equals</code>方法依赖于对URL中主机IP地址的比较。但IP是会变化的，会导致一些问题，但因为兼容性的考虑，equal方法无法被改变。</p><h4 id="非空性"><a href="#非空性" class="headerlink" title="非空性"></a>非空性</h4><p>很难想象什么场景下<code>o.equals(null)</code>会返回<code>true</code>，但抛出PNE异常倒是有可能，通常约定equals方法不抛出NPE异常，很多类会进行一个显式的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(o == <span class="keyword">null</span>)&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其实这是没有必要的，在进行判断之前，会将参数转换为适当的类型，以调用它的访问方法或访问其属性。在转换之前，equals方法必须使用instanceof操作符，检查参数是否为正确的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Rectangle)) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line">Rectangle myType = (Rectangle) obj;</div></pre></td></tr></table></figure><p>如果漏掉这步检查，参数又为错误的类型，则会抛出<code>ClassCastException</code>异常，这就违反了equals的约定。但是如果instanceof的第一个操作数为null，那么会返回<a href="https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.20.2" target="_blank" rel="external">指定的false</a>。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>输出是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.out.println(Float.NaN == Float.NaN);</div><div class="line">System.out.println(Float.compare(Float.NaN, Float.NaN));</div><div class="line">System.out.println(+<span class="number">0.0f</span> == -<span class="number">0.0f</span>);</div><div class="line">System.out.println(Float.compare(+<span class="number">0.0f</span> , -<span class="number">0.0f</span>));</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">false</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure><blockquote><p>根据IEEE 754浮点“单一格式”位布局返回指定浮点值的表示形式，保留非数字（NaN）值。<br>位31（由掩码0x80000000选择的位）表示浮点数的符号。</p><p>位30-23（由掩码0x7f800000选择的位）表示指数。</p><p>位22-0（由掩码0x007fffff选择的位）表示浮点数的有效数（有时称为尾数）。<br>如果参数为正无穷大，则结果为0x7f800000。1111111100000000000000000000000<br>如果参数为负无穷大，则结果为0xff800000。</p><p>11111111100000000000000000000000</p><p>如果参数是NaN，则结果是表示实际NaN值的整数。</p><p>与floatToIntBits方法不同，floatToRawIntBits不会将编码NaN的所有位模式折叠为单个“规范”NaN值。<br>在所有情况下，结果都是一个整数，当赋予intBitsToFloat（int）方法时，它将生成一个与floatToRawIntBits的参数相同的浮点值。</p></blockquote><h3 id="诀窍"><a href="#诀窍" class="headerlink" title="诀窍"></a>诀窍</h3><ul><li>使用<code>==</code>操作符检查”参数是否为这个对象的引用”。</li><li>使用<code>instanceof</code>操作符检查”参数是否为正确类型”。<ul><li>一般情况下，正确类型为equals方法所在类</li><li>如果是接口，允许在实现了该接口的类之间比较，那么久使用接口(比如Set、List)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//java.util.AbstractList</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (o == <span class="keyword">this</span>)</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> List))</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>把参数转换为正确的类型(已经通过instanceof判断)</li><li><p>对于该类中的每个关键属性，检查参数中的属性是否与该对象中对应的属性匹配。</p><ul><li>非float、非double的基本类型：==</li><li>对象的引用属性：递归调用equals</li><li>float：Float.compare<ul><li>存在：Float.Nan、-0.0f、+0.0f</li></ul></li><li>double：Double.compare</li><li>数组<ul><li>按照上述原则逐个元素比较</li><li>Arrays.equals</li></ul></li><li>元素中含<code>null</code><ul><li>(field == null ? o.field == null : field.equals(o.field))</li><li>如果两个field是相同的对象引用<ul><li>(field == o.field || (field != null &amp;&amp; field.equals(o.field)))</li></ul></li></ul></li><li>定制化的类(例如忽略大小写)<ul><li>合理覆盖equals</li></ul></li></ul></li><li><p>先比较最有可能不一致的属性，或者是开销最低的属性</p></li><li>覆盖equals方法后，通过单元测试检查是否符合对称性、传递性、一致性、自反性和非空性</li></ul><h3 id="告诫"><a href="#告诫" class="headerlink" title="告诫"></a>告诫</h3><ul><li>覆盖equals时总要覆盖hashCode</li><li>不要企图让equals方法过于智能<ul><li>不要过度的寻求各种等价关系，比如不应该把File类指向同一个文件的符号链接当作相等的对象来看待</li></ul></li><li>不要将equals方法的参数类型Object替换为其他类型<ul><li>替换为其他类型就没有重写equals方法而是重载，相当于在Object类型外提供一个强类型的equals方法，除非这两个方法返回结果是一致的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas入门</title>
      <link href="/Java/arthas.html"/>
      <url>/Java/arthas.html</url>
      
        <content type="html"><![CDATA[<p>Alibaba开源的Java诊断工具</p><a id="more"></a><p><strong>1.支持管道操作;2.<code>-h</code>查看帮助;3.<code>tab</code>自动补全;4.keymap查看快捷键;5.方向键上和下查看历史命令，或通过history命令</strong></p><p>1.启动需要监测的应用程序</p><p>2.启动arthas，attach到自己的程序上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</div><div class="line"><span class="meta">#</span>阿里云镜像地址</div><div class="line">java -jar arthas-boot.jar --repo-mirror aliyun --use-http</div></pre></td></tr></table></figure><p>3.输入序号,回车。attach成功后，会打印Logo</p><hr><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><code>dashboard</code>：查看当前系统的实时数据面板</p><p><code>thread</code>：打印线程栈信息<code>thread [id]</code></p><p><code>jad</code>：反编译代码<code>jad demo.MathGame</code></p><p><code>watch</code>：查看函数的参数/返回值/异常信息<code>watch demo.MathGame primeFactors returnObj</code></p><p><code>sc</code>：查找JVM里已加载的类<code>sc -d *MathGame</code></p><p><code>exit</code>或<code>quit</code>：退出当前session</p><p><code>shutdown</code>：停止程序</p><p><code>resert</code>：清除增强代码(Arthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。)</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>--target-ip</code>：允许外部访问</p><p><code>--versions</code>：列出所有版本</p><p><code>--use-version  3.1.0</code>：使用指定版本</p><p><code>telnet-port 9999 --http-port -1</code>：只监听Telnet端口，不监听HTTP端口</p><p><code>-v</code>：打印运行详情</p><h3 id="查看JVM信息"><a href="#查看JVM信息" class="headerlink" title="查看JVM信息"></a>查看JVM信息</h3><h4 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h4><blockquote><p>打印所有的System Properties信息</p></blockquote><p>也可以指定单个key： <code>sysprop java.version</code></p><p>也可以通过<code>grep</code>来过滤： <code>sysprop | grep user</code></p><p>可以设置新的value： <code>sysprop testKey testValue</code></p><h4 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h4><p><code>sysenv</code> 命令可以获取到环境变量。和<code>sysprop</code>命令类似。</p><h4 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h4><p><code>jvm</code> 命令会打印出<code>JVM</code>的各种详细信息。</p><h4 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h4><p><code>dashboard</code> 命令可以查看当前系统的实时数据面板。</p><p>输入 <code>Q</code> 或者 <code>Ctrl+C</code> 可以退出dashboard命令。</p><h3 id="sc-sm-查看已加载的类"><a href="#sc-sm-查看已加载的类" class="headerlink" title="sc/sm 查看已加载的类"></a>sc/sm 查看已加载的类</h3><h4 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h4><p><code>sc</code> 命令可以查找到所有JVM已经加载到的类。</p><p>如果搜索的是接口，还会搜索所有的实现类。比如查看所有的<code>Filter</code>实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc javax.servlet.Filter</div></pre></td></tr></table></figure><p>通过<code>-d</code>参数，可以打印出类加载的具体信息，很方便查找类加载问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc -d javax.servlet.Filter</div></pre></td></tr></table></figure><p><code>sc</code>支持通配，比如搜索所有的<code>StringUtils</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sc *StringUtils</div></pre></td></tr></table></figure><h4 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h4><p><code>sm</code>命令则是查找类的具体函数。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sm java.math.RoundingMode</div></pre></td></tr></table></figure><p>通过<code>-d</code>参数可以打印函数的具体属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sm -d java.math.RoundingMode</div></pre></td></tr></table></figure><p>也可以查找特定的函数，比如查找构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sm java.math.RoundingMode &lt;init&gt;</div></pre></td></tr></table></figure><h3 id="Jad"><a href="#Jad" class="headerlink" title="Jad"></a>Jad</h3><p>可以通过 <code>jad</code> 命令来反编译代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad com.example.demo.arthas.user.UserController</div></pre></td></tr></table></figure><p>通过<code>--source-only</code>参数可以只打印出在反编译的源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jad --source-only com.example.demo.arthas.user.UserController</div></pre></td></tr></table></figure><h3 id="Ognl"><a href="#Ognl" class="headerlink" title="Ognl"></a>Ognl</h3><p>在Arthas里，有一个单独的<code>ognl</code>命令，可以动态执行代码。</p><h4 id="调用static函数"><a href="#调用static函数" class="headerlink" title="调用static函数"></a>调用static函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ognl &apos;@java.lang.System@out.println(&quot;hello ognl&quot;)&apos;</div></pre></td></tr></table></figure><h4 id="获取静态类的静态字段"><a href="#获取静态类的静态字段" class="headerlink" title="获取静态类的静态字段"></a>获取静态类的静态字段</h4><p>获取<code>UserController</code>类里的<code>logger</code>字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ognl -c 1be6f5c3 @com.example.demo.arthas.user.UserController@logger</div></pre></td></tr></table></figure><p>还可以通过<code>-x</code>参数控制返回值的展开层数。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ognl -c 1be6f5c3 -x 2 @com.example.demo.arthas.user.UserController@logger</div></pre></td></tr></table></figure><h4 id="执行多行表达式，赋值给临时变量，返回一个List"><a href="#执行多行表达式，赋值给临时变量，返回一个List" class="headerlink" title="执行多行表达式，赋值给临时变量，返回一个List"></a>执行多行表达式，赋值给临时变量，返回一个List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ognl &apos;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&apos;</div><div class="line">$ ognl &apos;#value1=@System@getProperty(&quot;java.home&quot;), #value2=@System@getProperty(&quot;java.runtime.name&quot;), &#123;#value1, #value2&#125;&apos;</div><div class="line">@ArrayList[</div><div class="line">    @String[/Library/Java/JavaVirtualMachines/jdk1.8.0_162.jdk/Contents/Home/jre],</div><div class="line">    @String[Java(TM) SE Runtime Environment],</div><div class="line">]</div></pre></td></tr></table></figure><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>在Arthas里<code>ognl</code>表达式是很重要的功能，在很多命令里都可以使用<code>ognl</code>表达式。</p><p>一些更复杂的用法，可以参考：</p><ul><li>OGNL特殊用法请参考：<a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="external">https://github.com/alibaba/arthas/issues/71</a></li><li>OGNL表达式官方指南：<a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="external">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li></ul><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><p>但是trace只能追踪一层的调用链路，如果一层的链路信息不够用，可以把该链路上有问题的方法再次进行trace。<br>trace使用例子如下。</p><p><code>trace demo.MathGame primeFactors</code></p><h3 id="tt"><a href="#tt" class="headerlink" title="tt"></a>tt</h3><p>录制、回放请求。有时候排查一个问题需要上游再次调用这个方法，比如使用postMan等工具，当然Arthas提供了一个命令让替代来回手动请求。</p><p>录制：<code>tt -t demo.MathGame primeFactors</code></p><p>回放：<code>tt -i 1004 -p</code></p><p>注意重放请求需要关注两点:</p><ul><li>ThreadLocal 信息丢失:由于使用的是Arthas线程调用，会让threadLocal信息丢失，比如一些TraceId信息可能会丢失</li><li>引用的对象:保存的入参是保存的引用，而不是拷贝，所以如果参数中的内容被修改，那么入参其实也是被修改的。</li></ul><h3 id="查看调用"><a href="#查看调用" class="headerlink" title="查看调用"></a>查看调用</h3><p>有时候有些方法非常耗时或者非常重要，需要知道到底是谁发起的调用，比如System.gc(),有时候如果发现fullgc频繁是因为System.gc()引起的，需要查看到底是什么应用调用的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">options unsafe true</div><div class="line">stack java.lang.System gc</div></pre></td></tr></table></figure><p>首先输入options unsafe true允许对jdk增强，然后对System.gc进行进行监视，然后记录当前的堆栈来获取是什么位置进行的调用。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>watch com.xxx.UserController * &#39;{params,throwExp} -x 2</code></p><p>结构：watch 类名 函数名 返回值表达式  展开结果</p><p><a href="https://alibaba.github.io/arthas/advice-class.html" target="_blank" rel="external">返回值表达式</a>可选值如下：</p><ul><li>loader</li><li>clazz</li><li>method</li><li>target</li><li>params</li><li>returnObj</li><li>throwExp</li><li>isBefore</li><li>isThrow</li><li>isReturn</li></ul><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>当第一个参数大于100时才打印结果</p><p><code>watch com.example.demo.arthas.user.UserController * returnObj &#39;params[0] &gt; 100</code></p><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p><code>watch</code>命令支持<code>-e</code>选项，表示只捕获抛出异常时的请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch com.example.demo.arthas.user.UserController * &quot;&#123;params[0],throwExp&#125;&quot; -e</div></pre></td></tr></table></figure><h4 id="按照耗时进行过滤"><a href="#按照耗时进行过滤" class="headerlink" title="按照耗时进行过滤"></a>按照耗时进行过滤</h4><p><code>watch</code>命令支持按请求耗时进行过滤，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">watch com.example.demo.arthas.user.UserController * &apos;&#123;params, returnObj&#125;&apos; &apos;#cost&gt;200&apos;</div></pre></td></tr></table></figure><h3 id="热更新代码"><a href="#热更新代码" class="headerlink" title="热更新代码"></a>热更新代码</h3><p>保存反编译文件</p><p><code>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</code></p><p>查找ClassLoader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sc -d *UserController | grep classLoaderHash</div><div class="line">classLoaderHash   1be6f5c3</div></pre></td></tr></table></figure><p>修改反编译文件后，重新编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</div><div class="line">Memory compiler output:</div><div class="line">/tmp/com/example/demo/arthas/user/UserController.class</div><div class="line">Affect(row-cnt:1) cost in 346 ms</div></pre></td></tr></table></figure><p>重新加载新编译后的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redefine /tmp/com/example/demo/arthas/user/UserController.class</div><div class="line">redefine success, size: 1</div></pre></td></tr></table></figure><h3 id="动态更新日志级别"><a href="#动态更新日志级别" class="headerlink" title="动态更新日志级别"></a>动态更新日志级别</h3><p>查找ClassLoader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sc -d com.example.demo.arthas.user.UserController | grep classLoaderHash</div><div class="line">classLoaderHash   1be6f5c3</div></pre></td></tr></table></figure><p>用ognl获取logger</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger'</div><div class="line">@Logger[</div><div class="line">    serialVersionUID=@Long[5454405123156820674],</div><div class="line">    FQCN=@String[ch.qos.logback.classic.Logger],</div><div class="line">    name=@String[com.example.demo.arthas.user.UserController],</div><div class="line">    level=null,</div><div class="line">    effectiveLevelInt=@Integer[20000],</div><div class="line">    parent=@Logger[Logger[com.example.demo.arthas.user]],</div><div class="line">    childrenList=null,</div><div class="line">    aai=null,</div><div class="line">    additive=@Boolean[true],</div><div class="line">    loggerContext=@LoggerContext[ch.qos.logback.classic.LoggerContext[default]],</div><div class="line">]</div></pre></td></tr></table></figure><p>可以通过loggerContext看出来使用的是logback，并且通过level看出来没有设置级别</p><p>单独设置某类的级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ognl -c 1be6f5c3 '@com.example.demo.arthas.user.UserController@logger.setLevel(@ch.qos.logback.classic.Level@DEBUG)'</div></pre></td></tr></table></figure><p>修改全局日志级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ognl -c 1be6f5c3 '@org.slf4j.LoggerFactory@getLogger("root").setLevel(@ch.qos.logback.classic.Level@DEBUG)'</div></pre></td></tr></table></figure><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="查看所有线程信息"><a href="#查看所有线程信息" class="headerlink" title="查看所有线程信息"></a>查看所有线程信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread</div></pre></td></tr></table></figure><h4 id="查看具体线程的栈"><a href="#查看具体线程的栈" class="headerlink" title="查看具体线程的栈"></a>查看具体线程的栈</h4><p>查看线程ID 16的栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread 16</div></pre></td></tr></table></figure><h4 id="查看CPU使用率top-n线程的栈"><a href="#查看CPU使用率top-n线程的栈" class="headerlink" title="查看CPU使用率top n线程的栈"></a>查看CPU使用率top n线程的栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread -n 3</div></pre></td></tr></table></figure><p>查看5秒内的CPU使用率top n线程栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread -n 3 -i 5000</div></pre></td></tr></table></figure><h4 id="查找线程是否有阻塞"><a href="#查找线程是否有阻塞" class="headerlink" title="查找线程是否有阻塞"></a>查找线程是否有阻塞</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread -b</div></pre></td></tr></table></figure><h3 id="Web-Console"><a href="#Web-Console" class="headerlink" title="Web Console"></a>Web Console</h3><p>通过Web Socket访问Arthas：<code>http://localhost:8563</code></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h4><p>主要信息，通过Class获取：<code>Test.class.isInterface()</code></p><p>加载信息，通过CodeSource获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CodeSource codeSource = Test.class.getProtectionDomain().getCodeSource();</div><div class="line">codeSource.getLocation().getFile();</div></pre></td></tr></table></figure><h4 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h4><p>使用的是<a href="http://www.benf.org/other/cfr/" target="_blank" rel="external">cfr</a>提供的jar包来进行反编译</p><h4 id="修改日志级别"><a href="#修改日志级别" class="headerlink" title="修改日志级别"></a>修改日志级别</h4><p>具体原理是首先获取AppClassLoader(默认)或者指定的ClassLoader，然后再调用Ognl的包，自动执行解析这个表达式，而这个执行的类都会从前面的ClassLoader中获取中去获取。</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>利用jdk1.6的instrument + ASM 记录方法的入参出参，以及方法消耗时间。</p><h4 id="trace-1"><a href="#trace-1" class="headerlink" title="trace"></a>trace</h4><p>利用jdk1.6的instrument + ASM。在访问方法之前和之后会进行记录</p><h3 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h3><p><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics" target="_blank" rel="external">Arthas Tutorials</a></p><p><a href="https://alibaba.github.io/arthas/commands.html" target="_blank" rel="external">Arthas命令</a></p><p><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="external">Katacoda在线学习</a></p><p><a href="https://mp.weixin.qq.com/s/wG51oUqVPObACqvZA9ItOg" target="_blank" rel="external">Arthas&amp;jvm-sandbox对比</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> monitor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合遍历</title>
      <link href="/JDK/Traversal.html"/>
      <url>/JDK/Traversal.html</url>
      
        <content type="html"><![CDATA[<p>有多少人和别人借过钱？</p><ul><li>我现在只有10块，都给你吧</li><li>走，跟我去银行，只要有，我会都给你</li></ul><p>期待哪个答案？</p><a id="more"></a><p>相信大多数人都会选择去银行，这也就是此次分享的主题。分享之前，先来看过去是怎么做的。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><p>作为Java程序员，集合类肯定不陌生，日常工作比较常用<code>ArrayList</code>、<code>HashSet</code>等。</p><p>当遍历集合时，一般会怎么写呢？</p><ul><li>遍历数组，通过索引</li></ul><p><code>for(int i=0; i&lt;array.size(); i++) { ... get(i) ... }</code></p><ul><li>遍历链表必须通过while</li></ul><p><code>while((e=e.next())!=null) { ... e.data() ... }</code></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>必须知道集合的内部结构</li><li>访问代码和集合是紧耦合</li><li>无法复用代码</li><li>集合类型改变，相应代码需全部重写</li></ul><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><blockquote><p>假设需要计算100以内多少个数是以0结尾，可以使用List或者Iterator。都需要将所有的数字处理一次，才可以得出最终结果。但是，如果需要计算<code>Integer.MAX_VALUE</code>以内或者无穷大的数字呢？</p></blockquote><ul><li>使用Collection方式，首先需要将所有数字都加载进内存，再通过显式遍历，计算所有元素后得出最终结果</li><li>使用Iterator方式，将迭代器返回，使用方通过<code>hasNext()</code>方式来判断是否需要执行下一次计算，如果需要执行，通过next()方法获取到下一个元素，计算。</li></ul><p>可以看出，首先在内存使用上，Iterator无需知道集合到底有多少个数据，也无需将集合中所有元素都放进集合中才可以返回给使用方，集合的填充和使用可以是异步进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger ATOMIC_INTEGER = <span class="keyword">new</span> AtomicInteger();    </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">       <span class="keyword">while</span> (creator().hasNext()) &#123;</div><div class="line">           Integer next = creator().next();</div><div class="line">           System.out.println(<span class="string">"consumer :"</span> + next);</div><div class="line">           <span class="keyword">if</span> (next % <span class="number">10</span> == <span class="number">0</span>) &#123;</div><div class="line">               System.out.println(<span class="string">"The Element % 10 = 0 : "</span> + next);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Iterator&lt;Integer&gt; <span class="title">creator</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Integer&gt;() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">return</span> ATOMIC_INTEGER.intValue() &lt; Integer.MAX_VALUE;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">               System.out.println(<span class="string">"producer :"</span> + ATOMIC_INTEGER.get());</div><div class="line">               <span class="keyword">return</span> ATOMIC_INTEGER.incrementAndGet();</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p><strong>问题1：为啥可以返回元素类型是Integer的迭代器呢?</strong></p><p><code>OfDouble</code>、<code>OfInt</code>、<code>OfLong</code>三个接口继承自<code>PrimitiveIterator</code>，它又继承自<code>Iterator</code>。</p><p>各自<code>Override</code>了<code>next()</code>。这个接口使用了JDK 1.8的新特性：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" target="_blank" rel="external">Consumer</a>，有兴趣的同学可以自己研究。</p><p><strong>问题2:那又为啥集合类也可以返回<code>Iterator</code>呢?</strong></p><h3 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h3><p>查看这些常用集合类的源码时，可以看出，都继承自<code>Collection</code>接口，而<code>Collection</code>接口继承自为<code>Iterable</code>。</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1g12gmykxu4j20pi0ramyb.jpg" alt=""></p><p>查看Guava的<code>Iterables</code>帮助文档时，开头第一句话：</p><blockquote><p>Whenever possible, Guava prefers to provide utilities accepting an <code>Iterable</code> rather than a <code>Collection</code>. </p></blockquote><p>为什么呢？</p><blockquote><p>Here at Google, it’s not out of the ordinary to encounter a “collection” that isn’t actually stored in main memory, but is being gathered from a database, or from another data center, and can’t support operations like <code>size()</code> without actually grabbing all of the elements.</p></blockquote><p>谷歌如此大力提倡<code>Iterable</code>，来看一下它的源码，其中包含一个<code>iterator()</code>方法，返回<code>iterator&lt;T&gt;</code>。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1g12gmymy0jj20xs0gg0v9.jpg" alt=""></p><p><strong>问题3:<code>Iterator</code>是什么?</strong></p><blockquote><p>Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。</p><p>方法：next()、hasNext()、remove()</p><ul><li>每一个集合返回的Iterator对象都是从头开始的，相互独立的。</li></ul></blockquote><p>也就是说，所有继承自<code>Collection</code>接口的集合类，都可以使用<code>Iterator</code>，那么它是如何遍历的呢？</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1g12gmykecmj20lk09e3ze.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</div><div class="line"><span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>优点<ul><li>无需关心数据类型</li><li>无需关心内部结构<ul><li>不同类型都有相应的Iterator实现类:<code>ArraryIterator</code>、<code>SetIterator</code>、<code>TreeIterator</code></li></ul></li><li>不维护遍历集合的索引</li><li>代码清爽</li><li>返回的Iterables的方法返回结果是延迟计算的，并不是把所有数据都加载到内存中</li><li>短路<ul><li>拿到当前元素，执行对应操作</li><li>判断集合中一部分数据就可以完成操作，不需要计算所有集合数据</li></ul></li></ul></li></ul><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><blockquote><p>持有一个集合A，要和数据库中的数据B进行对比。</p></blockquote><p>首先以A为基准，B中的数据有两种结果：存在(与A一致、与A不一致)、不存在。再将B中存在，A中不存在的数据标记。</p><p>如果直接使用<code>select * from table</code>，并不能确定数据库中究竟有多少数据，是一条还是一百万条。其次，内存可以一次性加载这么多的数据吗？假设都满足，这么大的计算量，会导致服务器资源占用过高，影响其它业务的处理能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StartLimitQueryTemplate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 单次分页查询</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> limit</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> limit)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.google.common.base.Preconditions;</div><div class="line"><span class="keyword">import</span> com.google.common.collect.AbstractIterator;</div><div class="line"><span class="keyword">import</span> org.apache.commons.collections4.CollectionUtils;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterables2</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Iterable&lt;List&lt;T&gt;&gt; split(<span class="keyword">final</span> StartLimitQueryTemplate&lt;T&gt; template, <span class="keyword">final</span> <span class="keyword">int</span> limit) &#123;</div><div class="line">        Preconditions.checkNotNull(template);</div><div class="line">        Preconditions.checkArgument(limit &gt; <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> AbstractIterator&lt;List&lt;T&gt;&gt;() &#123;</div><div class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">            <span class="keyword">boolean</span> endFlag = <span class="keyword">false</span>;</div><div class="line"> </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> List&lt;T&gt; <span class="title">computeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (endFlag) &#123;</div><div class="line">                    <span class="keyword">return</span> endOfData();</div><div class="line">                &#125;</div><div class="line">                List&lt;T&gt; queryResult = template.query(start, limit);</div><div class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(queryResult)) &#123;</div><div class="line">                    <span class="keyword">return</span> endOfData();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (queryResult.size() &lt; limit) &#123;</div><div class="line">                    endFlag = <span class="keyword">true</span>;</div><div class="line">                    <span class="keyword">return</span> queryResult;</div><div class="line">                &#125;</div><div class="line">                start = start + limit;</div><div class="line">                <span class="keyword">return</span> queryResult;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Iterable&lt;T&gt; <span class="title">flatIterable</span><span class="params">(<span class="keyword">final</span> Iterator&lt;? extends Iterable&lt;T&gt;&gt; iterators)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterable&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> AbstractIterator&lt;T&gt;() &#123;</div><div class="line">                    Iterator&lt;? extends Iterable&lt;T&gt;&gt; outIterable = iterators;</div><div class="line">                    Iterator&lt;T&gt; innerIterable = <span class="keyword">null</span>;</div><div class="line"> </div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">protected</span> T <span class="title">computeNext</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (innerIterable == <span class="keyword">null</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (!outIterable.hasNext()) &#123;</div><div class="line">                                <span class="keyword">return</span> endOfData();</div><div class="line">                            &#125;</div><div class="line">                            innerIterable = outIterable.next().iterator();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (innerIterable.hasNext()) &#123;</div><div class="line">                            <span class="keyword">return</span> iterator().next();</div><div class="line">                        &#125;</div><div class="line">                        innerIterable = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">return</span> computeNext();</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Collection为什么不实现Iterator接口"><a href="#Collection为什么不实现Iterator接口" class="headerlink" title="Collection为什么不实现Iterator接口"></a>Collection为什么不实现Iterator接口</h3><p>从<code>Iterator</code>的源码中可以得知，Iterator维护了访问集合时的内部状态，换句话说，依赖于迭代器的当前迭代位置的，如果Collection实现Iterator接口，也就需要集合内维护遍历元素时的指针等信息。当集合在不同方法中被传递时，由于当前迭代位置不可预置，那么next()方法的结果会变成不可预知。 除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。<br>但即使这样，Collection也只能同时存在一个当前迭代位置，会有多线程问题。而Iterable则不然，每次调用都会返回一个从头开始计数的迭代器。 多个迭代器是互不干扰的。</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>上图中隐藏了一个细节，<code>AbstractList</code>和<code>AbstractSet</code>。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1g12gmyqmy3j20rk0r4abk.jpg" alt=""></p><p>为什么都会有一个以<code>Abstract</code>开头的类呢？</p><p>假设开发一个接口，其中有10个方法，那使用方再实现接口的时候需要将10个方法都实现，否则就需要将类声明为<code>abstract</code>。是不是很麻烦！还会想实现它吗！有那功夫都自己写一个了好不好。所以，JDK的开发人员，提供了一系列以<code>Abstrat</code>开头的类，将对应接口的核心功能提供默认实现的版本，目的就是为了如果使用方有定制化的需求时，可以通过继承抽象类以最大程度减少工作量，只需要开发定制化功能。</p><h4 id="抽象类的特性"><a href="#抽象类的特性" class="headerlink" title="抽象类的特性"></a>抽象类的特性</h4><ul><li>抽象方法可有可无</li><li>不能被实例化</li><li>子类可以通过继承来使用</li></ul><h4 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h4><ul><li>相同点<ul><li>不能实例化</li><li>方法可以实现，也可以不实现<ul><li>接口可以通过 <code>default</code>提供默认实现</li></ul></li></ul></li><li>不同点<ul><li>字段<ul><li>抽象类可以定义非<code>static</code>、<code>final</code> 的字段</li><li>接口字段默认为<code>public static final</code></li></ul></li><li>方法<ul><li>抽象类：可以定义<code>public</code>、<code>protected</code>和<code>private</code>的具体方法</li><li>接口：只有<code>public</code></li></ul></li><li>子类<ul><li>可以继承一个类，无论是不是抽象类</li><li>可以实现多个接口</li></ul></li></ul></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>抽象类<ul><li>希望在几个密切相关的类之间复用代码</li><li>希望扩展抽象类的类具有许多常用方法或字段，或者需要除公共之外的访问修饰符（例如protected和private）</li><li>想声明非<code>static</code>、<code>final</code>字段。可以定义访问和修改它们所属对象的状态的方法</li></ul></li><li>接口<ul><li>不相关的类可以实现，例如<code>Compareble</code>、<code>Cloneable</code>和<code>Serializable</code>，被很多类实现</li><li>希望限定特定数据类型的行为，但不关心谁实现其行为</li><li>希望利用类型的多重继承</li></ul></li></ul><p><strong>问题4:Java 8接口有default method后是不是可以放弃抽象类了？</strong></p><blockquote><p>Java 8的接口上的default method最初的设计目的是让已经存在的接口可以演化——添加新方法而不需要原本已经存在的实现该接口的类做任何改变（甚至不需要重新编译）就可以使用该新版本的接口。</p><p>以Java的 java.util.List接口为例，它在Java SE 7的时候还没有sort()方法，而到Java SE 8的时候添加了这个方法。那么如果我以前在Java SE 7的时候写了个类 MyList 实现了 List<t> 接口，我当时是不需要实现这个 sort() 方法的；当我升级到JDK8的时候，突然发现接口上多了个方法，于是 MyList 类就也得实现这个方法并且重新编译才可以继续使用了，对不对？<br>所以就有了default method。上述 List.sort() 方法在Java SE 8里就是一个default method，它在接口上提供了默认实现，于是 MyList 即便不提供sort()的实现，也会自动从接口上继承到默认的实现，于是MyList不必重新编译也可以继续在Java SE 8使用。</t></p><p>确实，从Java SE 8的设计主题来看，default method是为了配合JDK标准库的函数式风格而设计的。通过default method，很多JDK里原有的接口都添加了新的可以接收Functional Interface参数的方法，使它们更便于以函数式风格使用</p><p>Java 8的接口，即便有了default method，还暂时无法完全替代抽象类。它不能拥有状态，只能提供公有虚方法的默认实现。Java 9的接口已经可以有非公有的静态方法了。未来的Java版本的接口可能会有更强的功能，或许能更大程度地替代原本需要使用抽象类的场景。</p></blockquote><p><strong>函数式编程：无副作用、无状态</strong></p><p>提到了Java8，就不得不说跟Iterator有很大相似性的Stream。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>不存储数据<ul><li>流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。</li></ul></li><li>函数式编程<ul><li>流的操作不会修改数据源，例如<code>filter</code>不会将数据源中的数据删除。</li></ul></li><li>延迟操作<ul><li>中间操作是延迟执行，只有到终端操作才执行</li></ul></li><li>短路<ul><li>对于无限数量的流，有些操作可以在有限时间完成<ul><li><code>limit(n)</code>、<code>findFirst()</code></li></ul></li></ul></li><li>纯消费<ul><li>流的元素只能访问一次，如果想重新访问流的元素，需要生成一个新的流</li></ul></li></ul><h3 id="与Iterator区别"><a href="#与Iterator区别" class="headerlink" title="与Iterator区别"></a>与Iterator区别</h3><table><thead><tr><th></th><th>Iterator</th><th>Stream</th></tr></thead><tbody><tr><td>迭代方式</td><td>外部迭代</td><td>内部迭代</td></tr><tr><td>使用次数</td><td>多次</td><td>一次(再次使用会报错：<code>java.lang.IllegalStateException: stream has already been operated upon or closed</code>)</td></tr><tr><td>执行顺序</td><td>元素顺序</td><td>串行、并行</td></tr><tr><td>性能优化</td><td>无</td><td>类库</td></tr></tbody></table><blockquote><p><strong>外部迭代</strong>：</p><ul><li>例如Iterator、for，显示进行迭代操作</li><li>元素访问由外部迭代器进行控制</li><li>串行，依赖元素存储顺序</li><li>无法优化控制流，以达到改善性能的目的</li></ul><p><strong>内部迭代</strong>：</p><ul><li>Collection.forEach、Stream，隐式进行迭代操作</li><li>无法获得当前元素下标</li><li>只需关心对当前元素的操作(Consumer)</li><li>流式处理(类库对其进行性能优化)、代码清晰</li></ul></blockquote><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>Stream<ul><li>需要对大数据集的所有元素进行计算</li><li>不关心怎么做，只关心做什么<ul><li>希望以这种方式处理每个元素</li></ul></li><li>复杂计算代码整洁度、可读性更高(写代码需要注意性能)</li></ul></li><li>Iterator<ul><li>短路操作</li><li>希望以这种方式处理一个接一个的元素</li></ul></li></ul><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><ul><li>使用<code>StreamSupport</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; sourceIterator = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).iterator();</div><div class="line">Stream&lt;String&gt; targetStream = StreamSupport.stream(</div><div class="line">          Spliterators.spliteratorUnknownSize(sourceIterator, Spliterator.ORDERED),</div><div class="line">          <span class="keyword">false</span>);</div></pre></td></tr></table></figure><ul><li>使用<code>Iterable</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Iterator&lt;String&gt; sourceIterator = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>).iterator();</div><div class="line">Iterable&lt;String&gt; iterable = () -&gt; sourceIterator;</div><div class="line">Stream&lt;String&gt; targetStream = StreamSupport.stream(iterable.spliterator(), <span class="keyword">false</span>);</div><div class="line"><span class="comment">//()-&gt;sourceIterator</span></div><div class="line"><span class="comment">//new Iterable&lt;&gt;() &#123; @Override public Iterator&lt;String&gt; iterator() &#123; return sourceIterator; &#125; &#125;</span></div></pre></td></tr></table></figure><h3 id="与Collection"><a href="#与Collection" class="headerlink" title="与Collection"></a>与Collection</h3><table><thead><tr><th></th><th>Collections</th><th>Stream</th></tr></thead><tbody><tr><td>侧重点</td><td>存储、访问和有效管理</td><td>元素计算</td></tr><tr><td>是否影响原集合数据</td><td>影响</td><td>不影响(返回持有结果的新Stream)</td></tr><tr><td>执行操作</td><td>急性</td><td>惰性</td></tr><tr><td>元素数量</td><td>有限</td><td>有限、无限</td></tr></tbody></table><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p><a href="https://www.jetbrains.com/help/idea/analyze-java-stream-operations.html" target="_blank" rel="external">Analyze Java Stream operations</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/20129762/why-does-streamt-not-implement-iterablet" target="_blank" rel="external">Why does Stream not implement Iterable?</a></li><li><a href="https://github.com/google/guava/wiki/CollectionUtilitiesExplained#iterables" target="_blank" rel="external">CollectionUtilitiesExplained</a></li><li><a href="https://github.com/google/guava/wiki/CollectionHelpersExplained" target="_blank" rel="external">CollectionHelpersExplained</a></li><li><a href="https://stackoverflow.com/questions/5159000/stream-vs-views-vs-iterators" target="_blank" rel="external">Stream vs Views vs Iterators</a></li><li><a href="https://stackoverflow.com/questions/48846529/java-streams-vs-iterators" target="_blank" rel="external">Java streams vs Iterators</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" target="_blank" rel="external">Oracle Tutorials - Abstract</a></li><li><a href="https://www.zhihu.com/question/41166418" target="_blank" rel="external">Java 8接口有default method后是不是可以放弃抽象类了？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句优化-原因</title>
      <link href="/MySQL/reason.html"/>
      <url>/MySQL/reason.html</url>
      
        <content type="html"><![CDATA[<p>知其然更知其所以然</p><a id="more"></a><p>Q：为什么不能在频繁新增修改的列建立索引?</p><p>A：更新表时，MySQL不仅要保存数据，还要保存一下索引文件。大部分场景下，低技术列上建立索引的精确查找，相对于布简历索引的全表扫描没有任何优势，而且增大了IO负担</p><p>Q：使用索引顺序为什么要和建立索引顺序保持一致？</p><p>A：索引使用原则是最左前缀</p><p>Q：为什么不建议使用<code>like %xxx%</code></p><p>A：不会使用索引，而<code>like xxx%</code>则会使用索引</p><p>Q：为什么不要包含多个列的排序</p><p>A：where子句中已经使用了索引的话，那么order by中的列是不会使用索引</p><p>Q：为什么不能在索引列上进行运算</p><p>A：将在每个行上进行运算，这将导致索引失效而进行全表扫描。MySQL只对一下操作符才使用索引：&lt;,&lt;=,=,&gt;,&gt;=,between,in,以及某些时候的like(不以通配符%或_开头的情形)。</p><p>Q：为什么数据类型会影响性能</p><p>A：</p><p>(1)越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。<br>(2)简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。<br>(3)尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。</p><p>Q：为什么要用列名替代*</p><p>A：</p><p>1.减少网络带宽消耗</p><p>2.能有效利用覆盖索引</p><p>3.表结构变更对程序基本无影响</p><p>Q：在需要小部分数据时，为什么要使用limit限定返回数量</p><p>A：避免全表扫描，数据库只查询指定条数的数据</p><p>Q：为什么要减少不必要的子查询</p><p>A：子查询对主查询的每一行运行一次，从而导致可能的低效率</p><p>Q：为什么要用in替代or</p><p>A：MySQL内部会对in的列值进行排序后查找，效率更高</p><p>Q：为什么用union all替代union</p><p>A：不需要对结果集进行排序</p><p>Q：为什么批量插入要将多条语句改为一条语句多value的格式</p><p>A：减少和db的交互次数</p><p>Q：为什么多次alter操作要合并为一次操作</p><p>A：mysql对表的修改巨大部分操作都需要锁表并重建表，而锁表将对线上业务造成影响。</p><p>Q：为什么SQL语句中不能包含业务逻辑</p><p>A：数据库时有状态的服务，比昂更复杂而且速度慢。</p><p>Q：为什么名称不能使用MySQL保留字</p><p>A：SQL语句必须用反引号引用，增加书写难度</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句优化</title>
      <link href="/MySQL/optimization.html"/>
      <url>/MySQL/optimization.html</url>
      
        <content type="html"><![CDATA[<p>优化SQL的前提是：SQL写的正确</p><a id="more"></a><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>多查少改的列</li><li>数据差异化大的列</li><li>索引会降低insert及update效率(重建索引)，最好不要超过6个</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时，并且应尽可能的让字段顺序与索引顺序相一致</p></li><li><p>不在索引列上使用函数，将结果直接计算出来后再进行比较</p></li><li>禁止更新clustered索引数据列，因为clustered索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。<ul><li>指定为PRIMARY KEY或UNIQUE约束创建聚集或非聚集索引。PRIMARY KEY 约束默认为 CLUSTERED；UNIQUE约束默认为 NONCLUSTERED。如果表中已存在聚集约束或索引，那么在 ALTER TABLE 中就不能指定 CLUSTERED。如果表中已存在聚集约束或索引，PRIMARY KEY 约束默认为 NONCLUSTERED。</li></ul></li><li>尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。</li></ul><ul><li>正确书写where条件<ul><li>尽量不使用<ul><li>操作符<code>!=</code>、<code>&lt;&gt;</code>、<code>!&lt;</code>、<code>!&gt;</code></li><li>判断：<code>is null</code>或<code>is not null</code>、<code>NOT</code>、<code>NOT EXISTS</code>、<code>NOT IN</code>、<code>NOT LIKE</code></li><li>连接条件：<code>where a or b</code>，用<code>union</code>或<code>union all</code>替代</li><li>通配符：<code>%a%</code></li></ul></li><li>对字段进行表达式操作<ul><li><code>where num/2=100</code> -&gt; <code>where num=200</code></li></ul></li><li>对字段进行函数操作<ul><li><code>substring(name,1,3)=&#39;abc&#39;</code> -&gt; <code>where name like &#39;abc%&#39;</code></li></ul></li><li><code>=</code>左边进行函数、算术运算或其他表达式运算</li><li>将能减少结果集数量的条件放最左侧</li></ul></li></ul><ul><li>慎重使用<code>in</code>和<code>not in</code><ul><li>连续数值，用<code>between</code>替代<code>in</code></li><li><code>exists</code>或<code>not exists</code>替代</li><li><code>left join</code>替代</li></ul></li></ul><ul><li>判断是否存在符合条件的数据<ul><li>利用<code>limit 1</code>、<code>top 1</code>取得一行</li></ul></li></ul><ul><li>只查询真正需要的数据<ul><li>用实际使用的数据列名替代<code>*</code></li><li>如果只需要很少的行数，用<code>limit</code>来限制返回数量<ul><li>查询是否存在符合条件的数据</li><li>分页查询</li></ul></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--wrong</span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> age &gt; <span class="number">20</span>;</div><div class="line"><span class="comment">--right</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, last_name, sex, age <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> age &gt; <span class="number">20</span>;</div><div class="line"></div><div class="line"><span class="comment">--wrong</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, price <span class="keyword">FROM</span> products;</div><div class="line"><span class="comment">--right</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, price <span class="keyword">FROM</span> products <span class="keyword">LIMIT</span> <span class="number">10</span>;</div></pre></td></tr></table></figure><ul><li>减少不必要的子查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">---wrong</span></div><div class="line"><span class="keyword">SELECT</span> user_id, last_name <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> donationuser <span class="keyword">WHERE</span> donationuser.user_id = users.user_id);</div><div class="line"><span class="comment">---right</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> users.user_id <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> donationuser <span class="keyword">ON</span> users.user_id = donationuser.user_id;</div></pre></td></tr></table></figure><p>需要结合使用场景，如果查询大部分行，使用<code>inner join</code>效率更高。</p><ul><li><code>like</code>优化<ul><li>左通配符是否必须</li><li>使用全文搜索替代(MySQL 5.7+，支持中文)</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">---wrong</span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%bar%'</span>;</div><div class="line"><span class="comment">---right</span></div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'bar%'</span>;</div></pre></td></tr></table></figure><ul><li>尽量用 union all替换 union<ul><li>涉及排序，增加运算量</li><li>确认不可能出现重复结果或不在乎重复时</li></ul></li><li>避免类型转换，数据库将不使用索引<ul><li>非要类型转换，在传入的参数上进行转换</li></ul></li><li>尽量使用数字型字段<ul><li>若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li></ul></li><li>尽可能的使用 varchar/nvarchar 代替 char/nchar <ul><li>因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li></ul></li><li><code>limit</code>优化</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">---很快</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">LIMIT</span> <span class="number">1000</span>,<span class="number">10</span></div><div class="line"><span class="comment">---很慢</span></div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> A <span class="keyword">LIMIT</span> <span class="number">90000</span>,<span class="number">10</span></div><div class="line"><span class="comment">---优化</span></div><div class="line"><span class="comment">---用索引</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">90000</span>,<span class="number">10</span>;</div><div class="line"><span class="comment">---用between替换</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> A <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>  <span class="keyword">between</span> <span class="number">10000000</span> <span class="keyword">and</span> <span class="number">10000010</span>;</div></pre></td></tr></table></figure><ul><li>批量插入优化</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">---wrong</span></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'A'</span>,<span class="number">14</span>)</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'B'</span>,<span class="number">14</span>)</div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'C'</span>,<span class="number">14</span>)</div><div class="line"><span class="comment">---right</span></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> person(<span class="keyword">name</span>,age) <span class="keyword">values</span>(<span class="string">'A'</span>,<span class="number">14</span>),(<span class="string">'B'</span>,<span class="number">14</span>),(<span class="string">'C'</span>,<span class="number">14</span>),</div></pre></td></tr></table></figure><ul><li>查询语句不知道效率如何，建议使用<code>EXPLAIN</code>。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--查询语句如何运行</span></div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">sql</span></div><div class="line"><span class="comment">--当使用EXTENDED关键字时，EXPLAIN产生附加信息，可以用SHOW WARNINGS浏览。该信息显示优化器限定SELECT语句中的表和列名，重写并且执行优化规则后SELECT语句是什么样子，并且还可能包括优化过程的其它注解。在MySQL5.0及更新的版本里都可以使用，在MySQL5.1里它有额外增加了一个过滤列(filtered)。</span></div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">EXTENDED</span> <span class="keyword">sql</span></div><div class="line"><span class="comment">--JSON格式显示结果</span></div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">FORMAT</span>=<span class="keyword">JSON</span> (<span class="number">5.6</span>新特性)</div></pre></td></tr></table></figure><p>例如：</p><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>partitions</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>new12306</td><td>null</td><td>ALL</td><td>null</td><td>null</td><td>null</td><td>null</td><td>7141154</td><td>100.0</td><td>null</td></tr></tbody></table><p>解释：</p><table><thead><tr><th><strong>id</strong></th><th>SELECT识别符。这是SELECT的查询序列号</th></tr></thead><tbody><tr><td><strong>select_type</strong></td><td>SELECT类型,可以为以下任何一种:<br><strong>SIMPLE</strong>:简单SELECT(不使用UNION或子查询) <br><strong>PRIMARY</strong>:最外面的SELECT <br><strong>UNION</strong>:UNION中的第二个或后面的SELECT语句 <br><strong>DEPENDENT UNION</strong>:UNION中的第二个或后面的SELECT语句,取决于外面的查询 <br><strong>UNION RESULT</strong>:UNION 的结果 <br><strong>SUBQUERY</strong>:子查询中的第一个SELECT <br><strong>DEPENDENT SUBQUERY</strong>:子查询中的第一个SELECT,取决于外面的查询 <br><strong>DERIVED</strong>:导出表的SELECT(FROM子句的子查询)</td></tr><tr><td><strong>table</strong></td><td>输出的行所引用的表</td></tr><tr><td><strong>type</strong></td><td>联接类型。下面给出各种联接类型,按照从最佳类型到最坏类型进行排序:<br><strong>system</strong>:表仅有一行(=系统表)。这是const联接类型的一个特例。 <br><strong>const</strong>:表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const表很快,因为它们只读取一次! <br><strong>eq_ref</strong>:对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。 <br><strong>ref</strong>:对于每个来自于前面的表的行组合,所有有匹配索引值的行将从这张表中读取。 <br><strong>ref_or_null</strong>:该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。 <br><strong>index_merge</strong>:该联接类型表示使用了索引合并优化方法。<br><strong>unique_subquery</strong>:该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。<br> <strong>index_subquery</strong>:该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) <br><strong>range</strong>:只检索给定范围的行,使用一个索引来选择行。 <br><strong>index</strong>:该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。 <br><strong>ALL</strong>:对于每个来自于先前的表的行组合,进行完整的表扫描。</td></tr><tr><td><strong>possible_keys</strong></td><td>指出MySQL能使用哪个索引在该表中找到行</td></tr><tr><td><strong>key</strong></td><td>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</td></tr><tr><td><strong>key_len</strong></td><td>显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。</td></tr><tr><td><strong>ref</strong></td><td>显示使用哪个列或常数与key一起从表中选择行。</td></tr><tr><td><strong>rows</strong></td><td>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</td></tr><tr><td><strong>filtered</strong></td><td>显示了通过条件过滤出的行数的百分比估计值。</td></tr><tr><td><strong>Extra</strong></td><td>该列包含MySQL解决查询的详细信息</td></tr><tr><td></td><td><strong>Distinct</strong>:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。<br> <strong>Not exists</strong>:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。 <br><strong>range checked for each record (index map: #)</strong>:MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。 <br><strong>Using filesort</strong>:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。 <br><strong>Using index</strong>:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 <br><strong>Using temporary</strong>:为了解决查询,MySQL需要创建一个临时表来容纳结果。 <br><strong>Using where</strong>:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。 <br><strong>Using sort_union(…), Using union(…), Using intersect(…)</strong>:这些函数说明如何为index_merge联接类型合并索引扫描。 <br><strong>Using index for group-by</strong>:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。</td></tr></tbody></table><p><strong>注意</strong>：在其它场景，语句会修改数据(<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>)，可以用事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BEGIN</span>;</div><div class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">ANALYZE</span> ...;</div><div class="line"><span class="keyword">ROLLBACK</span>;</div></pre></td></tr></table></figure><ul><li>性能优化器 profile</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--查询是否开启</span></div><div class="line"><span class="keyword">SELECT</span> @@profiling;</div><div class="line"><span class="comment">--设置开启</span></div><div class="line"><span class="keyword">SET</span> profiling = <span class="number">1</span>;</div><div class="line"><span class="comment">--执行一次查询</span></div><div class="line"><span class="keyword">select</span> a,b,c <span class="keyword">from</span> tableName;</div><div class="line"><span class="comment">--查看结果</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</div><div class="line"><span class="comment">--查看当前查询的信息, 2为执行语句所对应的Query ID</span></div><div class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">2</span>;</div></pre></td></tr></table></figure><h3 id="其它阅读"><a href="#其它阅读" class="headerlink" title="其它阅读"></a>其它阅读</h3><p><a href="https://use-the-index-luke.com/3-minute-test/mysql" target="_blank" rel="external">三分钟测试SQL水平</a></p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="https://www.vertabelo.com/blog/technical-articles/5-tips-to-optimize-your-sql-queries" target="_blank" rel="external">5 tips to optimize your SQL Queries</a></p><p><a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="external">mysql explain用法和结果的含义</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Good Code</title>
      <link href="/code/rule.html"/>
      <url>/code/rule.html</url>
      
        <content type="html"><![CDATA[<p>实在是不想捏着鼻子看代码了</p><a id="more"></a><ul><li><p>版权信息</p></li><li><p>作者信息</p></li><li><p>命名</p><ul><li>拼写正确</li><li>词性<ul><li>属性和类：名词</li><li>方法：动词</li></ul></li><li>有语义<ul><li>专业词汇</li><li>清晰、精准</li><li>无歧义</li></ul></li><li>集合<ul><li>统一使用复数形式，如果将来类型发生变化，不会影响名称的修改</li></ul></li><li>重要细节<ul><li>时间常量带单位</li></ul></li></ul></li><li><p>可读性</p><ul><li><p>采用正向思维</p><ul><li>例如场景是集合有数据时做一些事情，可以判断集合为空时直接返回(取决于具体业务场景)</li></ul></li><li><p>方法要短小精悍</p></li><li>缩小变量的作用域<ul><li>就近原则：在使用的上一句进行声明</li><li>try-catch语句块包裹时，在try内直接返回正常值，不要把<code>return</code>写在最后</li></ul></li><li>在保证可读性的前提下，尽可能少声明变量<ul><li>如果变量只使用一次，那就把赋值语句直接写到变量使用的地方</li></ul></li></ul></li><li><p>方法</p><ul><li>将子问题抽象为独立的方法</li><li>保证抽象级别一致</li><li>相同逻辑的代码抽象为方法，代码复用</li><li>如果是多层方法调用<ul><li>如果是下层方法使用参数，直接将原参数直接传递给下层，到具体使用时再获取</li><li>参数顺序要保持一致</li></ul></li></ul></li><li><p>返回值</p><ul><li>类型定义<ul><li>集合类型：如果数据库没有查询到值，就new一个空集合Safes.of()包装一下</li><li>对象类型：接口定义改为Optional，返回值使用Optional.of()包装，Optional使用guava的(实现了序列化)</li></ul></li><li>执行保存的方法统一返回主键值</li></ul></li><li><p>注释</p><ul><li>FIXME与TODO<ul><li>FIXME<ul><li>临时代码</li><li>错误代码</li></ul></li><li>TODO<ul><li>待实现</li></ul></li></ul></li></ul></li><li><p>依赖</p><ul><li><p>模块依赖</p><ul><li>下层不可以引用上层的类</li></ul></li><li><p>项目依赖</p><ul><li>dubbo接口需要注意循环依赖</li></ul></li></ul></li><li><p>getter/setter</p><ul><li>采用build模式<ul><li><code>command+N</code> -&gt; <code>Getter and Setter</code> -&gt; <code>Setter template</code> -&gt; <code>Builder</code></li></ul></li></ul></li><li><p>日志</p><ul><li>关键操作写日志</li><li>日志级别<ul><li>打印参数用<code>debug</code></li></ul></li></ul></li><li><p>单元测试</p><ul><li>单元测试的包路径和实现的包路径要保持一致</li></ul></li><li><p>数据删除</p><ul><li>严谨物理删除，统一采用逻辑删除</li></ul></li><li><p>其它</p><ul><li>接口中不要有enum，如果一定要用，需要保证不会变，可以写明范围</li><li>将相同的操作提取为工具类</li></ul></li><li><p>Guava</p><ul><li><p>只获取集合中第0个值，可以用Guava的<code>Iterators.getOnlyElement(iterator)</code></p><ul><li>确保集合内只有一个值，当大于一个值时会报错</li></ul></li><li><p>排序可以用guava的Ordering.natural或Java 8的Comparator</p></li><li>保存对应关系的Map如果值是固定的，可以采用Guava的<code>ImmutableMap</code></li></ul></li></ul><ul><li><p>类</p><ul><li>工具类<ul><li>如果是设置值，命名可以采用<code>writeXXX</code><ul><li>参考FieldUtils.writeField</li></ul></li><li>方法参数可以多样化<ul><li>如果是读取文件，入参可以为文件路径，流数据等</li></ul></li></ul></li><li>普通类<ul><li>尽量不要有类变量，如果有，要确保不变，否则会引起多线程问题</li><li>使用的值如果范围仅限于某几个方法，并且是会变化的值，可以作为方法参数由外部传值</li></ul></li></ul></li><li><p>性能</p><ul><li>算法复杂度<ul><li>尽可能将循环次数减少<ul><li>例如循环某个list，判断当前一条的某个值等于固定值时采取操作，可以替换为先将list转为以判断的值为key的map，直接根据固定值从map中取到对应的信息，从而避免无效的循环次数</li></ul></li></ul></li></ul></li><li><p>三方工具</p><ul><li><p>java 8</p><ul><li>Java8中新特性使用比较多的是collection与stream的结合。</li></ul></li><li><p>Guava</p><ul><li>Splitter</li><li>Joiner</li><li>Lists,</li><li>Maps</li><li>Sets,</li><li>Multimap</li><li>Rangexxx</li><li>Table</li><li>ImmuableXXX</li><li>Collections2</li><li>Preconditions</li><li>FluentIterable</li><li>Files(可选）</li></ul></li><li><p>Apache common  lang3</p><ul><li>StringUtils</li><li>NumberUtils</li></ul></li><li><p>Apache collection4</p><ul><li>ListUtils</li><li>CollectionUtils</li><li>MapUtils</li><li>SetUtils</li></ul></li><li><p>使用场景</p><ul><li>建议先使用java8 stream处理，如果stream没有合适的工具，然后从guava和apache中查找有没有合适的工具。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git与oh-my-zsh</title>
      <link href="/git/alias.html"/>
      <url>/git/alias.html</url>
      
        <content type="html"><![CDATA[<p>还在傻傻得敲全所有的命令嘛</p><a id="more"></a><p>oh-my-zsh默认自带一个git插件。</p><p><code>cd ~/.oh-my-zsh/plugins/git</code></p><p><code>ls</code></p><p><code>vi git.plugin.zsh</code></p><p>里面alias了很多命令，不要再继续傻傻的敲全命令啦。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red-Black Tree</title>
      <link href="/DS/red-blackTree.html"/>
      <url>/DS/red-blackTree.html</url>
      
        <content type="html"><![CDATA[<p>我才没有停更呢！红黑树，走着！</p><a id="more"></a><blockquote><p>数据结构是指<strong>逻辑意义</strong>上的数据结构组织方式及其相应的处理方式。</p></blockquote><ul><li>逻辑意义：实现层面，比如树，存储时可能是数组</li><li>数据组织方式：表、树、图、散列</li><li>处理方式：以某种特定的算法实现数据的增删改查及遍历</li></ul><h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><p><code>O(1)</code>、<code>O(logn)</code>、<code>O(n)</code>、<code>O(nlogn)</code>、<code>O(n2)</code>、<code>O(2n)</code>、<code>O(n!)</code></p><h2 id="数据结构的好与坏"><a href="#数据结构的好与坏" class="headerlink" title="数据结构的好与坏"></a>数据结构的好与坏</h2><p>AVL树&amp;红黑树：取决于场景和数据量</p><p>让算法复杂度成为一种立体的思维习惯。算法的规模和调用频率。</p><h2 id="什么是树"><a href="#什么是树" class="headerlink" title="什么是树"></a>什么是树</h2><ul><li>一个节点，即只有根节点，也可以是一棵树</li><li>其中任何一个节点与下面所有节点构成的树称为子树</li><li>根节点没有父节点，而叶子节点没有子节点</li><li>除根节点外，任何节点有且仅有一个父节点</li><li>任何节点可以有0~n个子节点</li></ul><h2 id="二叉查找树特性"><a href="#二叉查找树特性" class="headerlink" title="二叉查找树特性"></a>二叉查找树特性</h2><ul><li>左子树所有节点的值均小于或等于根节点的值</li><li>右子树所有节点的值均大于或等于根节点的值</li><li>左、右子树本身又各都是二叉查找树</li></ul><h3 id="二叉树如何找数据10"><a href="#二叉树如何找数据10" class="headerlink" title="二叉树如何找数据10"></a>二叉树如何找数据10</h3><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fyqd4opchqj21400u03zu.jpg" alt=""></p><ul><li>首先从根节点开始，比较10与9，由于10&gt;9，则在右子树查找</li><li>比较10与13，由于10&lt;13，则在左子树查找</li><li>比较10与11，由于10&lt;11，则在左子树查找</li><li>查找到10</li></ul><p>利用二分查找思想，经过三次，效率高。如果是列表的话，查找次数不止三次，正是因为这个特性，二叉查找树得到广泛应用。</p><h3 id="二叉树如何找数据"><a href="#二叉树如何找数据" class="headerlink" title="二叉树如何找数据"></a>二叉树如何找数据</h3><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fyqd4oj864j20u0140q4w.jpg" alt=""></p><p>前序遍历：根左右</p><p>中序遍历：左根右</p><p>后序遍历：左右根</p><p>二叉查找树的中序遍历就是有序序列，落到数轴上，即124789。</p><h3 id="长歪的二叉查找树"><a href="#长歪的二叉查找树" class="headerlink" title="长歪的二叉查找树"></a>长歪的二叉查找树</h3><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fyqd4o8pizj20u01400u3.jpg" alt=""></p><p>都是大于上一个节点，都挂在右节点，说是树，其实是列表，几乎变成了线性，构建、查找树均效率低。那就需要把树变得扁一些，重新构建树，解决多次插入新节点导致的不平衡问题，也就是平衡二叉树。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li>树的左右<strong>高度差</strong>的绝对值不能超过1</li><li>任何往下<strong>递归</strong>的左、右子树，必须符合第一条性质</li><li>没有任何节点的<strong>空树</strong>或只有根节点的树也是平衡二叉树</li></ul><p><img src="http://wx3.sinaimg.cn/mw690/8c564d2agy1fyqd4oe410j21400u0409.jpg" alt=""></p><h3 id="红黑树与AVL树"><a href="#红黑树与AVL树" class="headerlink" title="红黑树与AVL树"></a>红黑树与AVL树</h3><p><strong>AVL树</strong>：是以苏联数学家Adelson-Velsky和Landis名字命名的平衡二叉树算法</p><p>插入和修改都不频繁，查询频繁。</p><p><strong>红黑树</strong>：是于1972年发明的，当时称为对称二叉B树，1978年得到优化，正式命名为红黑树。它的特征是在每个节点上增加一个属性来表示节点的颜色，可以是红色和黑色。频繁插入和删除效率高。</p><p><strong>AVL树与红黑树是兄弟关系，谁也不属于谁</strong></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><blockquote><p>自平衡的二叉查找树</p></blockquote><p>红黑树以各方面都不差的性能，在JDK集合中广泛使用(TreeMap和TreeSet底层实现，HashMap_JDK8)</p><ul><li>节点只能是红色或黑色</li><li>根节点必须是黑色(旋转时很重要)</li><li>每个叶子节点都是黑色的空节点(NIL节点)<ul><li>nothing is leave，叶子节点的虚节点</li><li>旋转时，必须要判断叔叔节点的颜色，以决定旋转方向</li></ul></li><li>一条路径上不能出现相邻的两个红色节点</li><li>每个红色节点的两个子节点都是黑色的(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li><li>在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色</li></ul><p><strong>红黑树从根到叶子的最长路径不会超过最短路径的2倍</strong></p><h4 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h4><p>红黑树在插入和删除节点时，会导致红黑树性质发生改变，需要调整树的结构。</p><ul><li>操作<ul><li>变色</li><li>旋转<ul><li>左旋<ul><li>逆时针旋转红黑树的两个节点，使得父节点被自己的右子节点取代，而自己称为左子节点</li></ul></li><li>右旋<ul><li>顺时针旋转红黑树的两个节点，使得父节点被自己的左子节点取代，而自己成为右子节点</li></ul></li></ul></li></ul></li><li>过程<ul><li>红黑树的根节点始终为黑色，插入节点默认为红色（黑色也可以，但是会增加路径上的黑色结点，很容易破坏红黑树性质，调整很麻烦，所以选择红色）</li><li>插入红色节点</li></ul></li></ul><h5 id="插入新节点后的操作"><a href="#插入新节点后的操作" class="headerlink" title="插入新节点后的操作"></a>插入新节点后的操作</h5><ul><li>如果父结点为黑色，红黑树性质继续保持，操作完成。</li><li>如果父结点为红色时，叔叔节点时红色，则重新着色</li><li>如果父节点是红色，叔叔节点是黑色，而新节点是父节点的右节点时，进行左旋</li><li>如果父节点是红色，叔叔节点是黑色，而新节点是父节点的左节点时，进行右旋</li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>ConcurrentHashMap中定义了5种节点类型，分别为Node(常规节点类型)、Null、ReservationNode、TreeBin(要挂红黑树啦，下面是红色或黑色的TreeNode)、ForwardingNode(在扩容时，迁移完会放一个节点，如果这个节点放在桶里，会转发到迁移后的表里)。</p><p>下图为ConcurrentHashMap中底层实现，树与链表间的转换，使得拥有高效率的查询。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fyrlkpp08nj20uc0auwg1.jpg" alt="转为树"></p><p>当binCount大于等于TREEIFY_THRESHOLD时，转化为树。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fyrlkr2nu1j215a0tcq95.jpg" alt="转为链表"></p><p>如果是小于，则变为列表。</p><p>TreeMap底层的红黑树实现，新节点默认为红色，判断当树不平衡时，进行变色及旋转操作。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fyrlsf9gzyj20u00wugt5.jpg" alt="TreeMap"></p><h2 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h2><p>集合是数据结构的载体</p><p><img src="http://wx1.sinaimg.cn/large/8c564d2agy1fyspaak2trj21xy0u0adi.jpg" alt=""></p><h3 id="常用集合"><a href="#常用集合" class="headerlink" title="常用集合"></a>常用集合</h3><ul><li>HashSet、HashMap</li><li>TreeSet、TreeMap<ul><li>TreeSet其实就是TreeMap，只不过是TreeSet把value固定为<code>Present</code>，就是new Object()。浪费存储，new Object()大约占12个字节，和虚拟机有关，可以用visualVM分析。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div></pre></td></tr></table></figure><ul><li>LinkedList、ArrayList<ul><li>LinkedList实现了Deque接口</li><li>ArrayList的subList方法有坑，在subList场景中，高度注意对父集合元素的增加或删除，均会导致对子列表的遍历，增加、删除产生ConcurrentModificationException异常</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List parent = <span class="keyword">new</span> ArrayList();</div><div class="line">parent.add(<span class="number">1</span>);</div><div class="line">parent.add(<span class="number">2</span>);</div><div class="line">parent.add(<span class="number">3</span>);</div><div class="line"></div><div class="line">List list = parent.subList(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">parent.add(<span class="number">4</span>);</div><div class="line">list.forEach(System.out::println);</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException</div><div class="line">at java.base/java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1284)</div><div class="line">at java.base/java.util.ArrayList$SubList.listIterator(ArrayList.java:1153)</div><div class="line">at java.base/java.util.AbstractList.listIterator(AbstractList.java:311)</div><div class="line">at java.base/java.util.ArrayList$SubList.iterator(ArrayList.java:1149)</div><div class="line">at java.base/java.lang.Iterable.forEach(Iterable.java:74)</div></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>为什么要关注位运算。float的浮点型的实现。0.8f-0.7是否等于0.7f-0.6f。不等于。因为float有精度损失。</li><li>如何在单位愉快的实施代码规约？1.立法透明；大家都参与2.执法严厉；制定了就要严格执行，包括奖惩机制，组织上也要支持，技术负责人和老板要支持，要知道代码约定的意义。3.方法不要超过80行</li><li>如何高效阅读源码？1.让你的使用方式是正确的，避免错误的使用；2.出问题时快速定位问题；有可能是底层、也有可能是框架原理性的问题；3.使用断点调试(watch查看值)</li><li>数据结构在增删改查时很少用，有啥用？1.数据结构和集合是两回事，不同的集合可以用相同的数据结构来实现。2.业务判断，数据结构是否适合业务快速迭代，快速run起来。</li><li>ArrayList和HashMap走天下，有什么问题？数据结构的增删改查有侧重，要恰当的使用数据结构，多看看并法包。</li><li>CopyOnWriteArrayList，简称COW，在写的时候会复制一份出来，读的时候读原始数据。写的时候通知读，数据要发生改变啦。写的时候是利用了volatile，保证了线程的可见性。</li><li>怎么看待设计模式？设计模型的三种模式：创建(解决对象创建和使用之间的耦合度)、结构(解决对象的结构和功能之间的耦合问题)和行为(解决对象不变变化对使用者带来的耦合问题)。比如享元模式，是为了把变和不变的地方分离开来。例如下围棋时，棋子可以放在盒子里继续使用，它的材质、大小、形状、厂家是一样，但是位置、颜色是会发生变化的</li><li>如何解决线程和线程池的恐惧？1.线程和线程池各自有状态，例如线程有running、block、wait；线程池有terminate、stop、running等。线程池解决了高效复用线程的问题。线程提高了进程的使用效率。虽然多线程跑的时候不太可控，但正因为多线程的存在，才可以不受控于CPU的核数。</li><li>领域驱动的难点？很难抽象出比较好的业务模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> DS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac访问MySQL的Data文件夹</title>
      <link href="/MySQL/frm.html"/>
      <url>/MySQL/frm.html</url>
      
        <content type="html"><![CDATA[<p>MySQL导入frm、MYD、MYI文件</p><a id="more"></a><p>MySQL在使用MYISAM存储引擎时，表是由“<code>*.frm</code>、<code>*.MYD</code>、<code>*.MYI</code>”组成。</p><ul><li><code>*.frm</code>：表定义</li><li><code>*.MYD</code>：数据文件MYData</li><li><code>*.MYI</code>：索引文件MYIndex</li></ul><hr><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><ul><li>连接上MySQL后，创建一个数据库，访问MySQL安装目录下的<code>data</code>文件夹。</li><li><p>Mac上默认是没有读写权限的，需要修改</p><ul><li>data文件夹上右键”getInfo”，在最下方设置访问权限为可读写</li><li>终端：<code>sudo chmod +x /usr/local/mysql/data</code></li></ul></li><li><p>将需要恢复的数据放到<code>MySQL安装路径/data/数据库名字/</code>下</p></li><li>结束</li></ul><p>备注：恢复完毕后可以把文件夹权限修改回来，以防将来没地方哭</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺序一致性</title>
      <link href="/uncategorized/null.html"/>
      <url>/uncategorized/null.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重排序</title>
      <link href="/concurrency/reorder.html"/>
      <url>/concurrency/reorder.html</url>
      
        <content type="html"><![CDATA[<p>对程序执行顺序重新排序</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</p></blockquote><ul><li>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</li></ul><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><blockquote><p>不管怎么重排序(编译器和处理器为了提高并发度)，(单线程)程序的执行结果不能被改变</p></blockquote><ul><li><p>编译器、runtime和处理器都必须遵守as-if-serial语义</p><ul><li>不存在数据依赖，重排序</li><li>存在数据依赖，不重排序</li></ul></li><li><p>as-if-serial语义把单线程程序保护了起来</p></li></ul><h3 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h3><blockquote><p>JMM仅仅要求前一个操作(执行结果)对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p></blockquote><p>在计算机中，然间技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能提高并行度</p><h3 id="对多线程的影响"><a href="#对多线程的影响" class="headerlink" title="对多线程的影响"></a>对多线程的影响</h3><p>当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用<strong>猜测(Speculation)</strong>执行来克服控制相关性对并行度的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// A线程执行</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</div><div class="line">        a = <span class="number">1</span>;</div><div class="line">        flag = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"><span class="comment">// B线程执行</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (flag) &#123;</div><div class="line">            <span class="keyword">int</span> i = a * a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算<code>a*a</code>，然后把结果临时保存到一个名为**重排序缓冲(Reorder Buffer,ROB)的硬件缓存中。当<code>flag</code>为真时，就把该计算结果写入变量<code>i</code>中。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果(这也是as-if-serial语义允许在存在控制依赖的操作做重排序的原因)，但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果</p>]]></content>
      
      
      <categories>
          
          <category> concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/concurrency/JMM.html"/>
      <url>/concurrency/JMM.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。</p></blockquote><a id="more"></a><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>线程(并发执行的活动实体)之间的<strong>通信</strong>和<strong>同步</strong>，Java的并发采用的是共享内存模型</p><blockquote><ul><li><p>通信：线程之间以何种机制来交换信息</p><ul><li>共享内存<ul><li>通过读-写内存中的公共状态进行隐式通信</li></ul></li><li>消息传递<ul><li>通过发消息显式通信</li></ul></li></ul></li><li><p>同步：程序中用于控制不同线程间操作发生相对顺序的机制</p><ul><li>共享内存<ul><li>显式进行：必须显式指定某个方法或某段代码需要在线程之间互斥执行</li></ul></li><li>消息传递<ul><li>隐式进行：由于消息的发送必须在消息的接受之前</li></ul></li></ul></li></ul></blockquote><h3 id="抽象结构"><a href="#抽象结构" class="headerlink" title="抽象结构"></a>抽象结构</h3><p>共享变量：实例域、静态域和数组元素</p><p>非共享变量：局部变量、方法定义参数和异常处理器参数</p><blockquote><p> 线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p></blockquote><p>本地内存是JMM的一个抽象概念，涵盖了缓存、写缓冲区、寄存器以及其它的硬件和编译器优化</p><p>JMM通过控制主内存与每个线程的本地内存之间的交互，提供内存可见性保证。</p><h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><ul><li>种类<ul><li>编译器优化的重排序<ul><li>不改变但线程陈谷语义的前提下，可以重新安排语句的执行顺序</li><li>JMM的编译器重排序规则会禁止<strong>特定类型</strong>的编译器重排序</li></ul></li><li>处理器重排序(指令集并行的重排序)<ul><li>指令集并行技术(Instruction-Level Parallelism, ILP)</li><li>如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序</li><li>生成指令序列时，插入特定类型的内存屏障指令，禁止<strong>特定类型</strong>的处理器重排序</li></ul></li><li>内存系统的重排序<ul><li>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul></li></ul></li></ul><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>现代的处理器使用<strong>写缓冲区</strong>临时保存向内存写入的数据</p><ul><li>优点<ul><li>保证指令流水线持续运行</li><li>避免由于处理停顿下来等待向内存写入数据而产生的延迟</li><li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用</li></ul></li><li>缺点<ul><li>每个处理器上的写缓冲区，仅仅对它所在的处理器可见<ul><li>处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写顺序一致</li></ul></li></ul></li></ul><p>常见的处理器都允许Store_Load重排序；不允许存在数据依赖的操作重排序。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><table><thead><tr><th>屏障类型</th><th>指令实例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>确保Load1数据的装载先于Load2及所有后续装载指令的装载</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>确保Store1数据对其它处理器可见(刷新到内存)先于Store2级所有后续存储指令的存储</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load2</td><td>确保Store1数据怼其它处理器变得可见先于Load2及所有后续装载指令的装载</td></tr></tbody></table><blockquote><p>StoreLoad Barriers同时具有其它3个屏障的效果。大多处理器都支持。但执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中(Buffer Fully Flush)</p></blockquote><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><blockquote><p>JDK 5+</p><p>在JMM中，如果一个操作(同线程或不同线程)执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系</p><p>仅仅要求前一个操作(执行结果)对后一个操作可见</p></blockquote><ul><li>程序顺序规则<ul><li>一个线程中的每个操作，happens-before于该线程中的任意后续操作</li></ul></li><li>监视器锁规则<ul><li>对一个锁的解锁，happens-before于随后对这个锁的枷锁</li></ul></li><li>volatile变量规则<ul><li>对一个volatile域的写，happens-before域人意后续对这个volatile域的读</li></ul></li><li>传递性<ul><li>如果A happens-before B，且B happens-before C，那么A happens-before C</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized原理与应用</title>
      <link href="/concurrency/synchronized.html"/>
      <url>/concurrency/synchronized.html</url>
      
        <content type="html"><![CDATA[<p>偏向锁、轻量锁和锁的存储结构</p><a id="more"></a><ul><li>Sychronized实现同步的基础，也就是Java中的每一个对象都可以作为锁<ul><li>同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的Class对象</li><li>同步方法块，锁是sychronized括号里配置的对象</li></ul></li></ul><ul><li>Synchonized在JVM里的实现原理<ul><li>基于进入和退出Monitor对象来实现方法同步和代码块同步<ul><li>代码块同步：monitorenter、monitorexit</li><li>方法同步：JVM规范未明确，也可以使用上述两个命令实现</li></ul></li></ul></li></ul><blockquote><p>monitorenter指令是在变异后插入到同步代码块的开始位置</p><p>monitorexit是插入到方法结束处和异常处</p><p>JVM要保证每个monitorenter必须有对应的monitorexit与之配对</p><p>任何对象都有一个monitor与之关联，当且只有一个monitor被持有后，它将处于锁定状态。</p><p>线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的所</p></blockquote><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote><p>sychronized存储在对象头里</p><ul><li>数组<ul><li>3个字宽(word)存储对象头</li></ul></li><li>非数组<ul><li>2字宽存储对象头</li></ul></li></ul><p>字宽Word：定义位长度的单位，取决于计算机结构和操作系统。</p><p>32位：1字宽为4字节，即32bit</p><p>64位：1字宽8字节，即64bit</p></blockquote><h4 id="对象头长度"><a href="#对象头长度" class="headerlink" title="对象头长度"></a>对象头长度</h4><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode、分代年龄和锁标记位</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array Length</td><td>数组的长度(如果当前是数组)</td></tr></tbody></table><h4 id="对象头的存储结构"><a href="#对象头的存储结构" class="headerlink" title="对象头的存储结构"></a>对象头的存储结构</h4><p><strong>32bit</strong></p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标识位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象的hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p><strong>64bit</strong></p><table><thead><tr><th>锁状态</th><th>25bit</th><th>31bit</th><th>1bit</th><th>4bit</th><th>1bit</th><th>2bit</th></tr></thead><tbody><tr><td>锁状态</td><td></td><td></td><td>cms_free</td><td>分代年龄</td><td>偏向锁</td><td>锁标识位</td></tr><tr><td>无锁</td><td>unused</td><td>hashCode</td><td></td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>ThreadID(54bit)Epoch(2bit)</td><td>同左</td><td></td><td></td><td>1</td><td>01</td></tr></tbody></table><p><strong>Mark Word状态变化</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fxcbziwwsrj21bm0940u3.jpg" alt=""></p><h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>JDK1.6+</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID。</p></blockquote><h5 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h5><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入</p><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><ul><li>记录偏向锁的线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试对象头的Mark Word里是否存储着指向当前线程的偏向锁。<ul><li>测试成功：表示线程已经获得了锁</li><li>测试失败：需要测试Mark Word中偏向锁的标识是否为1(表示当前是偏向锁)<ul><li>无：使用CAS竞争锁</li><li>有：尝试使用CAS将对象头的偏向锁指向当前线程</li></ul></li></ul></li></ul><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><blockquote><p>机制：等到竞争才释放</p><p>时机：全局安全点(在这个时间点上没有正在执行的字节码)</p></blockquote><ul><li>暂停拥有偏向锁的线程</li><li>检查持有偏向锁的线程是否活着<ul><li>是：拥有偏向锁的栈会被执行，便利偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其它线程，要么恢复到无锁或者标记对象不适合作为偏向锁</li><li>否：将对象头设置成无锁状态</li></ul></li><li>唤醒暂停的线程</li></ul><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-XX:-UseBiastedLocking:启用/禁用(禁用后，默认进入轻量级锁状态)</div><div class="line">-XX:BiasedLockingStartupDelay=0:关闭启动延迟</div></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h5><ul><li>线程执行同步块之前，JVM会在当前线程的栈帧中创建存储锁记录的空间，并将对象头重的Mark Word复制到锁记录中，也就是<code>Displaced Mark Word</code></li><li>线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针<ul><li>成功：当前线程获得锁</li><li>失败：存在与其它线程竞争锁，当前线程尝试使用自旋来获取锁</li></ul></li></ul><blockquote><p>自旋会消耗CPU，为了避免无用的自旋(获得锁的线程阻塞住了)，一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。</p></blockquote><h5 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h5><ul><li>使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头<ul><li>成功：表示没有竞争发生</li><li>失败：当前锁存在竞争，锁就会膨胀成重量级锁</li></ul></li></ul><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外消耗(和执行非同步方法相比仅存在纳秒级的差距)</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>只有一个线程访问同步块</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度</td><td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td><td>追求响应时间，同步块执行速度非常快</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU</td><td>线程阻塞，响应时间缓慢</td><td>追求吞吐量，同步块执行速度较长</td></tr></tbody></table><h3 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h3><blockquote><p>原子atomic：不能被进一步分割的最小粒子</p><p>原子操作atomic operation：不可被中断的一个或一系列操作</p></blockquote><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><table><thead><tr><th>名称</th><th>英文</th><th>解释</th></tr></thead><tbody><tr><td>缓存行</td><td>Cache Line</td><td>缓存的最小操作单位</td></tr><tr><td>比较并交换</td><td>Compare and Swap</td><td>CAS操作需要输入两个数值，一个旧值(操作前的值)，和一个新值，比较旧值有无发生变化，没有发生变化才交换成新值，否则不交换</td></tr><tr><td>CPU流水线</td><td>CPU pipeline</td><td>在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度</td></tr><tr><td>内存顺序冲突</td><td>Memory order violation</td><td>一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，这时CPU必须清空流水线</td></tr></tbody></table><h4 id="CPU实现"><a href="#CPU实现" class="headerlink" title="CPU实现"></a>CPU实现</h4><blockquote><p>32位IA-32处理器使用基于对缓存加锁或总线加锁</p><p>Pentium 6和最新的处理自动保证单处理器对<strong>同一个缓存行</strong>里进行16/32/64位的操作是原子的，但是复杂的操作不能自动保证其原子性(跨总线宽度、跨多个缓存行和跨页表的访问)，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂处理的原子性。</p></blockquote><h5 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h5><blockquote><p>使用处理器提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p></blockquote><h5 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h5><p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里。</p><blockquote><p>内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性（缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其它处理器回写已被锁定的缓存行的数据时，会使缓存行无效）</p></blockquote><ul><li>两种情况不会使用缓存锁<ul><li>不能被缓存在处理器内部、操作跨多个缓存行时，处理器会调用总线锁定</li><li>处理器不支持缓存锁定(Intel 486和Pentium)</li></ul></li></ul><h4 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h4><blockquote><p>通过锁和循环CAS的方式来实现原子操作</p></blockquote><ul><li>循环CAS实现原子操作<ul><li>利用处理器的<code>CMPXCHG</code>指令</li><li>自旋CAS实现的基本思路：循环进行CAS操作直到成功为止</li></ul></li><li>CAS实现原子操作的三大问题<ul><li>ABA：使用版本号<ul><li>AtomicStampedReference：检查引用和标志</li></ul></li><li>循环时间长开销大<ul><li>如果JVM能支持处理器提供的<code>pause</code>指令，效率会有一定提升<ul><li>延迟流水线执行指令，使CPU不会消耗过多的执行资源</li><li>避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率</li></ul></li></ul></li><li>只能保证一个共享变量的原子操作<ul><li>循环CAS操作无法保证对多个共享变量的操作，除了锁以外，还可以将多个共享变量合并成一个共享变量来操作，Java 1.5，JDK提供了<code>AtomicReference</code>类来保证引用对象的原子性，就可以把多个变量放在一个对象里来进行CAS操作</li></ul></li></ul></li><li>使用锁机制保证原子操作<ul><li>偏向锁、轻量级锁和互斥锁</li><li>除了偏向锁，JVM实现锁的方式都用了循环CAS</li></ul></li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.quora.com/What-is-the-difference-between-a-word-and-a-byte" target="_blank" rel="external">Quora-What is the difference between a word and a byte?</a></p><p><a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf" target="_blank" rel="external">Oracle-Biased Locking</a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>Markdown的表格真得很一言难尽</li></ul>]]></content>
      
      
      <categories>
          
          <category> concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/concurrency/volatile.html"/>
      <url>/concurrency/volatile.html</url>
      
        <content type="html"><![CDATA[<p>我有一个问题，在文章的最下方，希望大佬指教，谢谢。</p><a id="more"></a><blockquote><p><code>volatile</code>时轻量级的<code>sychronize</code>，在多处理器开发中保证了<strong>共享变量</strong>的可见性。</p><p>当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><p>如果<code>volatile</code>使用恰当，比<code>sychronized</code>的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过<strong>排他锁</strong>单独获取这个变量</p><p>线程内存模型确保所有线程看到这个变量的值是一致的</p><p><strong>相关CPU术语</strong></p><table><thead><tr><th>术语</th><th>英文</th><th>描述</th></tr></thead><tbody><tr><td>内存屏障</td><td>memory barriers</td><td>一组处理器指令，实现对内存操作的顺序限制</td></tr><tr><td>缓存行</td><td>cache line</td><td>CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令</td></tr><tr><td>原子操作</td><td>atomic operations</td><td>不可中断的一个或一系列操作</td></tr><tr><td>缓存填充</td><td>cache line fill</td><td>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存(L1,L2,L3或所有)</td></tr><tr><td>缓存命中</td><td>cache hit</td><td>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取</td></tr><tr><td>写命中</td><td>write hit</td><td>当处理器将操作数写回道一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在，则处理器将这个操作数写回到缓存，而不是内存</td></tr><tr><td>写缺失</td><td>write misses the  cache</td><td>一个有效的缓存行被写入到不存在的内存区域</td></tr></tbody></table><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>处理器保证原子操作有两种机制<ul><li>总线锁定</li><li>缓存一致性<ul><li>当某块CPU对缓存中的数据进行了操作之后，就通知其它CPU放弃存储在它们内部的缓存，或者从主内存中重新读取</li></ul></li></ul></li></ul><p>有<code>volatile</code>修饰的共享变量进行写操作时，JVM会向处理器发送一条<code>Lock</code>前缀的指令，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查缓存的值是不是过期了，当处理器发现缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改时，会重新从系统内存中把数据读到处理器缓存里。</p><ul><li><p>Lock前缀的指令在多核处理器下的作用</p><ul><li>将当前处理器缓存行的数据写回到系统内存<ul><li>Intel486和Pentium处理器，处理器可以独占任何共享内存，锁住总线，导致其它CPU不能访问总线，也就不能访问系统内存</li><li>P6和目前的处理器中，会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</li></ul></li><li>这个写回内存的操作会使在其它CPU里缓存了该内存地址的数据无效<ul><li>IA-32和Intel 64处理器使用MESI控制协议去维护内部缓存和其它处理器缓存的一致性，能够嗅探其它处理器访问系统内存和它们的内部缓存，通过嗅探一个处理器来检测其它处理器打算写内存地址，而改地址处于共享状态，那么正在嗅探的处理器使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充</li></ul></li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/MESI_protocol" target="_blank" rel="external">MESI</a>：也称伊利诺斯协议(伊利诺斯州立大学提出)，是一种广泛使用的支持写回策略的缓存一致性协议。分别对应缓存的4种状态：Modified修改、Exclusive独占、Shared共享、Invalid无效。</p></blockquote></li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对于经常要写入缓存的操作，考虑到缓存锁会影响写入的效率。</p><p>对于i7，酷睿等处理器，高速缓存行是64字节，不支持部分填充缓存行，这也就意味着，当队列大小不足64字节的时候(引用结点)，这个时候，有可能会把头结点和尾结点读取到同一个缓存行中，那么当一个处理器锁定缓存行之后，其他处理器进行入队和出队操作的时候，就必须排队等待，这就影响了程序的执行效率，这个时候，就有人将队列的结点增加空属性来修改成64字节。这就可以使得你在操作某个结点的时候，其他处理器不需要排队等待缓存锁的释放。</p><ul><li>以下场景不适合使用<ul><li>缓存行非64字节宽的处理器<ul><li>P6系列和奔腾处理器，L1和L2高速缓存行时32字节宽</li></ul></li><li>共享变量不会被频繁写<ul><li>因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，本身会带来性能消耗，如果共享变量不会被频繁写，锁的几率也就很小，也就没有必要通过追加字节的方式来避免相互锁定</li></ul></li></ul></li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>Doug lea在对LinkedTransferQueue的<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/LinkedTransferQueue.java?revision=1.7&amp;view=markup" target="_blank" rel="external">JSR 166 - 1.7修正</a>中使用填充字节的方式，<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/LinkedTransferQueue.java?revision=1.8&amp;view=markup" target="_blank" rel="external">JSR 166 - 1.8</a>中就取消了这种方式，目前还不敢肯定的说出变化的原因，希望大佬指教，super2bai@gmail.com</p><ul><li><p><a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/LinkedTransferQueue.java?r1=1.7&amp;r2=1.8" target="_blank" rel="external">1.7&amp;1.8比较记录</a></p></li><li><p><a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/LinkedTransferQueue.java?view=log" target="_blank" rel="external">LinkedTransferQueue变更记录</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程的挑战</title>
      <link href="/concurrency/challenge.html"/>
      <url>/concurrency/challenge.html</url>
      
        <content type="html"><![CDATA[<p>并发要面对的事儿</p><a id="more"></a><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul><li><p>时间片一般是几十毫秒</p></li><li><p>线程有创建和上下文切换的开销</p></li><li><p>测试上下文切换次数和时长</p><ul><li><a href="http://www.bitmover.com/lmbench/" target="_blank" rel="external">Lmbench3</a>：时长</li><li>vmstat：次数<ul><li>Linux自带命令</li></ul></li></ul></li><li><p>CS(Content Switch)：上下文切换次数</p></li><li>如何减少上下文切换<ul><li>无锁并发编程<ul><li>数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据</li></ul></li><li>CAS算法<ul><li>Java的Atomic包使用CAS算法来更新数据，且无需加锁</li></ul></li><li>使用最少线程<ul><li>避免创建不需要的线程</li></ul></li><li>协程<ul><li>在单线程里实现多任务的调度</li><li>在单线程里维持多个任务间的切换</li></ul></li></ul></li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>避免死锁的方法<ul><li>避免一个线程同时获取多个锁</li><li>避免一个线程在锁内同时占用多个资源<ul><li>尽量保证每个锁只占用一个资源</li></ul></li><li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来代替使用内部锁机制</li><li>对于数据库锁，加锁和解锁必须在同一个数据库连接里<ul><li>否则会出现解锁失败的情况</li></ul></li></ul></li></ul><h3 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h3><blockquote><p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源</p></blockquote><ul><li>硬件资源<ul><li>带宽的上传/下载速度</li><li>硬盘读写速度</li><li>CPU的处理速度</li></ul></li><li>软件资源<ul><li>数据库的连接数</li><li>socket连接数</li><li>等等</li></ul></li></ul><p>在并发编程中，如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不会加快，反而会更慢，因为增加了上下文切换和资源调度的时间。</p><ul><li>解决办法<ul><li>硬件资源限制<ul><li>使用集群并行执行</li></ul></li><li>软件资源限制<ul><li>采用资源池将资源复用</li></ul></li></ul></li></ul><p>根据不同的资源限制调整程序的并发度</p>]]></content>
      
      
      <categories>
          
          <category> concurrency </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL编码及排序规则</title>
      <link href="/MySQL/sort.html"/>
      <url>/MySQL/sort.html</url>
      
        <content type="html"><![CDATA[<p>MySQL5.5.3是道分水岭</p><a id="more"></a><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><blockquote><p>代码点（Code Point)：Unicode是属于编码字符集（CCS）的范围。Unicode所做的事情就是将我们需要表示的字符表中的每个字符映射成一个数字，这个数字被称为相应字符的码点（code point）。例如“严”字在Unicode中对应的码点是U+0x4E25</p></blockquote><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>相同代码值</li><li>相同编码</li><li>相同长度</li></ul><h3 id="UTF8mb3"><a href="#UTF8mb3" class="headerlink" title="UTF8mb3"></a>UTF8mb3</h3><ul><li>变长编码</li><li>存储一个代码点需要1-3字节</li><li>不能存储所有Unicode代码点，只支持0x000到0xFFFF，也就是BMP(Basic Multilingual Plane)</li></ul><blockquote><p>BMP：基本多文种平面，也成第零平面(Plane 0)，是Unicode中的一个编码区段，几乎包含现代语言的字符，和大量符号。目的是支持对于书写使用的先前字符集的统一。</p></blockquote><h3 id="UTF8mb4"><a href="#UTF8mb4" class="headerlink" title="UTF8mb4"></a>UTF8mb4</h3><ul><li>补充字符<ul><li>支持存储例如emoji</li></ul></li><li>存储一个代码点需要4字节</li><li>MySQL5.5.3+</li></ul><p><strong>BTW, MariaDB也应该使用UTF8mb4</strong></p><h2 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h2><blockquote><p>ci：case insensitive，大小写不敏感</p><p>cs：case sensitive，大小写不敏感</p><p>bin：二进制，大小写敏感</p></blockquote><h3 id="utf8mb4-general-ci"><a href="#utf8mb4-general-ci" class="headerlink" title="utf8mb4_general_ci"></a>utf8mb4_general_ci</h3><ul><li><p>校对速度快，准确度稍差</p></li><li><p>一般语言用</p></li><li>不支持扩展</li></ul><h3 id="utf8mb4-unicode-ci"><a href="#utf8mb4-unicode-ci" class="headerlink" title="utf8mb4_unicode_ci"></a>utf8mb4_unicode_ci</h3><ul><li><p>校对速度稍慢，准确度高</p></li><li><p>含有德语、法语或俄语</p></li><li>支持扩展<ul><li>把一个字母看作与其它字母组合相等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中Text与Varchar</title>
      <link href="/MySQL/fieldType.html"/>
      <url>/MySQL/fieldType.html</url>
      
        <content type="html"><![CDATA[<p>MySQL中Text与Varchar的区别</p><a id="more"></a><p><code>Text</code></p><ul><li>固定长度：65535，无法修改</li><li>存储字符串长度<ul><li>占用2字节空间</li></ul></li><li>不能作为索引的一部分<ul><li>除了<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-fulltext-index.html" target="_blank" rel="external">fulltext</a> 类型索引</li></ul></li><li>不允许有默认值</li></ul><p><code>varchar(M)</code></p><ul><li>最大长度为M(1-65535)</li><li>存储字符串长度<ul><li>1字节：M≤ 255</li><li>2字节：256≤ M≤ 65535</li></ul></li><li>可以作为索引的一部分</li><li>允许有默认值</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8-Stream</title>
      <link href="/JDK/stream.html"/>
      <url>/JDK/stream.html</url>
      
        <content type="html"><![CDATA[<ul><li>Java8核心新特性<ul><li>Stream流</li><li>Optional</li><li>Lambda匿名函数</li><li>默认方法</li></ul></li></ul><p>本篇重点介绍Stream</p><a id="more"></a><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h3><blockquote><p>从支持数据处理操作的源，生成的元素序列</p><ul><li>元素序列：流提供接口，可以访问特定元素类型的一组有序值，流的目的在于表达计算</li><li>源：流会使用一个提供数据的源，如集合、数组或输入/输出资源</li><li>数据处理操作：提供类似于数据库的操作，以及函数式编程语言中的常用操作(filter、map、reduce、find、match、sort等)，串行或并行均支持</li><li>并行：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个流水线(可以进行延迟和短路等优化)</li><li>内部迭代：流的迭代操作是在后台进行的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * 返回低热量菜肴的名称，并按照卡路里排序</span></div><div class="line"><span class="comment">  * parallelStream():得到一个并行流</span></div><div class="line"><span class="comment">  * filter:过滤</span></div><div class="line"><span class="comment">  * map:将元素转换成其他形式或提取信息</span></div><div class="line"><span class="comment">  * limit:阶段流，使其元素不超过给定数量</span></div><div class="line"><span class="comment">  * sort:排序</span></div><div class="line"><span class="comment">  * collect:将流转换为其他形式</span></div><div class="line"><span class="comment">  */</span></div><div class="line">List&lt;String&gt; lowCaloricDishesName = </div><div class="line">menu.parallelStream()</div><div class="line">.filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)</div><div class="line">.sorted(comparing(Dishes::getCalories))</div><div class="line">.map(Dish::getName)</div><div class="line">.collect(toList());</div></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>声明性<ul><li>简洁易读</li><li>想要完成什么，而不是说明如何实现一个操作（利用循环和if条件等控制流语句）</li></ul></li><li>可复合：灵活</li><li>可并行：性能更好</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p><code>debug</code>时需要将将语句切换为多行(例如以<code>.</code>换行)才可以打断点</p></li><li><p>只能遍历一次</p><ul><li><code>s.forEach</code>第二次调用会报<code>java.lang.IllegalStateException: stream has already been operated upon or closed</code>异常</li></ul></li></ul><h4 id="与集合对比"><a href="#与集合对比" class="headerlink" title="与集合对比"></a>与集合对比</h4><ul><li>存储<ul><li>集合：内存中的数据结构，包含所有值</li><li>流：概念上固定的(不能添加或删除)</li></ul></li><li>计算时机<ul><li>集合：元素需先计算出来才能成为集合的一部分</li><li>流：按需计算，只有在有需要时才会计算值</li></ul></li><li>创建<ul><li>集合：急切创建，先装满再处理</li><li>流：延迟创建，需要时再计算值</li></ul></li><li>迭代<ul><li>集合：外部迭代(<code>for-each</code>)</li><li>流：内部迭代(透明并行、优化处理顺序)</li></ul></li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul><li>中间操作<ul><li>可以连接起来的流操作<ul><li><code>filter</code>、<code>map</code>、<code>limit</code></li></ul></li></ul></li><li>终端操作<ul><li>结果为不是流的值</li></ul></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><hr><h5 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h5><p><strong>筛选(distinct)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//2、4</span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">list.stream()</div><div class="line">    .filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">    .distinct()</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p><strong>截短流limit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//2    </span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</div><div class="line">list.stream()</div><div class="line">    .filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">    .limit(<span class="number">1</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><p><strong>跳过skip</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4        </span></div><div class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</div><div class="line">list.stream()</div><div class="line">    .filter(integer -&gt; integer % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">    .skip(<span class="number">2</span>)</div><div class="line">    .forEach(System.out::println);</div></pre></td></tr></table></figure><hr><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p><strong>map</strong></p><p>创建一个新版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; dishNames = menu.stream()</div><div class="line">    .map(Dish::getName)</div><div class="line">    .collect(toList());</div></pre></td></tr></table></figure><p><strong>flatmap</strong></p><p>将结果合并为一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; uniqueCharacters =</div><div class="line">    words.stream()</div><div class="line">         .map(w -&gt; w.split(<span class="string">""</span>))</div><div class="line">         .flatMap(Arrays::stream)</div><div class="line">         .distinct()</div><div class="line">         .collect(Collectors.toList());</div></pre></td></tr></table></figure><h5 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h5><ul><li>短路<ul><li>allMatch：流中的元素是否都能匹配</li><li>anyMatch：流中的元素是否有一个元素能匹配</li><li>noneMatch：确保流中没有任何元素匹配</li></ul></li><li>findFirst：返回第一个匹配的值（并行流上限制多）</li><li>findAny：返回任意匹配的值（并行流上限制少）</li></ul><h5 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h5><p><strong>元素求和</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reduce(初始值,BinaryOperator&lt;T&gt;来将两个元素结合起来产生一个新值)</span></div><div class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</div><div class="line"><span class="comment">// 代码更简洁</span></div><div class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</div><div class="line"><span class="comment">// Optional用于流中没有元素的情况</span></div><div class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</div></pre></td></tr></table></figure><p><strong>最大值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.stream().reduce(<span class="number">0</span>, Integer::max);</div></pre></td></tr></table></figure><p><strong>最小值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numbers.stream().reduce(<span class="number">0</span>, Integer::min);</div></pre></td></tr></table></figure><h4 id="流类型"><a href="#流类型" class="headerlink" title="流类型"></a>流类型</h4><blockquote><p>数值流、多种来源流(文件、数组)、无限流</p></blockquote><h5 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h5><blockquote><p>避免暗含的装箱成本</p></blockquote><ul><li><code>IntStream</code>：<code>mapToInt</code>、<code>OptionalInt</code></li><li><code>DoubleStream</code>：<code>mapToDouble</code>、<code>OptionalDouble</code></li><li><code>LongStream</code>：<code>mapToLong</code>、<code>OptionalLong</code></li></ul><blockquote><p>数值流转换为一般流可用<code>boxed()</code>方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</div></pre></td></tr></table></figure><p><strong>数值范围</strong></p><ul><li>可用于<code>IntStream</code>和<code>LongStream</code><ul><li><code>range</code>：不包含结束值</li><li><code>rangeClosed</code>：包含结束值</li></ul></li></ul><h5 id="多种来源流-文件、数组"><a href="#多种来源流-文件、数组" class="headerlink" title="多种来源流(文件、数组)"></a>多种来源流(文件、数组)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建流</span></div><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java"</span>, <span class="string">"Lambdas"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 创建空流</span></div><div class="line">Stream&lt;String&gt; stream = Stream.empty();</div><div class="line"></div><div class="line"><span class="comment">// 数组创建流</span></div><div class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</div><div class="line"></div><div class="line"><span class="comment">// 由文件创建流</span></div><div class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</div><div class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">"data.txt"</span>), Charset.defaultCharset()))&#123;</div><div class="line">    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">""</span>))).distinct().count();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="无限流"><a href="#无限流" class="headerlink" title="无限流"></a>无限流</h5><ul><li><code>Stream.iterate</code><ul><li>需要依次生成一系列值<ul><li>斐波那契数列</li></ul></li><li>对象无可变状态</li></ul></li></ul><p><strong>应该使用limit(n)来对流加以限制，防止一直计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</div><div class="line">      .limit(<span class="number">10</span>)</div><div class="line">      .forEach(System.out::println);</div></pre></td></tr></table></figure><ul><li><code>Stream.generate</code><ul><li>按需生成</li><li>对象有可变的状态</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stream.generate(Math::random)</div><div class="line">         .limit(<span class="number">5</span>)</div><div class="line">         .forEach(System.out::println);</div></pre></td></tr></table></figure><h4 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h4><h5 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h5><ul><li>Collection<ul><li>Java集合的祖先接口</li></ul></li><li>Collections<ul><li><code>java.util</code>包下的工具类</li><li>内置各种处理集合的静态方法</li></ul></li><li>Collector<ul><li>接口</li><li>创建常见常见收集器实例<ul><li><code>Collectors.counting()</code>：计数</li><li><code>Collectors.maxBy()</code>：求最大</li><li><code>Collectors.minBy()</code>：求最小</li><li><code>Collectors.summingInt()</code>：汇总</li><li><code>Collectors.averaginInt()</code>：求平均值</li><li><code>Collectors.joining()</code>：拼接字符串</li><li><code>Collectors.reducing(startValue, lambda, BinaryOperator)</code>：规约</li><li><code>Collectors.groupingBy(lambda)</code>：分组</li><li><code>Collectors.partitioningBy(lambda)</code>：分区</li></ul></li><li>功能<ul><li>将流元素规约和汇总为一个值</li><li>元素分组</li><li>元素分区</li></ul></li><li><code>Collectors.toList()</code></li></ul></li><li>collect<ul><li><code>java.util.stream.Stream#collec</code></li><li>负责收集流</li><li>适合表达可变容器上的规约</li></ul></li><li>Collections<ul><li>集合类的工具类<ul><li>排序</li><li>搜索</li></ul></li></ul></li></ul><hr><ul><li>Optional<ul><li>isPresent()：包含值的时候返回true，否则返回false</li><li>get()：在值存在时返回，否则抛出一个<code>NoSuchElement</code>异常</li><li>orElse(T other)：会在值存在时返回，否则返回一个默认值</li></ul></li></ul><hr><ul><li>处理流的方式分为惰性求值和及早求值，对流的处理通常包括一系列的惰性求值和一个及早求值，流遇到及早求值时，才会真正的遍历和执行</li><li>函数式编程时，函数应该是没有副作用的，对象不应该被修改，如果需要修改对象，则采用map方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法调用</title>
      <link href="/JVM/callMethod.html"/>
      <url>/JVM/callMethod.html</url>
      
        <content type="html"><![CDATA[<p>方法调用阶段唯一的任务就是确定被调用方法的版本(即调用的是哪一个方法)</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的只是符号引用，而不是方法在时机运行时内存布局中的入口地址(直接引用)，这就是Java语言动态扩展能力的基础，代价是Java方法调用过程变得相对复杂，需要在类加载期间，甚至运行期间才能确定目标方法的直接引用。</p><h3 id="解析Resolution"><a href="#解析Resolution" class="headerlink" title="解析Resolution"></a>解析Resolution</h3><blockquote><p>调用目标在程序代码写好、编译器进行编译时就必须确定下来，静态过程</p></blockquote><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li>与类型直接关联</li><li>不能通过继承或其他方式重写，在类加载阶段进行解析</li></ul><h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><ul><li>外部不可访问</li><li>不能通过继承或其他方式重写，在类加载阶段进行解析</li></ul><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p><strong>分派逻辑固化在JVM内部</strong></p><ul><li><code>invokestatic</code>：调用静态方法</li><li><code>invokespecial</code>：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li><li><code>invokevirtual</code>：调用所有的虚方法</li><li><code>invokeinterface</code>：调用接口方法，会在运行时确定一个实现此接口的对象</li></ul><p><strong>分派逻辑由用户所设定的引导方法决定</strong></p><ul><li><code>invokedynamic</code>：先在运行时动态解析出调用点限定符所引用的方法然后再执行改方法</li></ul><blockquote><p>非虚方法：</p><ul><li><code>invokestatic</code>和<code>invokespecial</code>指令调用的方法、final修饰的方法</li><li>可以在解析阶段确定唯一的调用版本</li><li>在类加载阶段把方法的符号引用解析为直接引用</li></ul><p><strong>final修饰的方法虽然用<code>invokevirtual</code>指令调用，但是由于它无法被覆盖，保证了方法的唯一性</strong></p><p>虚方法：</p><p>除去非虚方法之外的</p></blockquote><h3 id="分派Dispatch"><a href="#分派Dispatch" class="headerlink" title="分派Dispatch"></a>分派Dispatch</h3><blockquote><ul><li>可静态可动态</li><li>根据宗量数分为：单分派、多分派</li><li>静态单分派、静态多分派、动态单分派、动态多分派</li><li>Java语言多态性特征的基本体现</li></ul></blockquote><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><blockquote><p>Method Overload Resolution，依赖静态类型来定位方法执行版本的分派动作，典型应用是方法重载，发生在编译阶段。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human h)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello human"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man h)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Man"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman h)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"hello Woman"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//Human为变量的静态类型Static Type或外观类型Apparent Type</span></div><div class="line">        <span class="comment">//Man为变量的实际类型Actual Type</span></div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line"></div><div class="line">        StaticDispatch s = <span class="keyword">new</span> StaticDispatch();</div><div class="line">        <span class="comment">//hello human</span></div><div class="line">        s.sayHello(man);</div><div class="line">        <span class="comment">//hello human</span></div><div class="line">        s.sayHello(woman);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>变量的静态类型和实际类型在程序中都可以发生变化，但静态类型的变化仅仅在使用时发生，不会改变，编译器可知；实际类型变化虚在运行期确定。编译器通过参数的静态类型确定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 实际类型变化</span></div><div class="line">&gt; Human man = <span class="keyword">new</span> Man();</div><div class="line">&gt; man = <span class="keyword">new</span> Woman();</div><div class="line">&gt; <span class="comment">// 静态类型变化</span></div><div class="line">&gt; s.sayHello((Woman) man);</div><div class="line">&gt; s.sayHello((Man) man);</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><blockquote><p>在运行期根据实际类型确定方法执行版本的分派过程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"man say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"woman say hello"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line">        <span class="comment">//man say hello</span></div><div class="line">        man.sayHello();</div><div class="line">        <span class="comment">//woman say hello</span></div><div class="line">        woman.sayHello();</div><div class="line">        man = <span class="keyword">new</span> Woman();</div><div class="line">        <span class="comment">//woman say hello</span></div><div class="line">        man.sayHello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sayHello()</code>方法使用<code>invokeVirtual</code>指令来完成方法调用，<code>invokeVirtual</code>指令的运行时解析过程为</p><ul><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，计作C</li><li>在类型C中找到与常量中的描述符和简单名称都相符的方法<ul><li>找到<ul><li>进行访问权限校验，通过则返回这个方法的直接引用，查找过程结束</li></ul></li><li>没有找到<ul><li>返回<code>java.lang.IllegalAccessError</code>异常</li></ul></li></ul></li><li>按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程</li><li>都没有找到，抛出<code>java.lang.AbstractMethodError</code>异常</li></ul><blockquote><ul><li>Java语言中方法重写的本质：<code>invokeVirtual</code>指令<ul><li>在运行期确定接受者的实际类型，把常量池中的类方法符号引用解析道了不同的直接引用上</li></ul></li></ul></blockquote><h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><blockquote><p>宗量：方法的接受者、参数</p><p>单分派：根据一个宗量对目标方法进行选择</p><p>多分派：根据多于一个对目标方法进行选择</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"father choose _360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choose qq"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"son choose _360"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Father father = <span class="keyword">new</span> Father();</div><div class="line">        Father son = <span class="keyword">new</span> Son();</div><div class="line">        <span class="comment">//father choose _360</span></div><div class="line">        father.hardChoice(<span class="keyword">new</span> _360());</div><div class="line">        <span class="comment">//son choose qq</span></div><div class="line">        son.hardChoice(<span class="keyword">new</span> QQ());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><ul><li>编译阶段进行静态分派时，依据静态类型及参数，会生成两条<code>invokeVirtual</code>指令，分别指向<code>Father.hardChoice(QQ)</code>和<code>Father.hardChoice(_360)</code>方法的符号引用。因为是根据两个宗量进行选择，所以静态分派属于多分派类型</li><li>运行期进行动态分派时，在执行<code>son.hardChoice(new QQ());</code>语句时，由于编译期已经决定方法签名必须为<code>hardChoice(QQ)</code>，唯一可以影响虚拟机选择的因素只有方法接受者的实际类型，因为是根据一个宗量进行选择，所以动态分派属于单分派类型</li></ul></blockquote><h4 id="JVM动态分派实现"><a href="#JVM动态分派实现" class="headerlink" title="JVM动态分派实现"></a>JVM动态分派实现</h4><ul><li>动态分派的版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，JVM基于性能考虑，在类的方法区中建立一个虚方法表(Virtual Method Table,vTable)，使用虚方法表索引来代替元数据查找。</li><li>虚方法表中存放着各个方法的时机入口地址<ul><li>方法在子类中没有被重写<ul><li>子类的虚方法表中的地址入口和父类的入口一致，都指向父类的实现入口</li></ul></li><li>方法在子类中被重写<ul><li>子类方法表中的地址将会替换为指向子类实现版本的入口地址</li></ul></li></ul></li></ul><blockquote><p>JVM优化手段</p><ul><li>稳定优化<ul><li>方法表</li></ul></li><li>激进优化<ul><li>内联缓存(Inline Cache)</li><li>守护内联(Guarded Inlining)：基于“类型继承关系分析(Class Hirarchy Analysis,CHA)”技术</li></ul></li></ul></blockquote><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>JDK7新增<code>invokeDynamic</code>指令，是实现”动态类型语言Dynamically Typed Language”支持而做的改进之一，也是为JDK8可以实现Lambda表达式做的技术准本。</p><h4 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h4><blockquote><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期，变量无类型而变量值才有类型也是重要特征之一。</p></blockquote><p>静态类型语言在编译期确定类型，利于稳定性及代码达到更大规模；</p><p>动态类型语言在运行期确定类行，实现会更加清晰简洁，提升开发效率。</p><h4 id="java-lang-invoke包"><a href="#java-lang-invoke包" class="headerlink" title="java.lang.invoke包"></a><code>java.lang.invoke</code>包</h4><p>JDK 1.7实现JSR-292，新增<code>java.lang.invoke</code>包，目的是提供一种新的动态确定目标方法的机制，称为MethodHandle。这样一来，Java语言也可以拥有类似于函数指针或委托的方法别名的工具了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.invoke.MethodHandles.lookup;</div><div class="line"><span class="keyword">import</span> java.lang.invoke.MethodHandle;</div><div class="line"><span class="keyword">import</span> java.lang.invoke.MethodType;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String a)</span> </span>&#123;</div><div class="line">            System.out.println(a);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * MethodHandleTest$ClassA或java.io.PrintStream</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</div><div class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"super2bai"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object receiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// 方法返回值，具体参数</span></div><div class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span>.class, String.class);</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * lookup(): MethodHandles.lookup(), 在指定类中查找符合给定方法名称、方法类型，并且符合调用权限的方法句柄</span></div><div class="line"><span class="comment">         * findVirtual: 调用虚方法, 参数: 方法接收者, 方法名字, 方法类型</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> lookup().findVirtual(receiver.getClass(), <span class="string">"println"</span>, mt).bindTo(receiver);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>MethodHandle</code>与<code>Reflection</code>都是模仿方法调用，区别为</p><ul><li>层次<ul><li><code>MethodHandle</code>：模拟字节码层次的方法调用<ul><li><code>MethodHandles.lookup()</code>中的<code>findStatic()</code>、<code>findVirtual()</code>和<code>findSpecial</code>分别对应指令<code>invokestatic</code>、<code>invokevirtual&amp;invokeinterface</code>和<code>invokespecial</code>这几条字节码指令的执行权限校验行为，这些底层细节在使用<code>Reflction</code>时是不需要关心的</li></ul></li><li><code>Reflection</code>：模拟Java代码层次的方法调用</li></ul></li><li>包含信息<ul><li><code>MethodHandle</code>：轻量级<ul><li><code>java.lang.invoke.MethodHandle</code>仅包含与执行该方法相关的信息</li></ul></li><li><code>Reflection</code>：重量级<ul><li><code>java.lang.reflect.Method</code>对象是方法在Java一端的全面映像，包含方法签名、描述信符和方法属性表以及运行权限等运行时信息</li></ul></li></ul></li><li>优化<ul><li><code>MethodHandle</code>：对字节码的方法指令调用的模拟，一些优化手段诸如方法内联，可以采用类似思路支持</li><li><code>Reflection</code>：不支持</li></ul></li><li>支持语言<ul><li><code>MethodHandle</code>：可服务于所有JVM支持的语言</li><li><code>Reflection</code>：仅支持Java</li></ul></li></ul><h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a><code>invokedynamic</code>指令</h4><blockquote><p><code>invokedynamic</code>与<code>MethodHandle</code>机制的作用是一样的，都是为了解决原有4条<code>invoke*</code>指令方法分派规则固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码中。二者思路也相同，一个用上层Java代码和API来实现，另一个用字节码和Class中其他属性、常量来完成。</p><p>动态调用点Dynamic Call Site：每一处含有<code>invokedynamic</code>指令的位置</p></blockquote><ul><li>指令第一个参数为<code>CONSTANT_InvokeDynamic_info</code>常量<ul><li>可以得到引导方法(Bootstrap Method)、方法类型和名称<ul><li>引导方法：存放在新增的BootstrapMethods属性中，固定参数，返回值为<code>java.lang.invoke.CallSite</code>对象，代表真正要执行的目标方法调用</li></ul></li></ul></li></ul><p>根据上述信息，JVM可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用要执行的目标方法。</p><h4 id="方法分派规则"><a href="#方法分派规则" class="headerlink" title="方法分派规则"></a>方法分派规则</h4><p><code>invokedynamic</code>指令与其他4条<code>invoke*</code>指令的最大区别就是分派逻辑是程序员决定的，不再固化在虚拟机中。</p><p><del>新公司太忙了。。。导致好久都没有更新，一直在忙于熟悉新公司的业务，对不住了您内</del></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html#jvms-5.4.3" target="_blank" rel="external">JVM Specifications- Linking</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时栈帧结构</title>
      <link href="/JVM/stackFrame.html"/>
      <url>/JVM/stackFrame.html</url>
      
        <content type="html"><![CDATA[<p>执行引擎是Java虚拟机最核心的部分。</p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><strong>虚拟机与物理机在执行代码时，执行引擎的区别</strong></p><ul><li>物理机<ul><li>直接建立在处理器、硬件、指令集和操作系统层面上的</li></ul></li><li>虚拟机<ul><li>自己实现，可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式</li></ul></li></ul><hr><p><strong>Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，大体分为</strong></p><ul><li>解释执行<ul><li>通过解释器执行</li></ul></li><li>编译执行<ul><li>通过即时编译器产生本地代码</li></ul></li></ul><hr><p>执行引擎流程：字节码文件&gt; 字节码解析&gt; 执行效果</p><h3 id="栈帧Stack-Frame"><a href="#栈帧Stack-Frame" class="headerlink" title="栈帧Stack Frame"></a>栈帧Stack Frame</h3><blockquote><p>用于支持虚拟机进行方法调用和方法执行的数据结构。是虚拟机栈的栈元素</p></blockquote><h4 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h4><p>方法的局部变量表、操作数栈、动态连接和方法返回地址和附加信息。</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>在编译时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的<a href="https://super2bai.github.io/JVM/classDetail2.html#%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88">Code属性</a>之中，因此一个栈帧需要分配多少内存，不会收到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p><blockquote><p><strong>当前栈帧</strong>：位于栈顶的栈帧。</p></blockquote><p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态，对于执行引擎来说，只有当前栈帧才是有效的，与之关联的方法称为当前方法。</p><p>执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><blockquote><p>Local Cariable Table ，一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p></blockquote><h4 id="最大容量"><a href="#最大容量" class="headerlink" title="最大容量"></a>最大容量</h4><p>在Java程序编译为Class文件时，就在方法的Code属性的<code>max-locals</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>变量槽(Variable Slot)为最小单位，虚拟机规范要求每个Slot必须能存放一个<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>float</code>、<code>reference</code>或<code>returnAddress</code>类型的数据，一个Slot占用内存大小具体取决于虚拟机实现。</p><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li>前六种可以按照Java语言去理解，但注意Java语言和JVM中的虚拟机类型时存在本质差别的</li><li><code>reference</code>：对象实例的引用<ul><li>JVM规范没有要求长度(32、64)、结构</li><li>需要保证两点<ul><li>从此引用中查找到对象在Java堆中的数据存放的起始地址索引</li><li>此引用中查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束</li></ul></li></ul></li><li><code>returnAddress</code>：指向一条字节码指令的地址<ul><li>为指令<code>jsr</code>、<code>jsr_w</code>、<code>ret</code>服务</li><li><strong>异常处理，现已用异常表代替</strong></li></ul></li><li><p>对于64位的数据类型，JVM会以<strong>高位对齐</strong>的方式为其分配两个连续的Slot空间</p><ul><li>局部变量表是建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起线程安全问题</li></ul></li><li><p>JVM使用<strong>索引定位</strong>的方式使用局部变量表(0-最大Slot)</p><ul><li>32位：n</li><li>64位：n、n+1<ul><li>不允许采用任何方式单独访问其中的某一个，否则在类加载的校验阶段抛异常</li></ul></li></ul></li><li><p>方法执行时，JVM使用局部变量表完成参数值到参数变量列表的传递过程</p><ul><li>实例方法(非static)：<ul><li>0：方法所属的实例对象的引用(this)</li><li>其余按照参数表顺序排列</li><li>再分配方法内的变量(顺序、作用域)</li></ul></li></ul></li><li><p>Slot可复用</p><ul><li>PC计数器的值超过变量的作用域，那此变量的Slot就可以交给其他变量使用</li><li>优点：节省栈帧空间</li><li>缺点：影响垃圾收集行为</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 例子1:</span></div><div class="line"><span class="comment"> * placeHolder在gc后未被回收</span></div><div class="line"><span class="comment"> * 原因：局部变量表还存有placeHolder的引用</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[] placeHolder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</div><div class="line">System.gc()</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 例子2:</span></div><div class="line"><span class="comment"> * placeHolder在gc后被回收</span></div><div class="line"><span class="comment"> * 更佳做法：</span></div><div class="line"><span class="comment"> * 控制恰当的作用域来控制变量回收时间</span></div><div class="line"><span class="comment"> * 补充：</span></div><div class="line"><span class="comment"> * 如果经过JIT编译优化，是无需手动赋null就可以被回收</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&#123;</div><div class="line"><span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">placeHolder = <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">System.gc();</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 例子3:</span></div><div class="line"><span class="comment"> * placeHolder在gc后被回收</span></div><div class="line"><span class="comment"> * 原因：局部变量表被读写</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">&#123;</div><div class="line"><span class="keyword">byte</span>[] placeHolder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">System.gc()</div></pre></td></tr></table></figure><ul><li>局部变量表中的变量如果声明了但未被赋值是无法使用的<ul><li>类变量会在“准备阶段”赋系统初始值，在“初始化阶段”赋用户指定的值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="comment">//编译器报错</span></div><div class="line">    System.out.println(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><blockquote><p>算术计算时临时数据的存储区域；调用其他方法时进行参数传递</p></blockquote><h4 id="存储内容-1"><a href="#存储内容-1" class="headerlink" title="存储内容"></a>存储内容</h4><p>虚拟机在操作数栈中存储数据的类型和在局部变量区中是一样的:如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前,会被转换为int</p><h4 id="最大容量-1"><a href="#最大容量-1" class="headerlink" title="最大容量"></a>最大容量</h4><p>在Java程序编译为Class文件时，就在方法的Code属性的<code>max-stacks</code>数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>后进先出LIFO栈，访问方式通过入栈出栈</li></ul><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li><p>当一个方法开始执行时，操作数栈是空的，会有各种字节码指令往操作数栈中写入和提取内容(入栈、出栈)</p><ul><li>例如：加法的字节码指令<code>iadd</code>在运行时操作数栈中最接近栈顶的两个元素已经存入了两个<code>int</code>型的数值，当执行指令时，将两个<code>int</code>值出栈相加后，再将结果入栈</li></ul></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配</p><ul><li>不能出现一个<code>long</code>和一个<code>float</code>使用<code>iadd</code>命令相加</li><li>编译器在编译时期验证</li><li>类校验阶段的数据流分析中再次验证</li></ul></li><li><p>概念模型中，操作数栈相互独立；但虚拟机实现中会有一部分重叠来达到在方法调用时共用数据的目的</p></li></ul><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><blockquote><p>保存指向运行时常量池中该栈帧所属方法的引用，在<strong>运行期间</strong>将符号引用转化为直接引用</p></blockquote><ul><li><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，作用就是为了支持方法调用过程中的动态链接(Dynamic Linking)。</p></li><li><p>静态连接：符号引用一部分会在<strong>类加载阶段</strong>或者<strong>第一次使用时</strong>转化为直接引用</p></li><li><p>此处只介绍概念，详情之后会补充。</p></li></ul><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><blockquote><p>保留一些退出方法时，上层方法(调用者)执行状态的信息</p></blockquote><h4 id="退出方法方式"><a href="#退出方法方式" class="headerlink" title="退出方法方式"></a>退出方法方式</h4><ul><li>正常完成出口<ul><li>执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层的方法调用者(是否有返回值及类型取决于退出的方法返回指令)</li><li>调用者的PC计数器的值可以作为返回地址，栈帧中很有可能会保存这个值</li></ul></li><li>异常完成出口<ul><li>在方法执行过程中遇到了异常，并且没有在方法体内得到处理（虚拟机异常、<code>athrow</code>字节码指令），不会有返回值</li><li>异常处理表来确定返回地址，栈帧中不会保存</li></ul></li></ul><h4 id="退出方法操作"><a href="#退出方法操作" class="headerlink" title="退出方法操作"></a>退出方法操作</h4><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>如果有返回值，将返回值压入调用者栈帧的操作数栈中</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li></ul><h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><ul><li>虚拟机规范允许具体实现中增加规范中没有描述的信息到栈帧之中<ul><li>调试相关的信息</li></ul></li><li>栈帧信息：动态连接、方法返回地址、附加信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="/JVM/clzloader.html"/>
      <url>/JVM/clzloader.html</url>
      
        <content type="html"><![CDATA[<p>是时候介绍一下那些把Java类加载到内存中的家伙了</p><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>实现“通过一个类的全限定名来获取描述此类的二进制字节流”的代码模块</p></blockquote><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Java语言的创新，领域包括：</p><ul><li><p>类层次划分</p></li><li><p>OSGi(Open Service Gateway Initiative)</p><ul><li>Java动态化模块化系统的一系列规范</li><li>支持模块热部署，方便模块管理</li></ul></li><li><p>热部署</p></li><li><p>代码加密</p></li></ul><h3 id="类与加载器"><a href="#类与加载器" class="headerlink" title="类与加载器"></a>类与加载器</h3><blockquote><p> 对于任意一个类，都需要由加载它的<strong>类加载器</strong>和<strong>这个类本身</strong>一同确定其在JVM中的<strong>唯一性</strong></p></blockquote><ul><li>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义<ul><li>相同Class文件</li><li>同一个JVM加载</li><li>不同类加载器加载</li><li><strong>必定不相等</strong><ul><li>Class对象的<code>equal()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code></li></ul></li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>启动类加载器Bootstrap ClassLoader</p><ul><li>C++实现</li><li>虚拟机自身的一部分</li></ul></li><li><p>其他类加载器(扩展类加载器Extension ClassLoader、应用程序类加载器Application ClassLoader)</p><ul><li>Java实现</li><li>独立于虚拟机</li><li>继承抽象类<code>java.lang.ClassLoader</code></li></ul></li></ul><h4 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h4><ul><li><p>加载路径</p><ul><li><code>&lt;JAVA_HOME&gt;\lib</code></li><li><code>-Xbootclasspath</code>指定的路径中被虚拟机识别的(按名称)</li></ul></li><li><p>说明</p><ul><li>无法被Java程序直接引用<ul><li>自定义加载器时，如果想使用此加载器加载，直接使用<code>null</code>即可</li></ul></li></ul></li></ul><h4 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h4><ul><li>加载路径<ul><li><code>&lt;JAVA_HOME&gt;\lib\ext</code></li><li><code>java.ext.dirs</code>系统变量指定的路径中所有类库</li></ul></li><li>说明<ul><li>可以被Java程序直接使用</li><li><code>sun.misc.Launcher$ExtClassLoader</code>实现</li></ul></li></ul><h4 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h4><ul><li>加载路径<ul><li>用户类路径<code>ClassPath</code>所指定的类库</li></ul></li><li>说明<ul><li>可以被Java程序直接使用</li><li><code>sun.misc.Launcher$AppClassLoader</code>实现</li><li>ClassLoader中<code>getSystemClassLoader()</code>方法的返回值</li><li>如果没有自定义过类加载器，则默认此类加载器</li></ul></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul><li>启动类加载器Bootstrap ClassLoader<ul><li>扩展类加载器Extension ClassLoader<ul><li>应用程序类加载器Application ClassLoader<ul><li>自定义类加载器User ClassLoader</li><li>自定义类加载器User ClassLoader</li></ul></li></ul></li></ul></li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>除了顶层的启动类加载器外，其余皆有父类加载器</li><li>父子是组合(Composition)关系</li><li>JDK 1.2+</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>一个类加载器收到类加载的请求</li><li>逐层委派给父类加载器完成</li><li>传送到顶层的启动类加载器中</li><li>父类加载器没有找到时，子类加载器尝试自己加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//java.lang.ClassLoader#loadClass</span></div><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">            <span class="comment">// 首先，检查此类是否已经被加载过</span></div><div class="line">            Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123; </div><div class="line">                        c = findBootstrapClassOrNull(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                    <span class="comment">// 父类加载器未找到则抛出ClassNotFoundException异常</span></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// 父类加载器无法加载时，自己才加载</span></div><div class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                    c = findClass(name);</div><div class="line"></div><div class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (resolve) &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>Java类随着类加载器一起具备了一种带有优先级的层次关系</li><li>保证了Java程序的稳定运行</li></ul><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><h4 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass()"></a>loadClass()</h4><ul><li><p>在JDK 1.2之前，双亲委派模型出现前，用户继承<code>java.lang.ClassLoader</code>唯一目的就是重写<code>loadClass()</code>方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法<code>loadClassInternal()</code>，也就是调用自己的<code>loadClass()</code>。</p></li><li><p>双亲委派模型出现在JDK 1.2，而类加载器和抽象类<code>java.lang.ClassLoader</code>在JDK 1.0就有，为了向前兼容，在JDK 1.2中的<code>java.lang.ClassLoader</code>增加了<code>protected</code>的<code>findClass()</code>方法，应当把自定义的类加载逻辑写到这个方法中，在<code>loadClass()</code>里，如果父加载器加载失败，则会调用自己的<code>findClass()</code>方法来完成加载，可以保证自定义的类加载器是符合双亲委派模型。</p></li></ul><h4 id="自身缺陷"><a href="#自身缺陷" class="headerlink" title="自身缺陷"></a>自身缺陷</h4><p>基础类是作为被用户代码调用的API，但如果需要回调用户的代码时，Bootstrap ClassLoader不认识这些代码也就无法完成加载动作，怎么办呢？ 例如JNDI服务</p><blockquote><p>JNDI服务：</p><ul><li>JDK 1.3 ：rt.jar</li><li>对资源进行集中管理和查找</li><li>需要调用独立厂商实现并部署在应用程序的<code>ClassPath</code>下的JNDI接口提供者(SPI)的代码</li></ul></blockquote><p>这时候就需要线程上下文类加载器(Thread Context ClassLoader) 来载入需要的Class</p><ul><li>通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置</li><li>创建线程时未设置，则从父线程中继承</li><li>如果全局都没有设置，默认为Application ClassLoader</li></ul><p>线程上下文类加载器其实就是父类加载器委托子类加载器完成加载动作</p><ul><li>父类加载器可以获得当前线程的Context ClassLoader，可能是它的子类加载器也可能是其他类加载器，父类加载器可以从其获得所需的Class，也就打破了只能向父类加载器请求的限制。</li></ul><p>这个机制就满足了classpath是在运行时才确定，并且由定制的类加载器加载。由Application ClassLoader加载的class可以通过Thread Context ClassLoader获得定制的类加载器并载入特定的Class。</p><p><strong>Java中所有涉及SPI的加载动作基本都采用这种方式，如JNDI、JDBC、JCE、JAXB和JBI等</strong></p><h4 id="追求程序的动态性"><a href="#追求程序的动态性" class="headerlink" title="追求程序的动态性"></a>追求程序的动态性</h4><blockquote><p>动态性：代码热替换HotSwap、模块热部署(Hot Deployment)</p></blockquote><p>模块化之争：</p><ul><li><p>Sun</p><ul><li><code>JSR-294</code>(Java语言改进的模块化支持)</li><li><code>JSR-277</code>(Java模块化系统)</li></ul></li><li><p>JCP</p><ul><li><a href="https://jcp.org/en/jsr/detail?id=291" target="_blank" rel="external">JSR-291(OSGI R4)</a></li></ul></li></ul><p>最终，JCP赢了。不知道OSGI是啥，<a href="http://osgi.com.cn/article/7289372" target="_blank" rel="external">请看这篇文章</a></p><blockquote><p>OSGI联盟给出的最新OSGI定义是The Dynamic Module System for Java，即面向Java的动态模块化系统。</p><p>OSGI实现模块化热部署的关键是自定义的类加载器机制的实现。</p><p>也就是说，每一个程序模块(Bundle)都有独自的类加载器，当需要更换一个Bundle时，就把Bundle和类加载器一起换掉，实现代码的热替换。</p></blockquote><p>OSGI使用更为复杂的网状结构，不使用双亲委派模型的树状接口。</p><ul><li>当收到类加载请求时，OSGI对类搜索的操作<ul><li>将以<code>java.*</code>开头的类委派给父类加载器加载</li><li>否则，将委派列表名单内的类委派给父类加载器</li><li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载</li><li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li><li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li><li>否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载</li><li>否则，类查找失败</li></ul></li></ul><p><strong>想掌握类加载器的精髓，就搞懂OSGI的实现吧</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载的过程</title>
      <link href="/JVM/clzloadpcs.html"/>
      <url>/JVM/clzloadpcs.html</url>
      
        <content type="html"><![CDATA[<p>类加载的全过程，加载、验证、准备、解析和初始化</p><a id="more"></a><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul><li>JVM要完成<ul><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li></ul></li></ul><h4 id="获取二进制字节流"><a href="#获取二进制字节流" class="headerlink" title="获取二进制字节流"></a>获取二进制字节流</h4><ul><li>二进制来源可以有多种<ul><li>zip：JAR、EAR、WAR</li><li>网络：Applet</li><li>运行时计算生成：动态代理</li><li>其他文件生成：：JSP</li><li>数据库：中间件服务器(SAP Netweaver)把程序安装到数据库中来完成程序代码在进群间的分发</li><li>…</li></ul></li><li>非数组类的类加载器<ul><li>系统提供的引导类加载器</li><li>自定义的类加载器(重写一个类加载器的<code>loadClass()</code>方法)</li></ul></li><li>数组类<ul><li>由JVM直接创建</li><li>数组类的元素类型(去除所有维度的类型)最终时要靠类加载器去创建</li><li>创建过程原则<ul><li>如果数组的组件类型(Componen Type,去除一个维度的类型)是引用类型，那就递归采用默认加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识</li><li>如果数组的组件类型不是引用类型(如<code>int[]</code>)，JVM将会把数组C标记为与引导类加载器关联</li><li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public</li></ul></li></ul></li></ul><blockquote><p>加载阶段完成后</p><ul><li>JVM外部的二进制字节流就按照JVM所需的格式存储在方法区之中(格式自定义，JVM规范未规定)</li><li>内存中实例化一个<code>java.lang.Class</code>类的对象，作为程序访问这些类型数据的外部接口</li></ul></blockquote><p><strong>加载阶段与连接阶段的部分内容是交叉进行的，但开始时间是固定的先后顺序</strong></p><h3 id="连接-验证"><a href="#连接-验证" class="headerlink" title="连接(验证)"></a>连接(验证)</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><h5 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h5><ul><li><p>字节流是否符合Class文件格式的规范</p><ul><li>能够正常解析及存储在方法区内，格式上符合描述一个Java类型信息的要求</li></ul></li><li><p>能被当前版本的虚拟机处理</p></li></ul><h5 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h5><p>基于二进制字节流</p><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul><li>是否以0xCAFEBABE开头</li><li>主、次版本号是否在当前虚拟机处理范围之内</li><li>常量池的常量中是否有不被支持的常量类型(检查常量tag标志)</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTATNT_Utf8_info型的常量中是否有不符合UFT8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的信息</li><li>…</li></ul><h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><h5 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h5><p>保证其描述的信息符合Java语言规范的要求</p><h5 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h5><p>类的元数据(字节码描述的信息进行语义分析)</p><h5 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h5><ul><li>这个类是否有父类</li><li>父类是否即成了不允许被继承(final)的类</li><li>这个类如果不是抽象类，是否实现了父类或接口之中要求实现的所有方法</li><li>类中的字段、方法是否与父类产生矛盾(覆盖父类的final字段、不合法的方法重载)</li></ul><h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><h5 id="目的-3"><a href="#目的-3" class="headerlink" title="目的"></a>目的</h5><p>通过数据流和控制流分析，确保语义是合法的、符合逻辑的</p><h5 id="对象-2"><a href="#对象-2" class="headerlink" title="对象"></a>对象</h5><p>类的方法体</p><h5 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h5><ul><li><p>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作</p><ul><li>操作数栈int类型，使用时却按long类型加载到本地变量表之中</li></ul></li><li><p>保证跳转指令不会跳转到方法体以外的字节码指令上</p></li><li>保证方法体中的类型转换是有效的<ul><li>可以把一个子类对象赋值给父类，是安全的，反之不安全</li></ul></li></ul><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。通过程序去校验程序逻辑是无法做到绝对准确的。</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>方法体的Code属性的属性表增加<code>StackMapTable</code>属性。</p><p>它描述了方法体中所有的基本块开始时本地变量表和操作数栈应有的状态，在字节码验证器件，就不需要推导这些状态的合法性，只需要检查表中的状态是否合法即可。</p><p>具体可参考<a href="http://hllvm.group.iteye.com/group/topic/26545" target="_blank" rel="external">R大的回答</a></p><h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><h5 id="目的-4"><a href="#目的-4" class="headerlink" title="目的"></a>目的</h5><p>对类自身以外的信息(常量池中的各种符号引用)进行匹配行校验，确保解析动作能正常执行，否则抛出<code>java.lang.IncompatibleClassChangeError</code>异常的子类</p><h5 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h5><p>将符号引用转化(解析时转化)为直接引用时</p><h5 id="对象-3"><a href="#对象-3" class="headerlink" title="对象"></a>对象</h5><p>符号引用</p><h5 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h5><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>在执行类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性是否可被当前类访问</li><li>…</li></ul><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5><p>可通过<code>-Xveerify:none</code>参数关闭大部分类验证措施，缩短类加载时间</p><h3 id="连接-准备"><a href="#连接-准备" class="headerlink" title="连接(准备)"></a>连接(准备)</h3><h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><ul><li>正式为类变量(static)分配内存(方法区)<ul><li>实例变量将随着对象一起分配在Java堆中</li></ul></li><li>设置类变量初始值(默认值，如int为0)<ul><li>赋值操作(<code>putstatic</code>指令)在程序被编译后，存放于类构造器<code>&lt;clinit&gt;</code>方法中，也就是初始化阶段</li></ul></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</div></pre></td></tr></table></figure><p>符合上述描述，此阶段赋值为0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value=<span class="number">123</span>;</div></pre></td></tr></table></figure><p>准备阶段变量<code>value</code>就会被初始化为<code>ConstatntCalue</code>属性所指定的值(123)</p><h3 id="连接-解析"><a href="#连接-解析" class="headerlink" title="连接(解析)"></a>连接(解析)</h3><h4 id="目的-5"><a href="#目的-5" class="headerlink" title="目的"></a>目的</h4><p>将常量池内的符号引用替换为直接引用</p><blockquote><p><strong>符号引用Symbolic References</strong>：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。内存布局无关。引用目标不一定被加载到内存中。</p><p><strong>直接引用Direct References</strong>：可以是直接指向目标的指针、相对偏移量或是一个能简洁定位到目标的句柄。内存布局相关。引用目标一定被加载到内存中。</p></blockquote><h4 id="时机-1"><a href="#时机-1" class="headerlink" title="时机"></a>时机</h4><ul><li>执行用于操作符号引用的字节码指令之前，自定义实现时机<ul><li>类被加载器加载时</li><li>一个符号引用将被使用钱</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anewarray、checkcast、getfield、getstatic、<span class="keyword">instanceof</span>、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_w、multianewarray、<span class="keyword">new</span>、putfield、putstatic</div></pre></td></tr></table></figure><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><h5 id="invokedynamic"><a href="#invokedynamic" class="headerlink" title="invokedynamic"></a><code>invokedynamic</code></h5><ul><li>当碰到某个前面已经由<code>invokedynamic</code>指令触发过解析的符号引用时，并不意味着这个解析结果对其他<code>invokedynamic</code>指令同样生效。</li><li><code>invokedynamic</code>指令的目的就是用于动态语言支持，其对应的引用称为“动态调用点限定符Dynamic Call Site Specifier”<ul><li>必须等到程序运行到这条指令时，解析动作才能进行。</li></ul></li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li><p>虚拟机实现可以堆第一次解析的结果进行缓存(在运行时常量池中记录直接引用，并把常量标识为已解析状态)，从而避免重复解析。</p></li><li><p>只需要保证在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一致成功；如果第一次失败了，其他指令对这个符号一用的解析请求也应该收到相同的异常。</p></li></ul><h4 id="对象-4"><a href="#对象-4" class="headerlink" title="对象"></a>对象</h4><ul><li><p>类或接口CONSTANT_Class_info</p></li><li><p>字段CONSTANT_fieldref_info</p></li><li><p>类方法CONSTANT_Methodref_info</p></li><li><p>接口方法CONSTANT_InterfaceMethodRef_info</p></li><li><p>方法类型CONSTANT_MethodType_info</p><ul><li>介绍后续补充</li></ul></li><li><p>方法句柄CONSTANT_MethodHandle_info</p><ul><li>介绍后续补充</li></ul></li><li><p>调用点限定符CONSTANT_InvokeDynamic_info</p><ul><li>介绍后续补充</li></ul></li></ul><h4 id="类或接口解析"><a href="#类或接口解析" class="headerlink" title="类或接口解析"></a>类或接口解析</h4><blockquote><p>假设当前代码所处的类为D，要把一个从未解析过的符号引用N解析为一个类或接口的C的直接引用</p></blockquote><ul><li><p>如果C不是数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载C类。</p><ul><li>在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作(加载其父类)</li><li>如果出现问题，解析阶段将失败</li></ul></li><li><p>如果C是数组类型</p><ul><li>数组的元素类型为对象，如<code>[Ljava/lang/Integer</code>，需要加载的就是<code>java.lang.Integer</code>，虚拟机生成一个代表此数组维度和元素的数组对象</li><li>如果前面步骤没有出现异常，那么C在虚拟机中时机上已经成为一个有效的类或接口，但在解析完成之间还有符号引用验证，确认D是否有权限访问C，如不具备，则抛出<code>java.lang.IllegalAccessError</code>异常</li></ul></li></ul><h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><blockquote><p>要解析一个未被解析过的字段符号引用，首先会解析字段所属的类或接口的符号引用，设为C，然后JVM会从这个类开始逐级往父类或接口找与这个字段相匹配的字段</p></blockquote><ul><li>C本身包含名称与描述符都匹配的字段，返回字段的直接引用，查找结束</li><li>C中实现了接口，按照继承关系从下往上搜索父接口，有则返回，查找结束</li><li>C有父类，按照继承关系从下往上搜索父类，有则返回，查找结束</li><li>都没找到，抛出<code>java.lang.NoSuchFieldError</code>异常</li></ul><h5 id="验证权限"><a href="#验证权限" class="headerlink" title="验证权限"></a>验证权限</h5><p>是否具备访问权限，不具备则抛出<code>java.lang.IllegalAccessError</code>异常</p><h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><h5 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h5><blockquote><p>解析方法所属的类或接口的符号引用C，解析成功，进行类方法的搜索</p></blockquote><ul><li>如果C解析为接口，则抛出<code>java.lang.IncompatibleClassChangeError</code>异常</li><li>在类C中找到是否有简单名称和描述符都匹配的方法，有则返回直接引用，查找结束</li><li>类C的父类中递归查找，有则返回，查找结束</li><li>类C实现的接口列表以及父接口之中递归查找，如果有，说明C是抽象类，直接抛出<code>java.lang.AbstractMethodError</code>异常</li><li>都没找到，抛出<code>java.lang.NoSuchMethodError</code>异常</li></ul><h5 id="验证权限-1"><a href="#验证权限-1" class="headerlink" title="验证权限"></a>验证权限</h5><p>是否具备访问权限，不具备则抛出<code>java.lang.IllegalAccessError</code>异常</p><h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><blockquote><p>先解析出接口方法所属的类或接口的符号引用C，解析成功，进行接口方法的搜索</p></blockquote><ul><li>如果C解析为类，则抛出<code>java.lang.IncompatibleClassChangeError</code>异常</li><li>在接口C中查找，有则返回，查找结束</li><li>在接口C的父接口中递归查找，直到<code>java.lang.Object</code>类(包含此类)，有则返回，查找结束</li><li>都没找到，抛出<code>java.lang.NoSuchMethodError</code>异常</li></ul><p><strong>接口方法默认为public，所以应当不会抛出<code>java.lang.IllegalAccessError</code>异常</strong></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><p> 最后一步，真正执行类中定义的Java程序代码，执行类构造器<code>&lt;clinit&gt;()</code>方法</p></blockquote><h4 id="lt-clinit-gt-特点"><a href="#lt-clinit-gt-特点" class="headerlink" title="&lt;clinit&gt;()特点"></a><code>&lt;clinit&gt;()</code>特点</h4><ul><li>由编译器自动收集类中的所有类变量的<strong>赋值动作</strong>和<strong>静态语句块(static)</strong>中的语句<strong>合并</strong>产生的<ul><li>收集顺序：源文件中出现的顺序</li><li>静态语句块中只能访问到定义在之前的变量，定义在后面的变量，在静态语句块中可以赋值，不能访问(使用)</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Class Test&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        <span class="comment">//正常编译</span></div><div class="line">        i = <span class="number">0</span>;</div><div class="line">        <span class="comment">//编译器提示：Illegal forward reference</span></div><div class="line">        System.out.println(i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>父类中定义的静态语句块优于子类的变量赋值操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        A = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//2</span></div><div class="line">        System.out.println(Sub.B);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>对于类或接口来说不是必需的</p><ul><li>没有静态语句块，也没有对变量的赋值操作，可以不生成</li></ul></li><li><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作</p><ul><li>执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法</li><li>只有当父接口中定义的变量使用时，才初始化父接口</li><li>接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法</li></ul></li><li><p>JVM保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步</p><ul><li>只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程阻塞，直至方法执行完毕</li><li>如果<code>&lt;clinit&gt;()</code>方法方法中有耗时很长的操作，就可能造成多进程阻塞。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac汇编环境搭建</title>
      <link href="/asm/macEnv.html"/>
      <url>/asm/macEnv.html</url>
      
        <content type="html"><![CDATA[<p>实在懒得开俩本学汇编…就在Mac搭了一个</p><a id="more"></a><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li>下载<a href="https://www.dosbox.com/" target="_blank" rel="external">DOSBox</a></li><li>下载MASM5(自行搜索)</li></ul><p>自行安装Dosbox</p><p>Masm5.zip下载好后解压</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>打开Dosbox</p><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mount c masm5解压路径</div></pre></td></tr></table></figure><p>然后就可以使用诸如debug等命令了</p><h3 id="汇编开发"><a href="#汇编开发" class="headerlink" title="汇编开发"></a>汇编开发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">;完整段的Hello World程序</div><div class="line">DATAS  SEGMENT</div><div class="line">     STRING  DB  &apos;Hello World!&apos;,13,10,&apos;$&apos;</div><div class="line">     ;定义了一个字符串,标号是STRING，其值是字符串首字符的地址。</div><div class="line">     ;DB表示的是字符串中每个字符的都是一个字节，每往后加1的时候，地址偏移量加1.</div><div class="line">     ;13 CR 回车</div><div class="line">     ;10 LF 换行</div><div class="line">     ;$作为字符串的结束符</div><div class="line">DATAS  ENDS</div><div class="line"></div><div class="line">CODES  SEGMENT</div><div class="line">     ASSUME    CS:CODES,DS:DATAS</div><div class="line">     </div><div class="line">START:</div><div class="line">     MOV  AX,DATAS</div><div class="line">     MOV  DS,AX</div><div class="line">     </div><div class="line">     LEA  DX,STRING;LEA 获取偏移量,并将其存入DX</div><div class="line">     </div><div class="line">     MOV  AH,9</div><div class="line">     INT  21H ;INT 21H是DOS中断的调用，其执行的操作根据AH里面的值来确定。</div><div class="line">               ;9，表示的是输出字符串，其地址为DS:DX</div><div class="line">    ;4CH带返回码结束</div><div class="line">     MOV  AH,4CH</div><div class="line">     INT  21H</div><div class="line">CODES  ENDS</div><div class="line">    END   START</div></pre></td></tr></table></figure><p>保存文件<code>test.asm</code>到masm5路径下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">masm test.asm</div></pre></td></tr></table></figure><p>三次回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">link test.obj</div></pre></td></tr></table></figure><p>三次回车</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">test.exe</div></pre></td></tr></table></figure><p>完事儿</p>]]></content>
      
      
      <categories>
          
          <category> asm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编之寄存器</title>
      <link href="/asm/register.html"/>
      <url>/asm/register.html</url>
      
        <content type="html"><![CDATA[<p>通过改变各种寄存器中的内容来实现对CPU的控制</p><a id="more"></a><ul><li>一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于CPU内部来说是外部总线。</li><li>内部总线实现CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。</li><li>在CPU中<ul><li>运算器进行信息处理</li><li>寄存器进行信息存储</li><li>控制器控制各个器件进行工作</li><li>内部总线连接各种器件，在它们之间进行数据的传送</li></ul></li><li>寄存器是CPU中程序员可以用指令读写的部件，通过改变各种寄存器中的内容来实现对CPU的控制</li><li>不同的CPU，寄存器的个数，结构是不同的<ul><li>8086CPU由14个寄存器</li><li>AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW</li></ul></li></ul><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul><li>8086CPU的所有寄存器都是16位的，可以存放两个字节</li><li>AX、BX、CX、DX这四个寄存器通常用来存放一般性的数据，称为通用寄存器</li><li>8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，8086CPU的四个通用寄存器都可分为两个可独立使用的8位寄存器来用<ul><li>AX：AH(高8位，8~15位)、AL(低8位，0～7位)</li><li>BX：BH、BL</li><li>CX：CH、CL</li><li>DX：DH、DL</li></ul></li></ul><blockquote><p>数据：18</p><p>二进制：10010</p><p>在寄存器AX中的存储</p><p>1(4位)0(3位)0(2位)1(1位)0(0位)</p></blockquote><h3 id="字在寄存中的存储"><a href="#字在寄存中的存储" class="headerlink" title="字在寄存中的存储"></a>字在寄存中的存储</h3><p>出于对兼容性的考虑，8086CPU可以一次性处理遗下两种尺寸的数字</p><ul><li>字节<ul><li>byte</li><li>一个字节由8个bit组成</li><li>可以存在8位寄存器中</li></ul></li><li>字<ul><li>word</li><li>一个字由两个字节组成</li><li>这两个字节分别称为这个字的高位字节和低位字节</li></ul></li></ul><p>一个字可以存在一个16位寄存器中，高位字节和地位字节就存在这个寄存器的高8位寄存器和低8位寄存器中。</p><blockquote><p>十进制：20000</p><p>二进制：100111000100000</p><p>AX：100111000100000</p><p>AH：1001110(高位字节)</p><p>AL：00100000(低位字节)</p></blockquote><p>书写习惯：</p><p>十六进制：Hexadecimal，前缀<code>0x</code>，后缀<code>H</code></p><p>十进制：decimal，前缀<code>\</code>，后缀<code>D</code></p><p>八进制：Octal，前缀<code>0</code>，后缀<code>O</code></p><p>二进制：Binary，前缀<code>0b</code>，后缀<code>B</code></p><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><p>书写汇编指令不区分大小写。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><table><thead><tr><th>程序段中的指令</th><th>执行后AX中的数据</th><th>执行后BX中的数据</th></tr></thead><tbody><tr><td>mov ax,001AH</td><td>001AH</td><td>0000H</td></tr><tr><td>mov bx,0026H</td><td>001AH</td><td>0026H</td></tr><tr><td>add al,bl</td><td>0040H</td><td>0026H</td></tr><tr><td>add ah,bl</td><td>2640H</td><td>0026H</td></tr><tr><td>add bh,al</td><td>2640H</td><td>4026H</td></tr><tr><td>mov ah,0</td><td>0040H</td><td>4026H</td></tr><tr><td>add al,85H</td><td>00C5H</td><td>4026H</td></tr><tr><td>add al,93H</td><td>?</td><td>4026H</td></tr></tbody></table><p>指令执行后AX中的数据为多少？</p><table><thead><tr><th>指令</th><th>AH</th><th>AL</th><th>BH</th><th>BL</th></tr></thead><tbody><tr><td>mov ax,001AH</td><td>00000000</td><td>00011010</td><td>00000000</td><td>00000000</td></tr><tr><td>mov bx,0026H</td><td>00000000</td><td>00011010</td><td>00000000</td><td>00100110</td></tr><tr><td>add al,bl</td><td>00000000</td><td>01000000</td><td>00000000</td><td>00100110</td></tr><tr><td>add ah,bl</td><td>00100110</td><td>01000000</td><td>01000000</td><td>00100110</td></tr><tr><td>add bh,al</td><td>00100110</td><td>01000000</td><td>01000000</td><td>00100110</td></tr><tr><td>mov ah,0</td><td>00000000</td><td>01000000</td><td>01000000</td><td>00100110</td></tr><tr><td>add al,85H</td><td>00000000</td><td>11000101</td><td>01000000</td><td>00100110</td></tr><tr><td>add al,93H</td><td>00000000</td><td>01011000</td><td>01000000</td><td>00100110</td></tr></tbody></table><p>解答：AX=AH+AL=00000000+01011000=0058H</p><p>分析：程序段中最后一条指令add al,93H，执行前，al中的数据为C5H(11000101)，相加后所得的值为158H(101011000)，但是al为8位寄存器，只能存放两位十六进制的数据，所以最高位的1丢失(8位寄存器中不能保存)，ax中的数据为：0058H。</p><blockquote><p>执行add al,93H时，al是作为一个独立的8位寄存器来使用的，和ah没有关系，CPU在执行这条指令时认为ah和al是两个不相关的寄存器，进行的是8位运算。</p><p>如果执行add ax,93H，低八位的进位会存储在ah中，CPU在执行这条指令时认为只有一个16位寄存器ax，进行的是16位运算。</p></blockquote><hr><p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">;以下为正确指令</div><div class="line">mov ax,bx</div><div class="line">mov bx,cx</div><div class="line">mov ax,18H</div><div class="line">mov al,18H</div><div class="line">add ax,bx</div><div class="line">add ax,20000</div><div class="line">;以下为错误指令，指令的两个操作对象的位数不一致</div><div class="line">mov ax,bl(在8位寄存器和16位寄存器之间传送数据)</div><div class="line">mov bh,ax(在16位寄存器和8位寄存器之间传送数据)</div><div class="line">mov al,20000(8位寄存器最大可存放值为255的数据)</div><div class="line">add al,100H(将一个高于8位的数据驾到一个8位寄存器中)</div></pre></td></tr></table></figure><h3 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h3><blockquote><p>CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间时一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，将这个唯一的地址称为物理空间</p></blockquote><p>CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在发送物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式，接下来讨论的是8086CPU如何内部形成内存单元的物理地址。</p><h3 id="16位结构的CPU"><a href="#16位结构的CPU" class="headerlink" title="16位结构的CPU"></a>16位结构的CPU</h3><p>16位结构(16位机、字长为16位)描述了一个CPU具有下面几方面的结构特性</p><ul><li>运算器一次最多可以处理16位的数据</li><li>寄存器的最大宽度为16位</li><li>寄存器和运算器之间的通路位16位</li></ul><h3 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h3><p>8086有20位地址总线，能达到1MB寻址能力，但又是16位结构，从内部一次性处理、传输、暂时存储的地址位16位。从它的内部结构看，如果将地址从内部简单的发出，那么只能送出16位的地址，表现出的寻址能力只有64KB。</p><p>8086采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p><blockquote><p>8086CPU要读写内存时：</p><ul><li>16位段地址+16位偏移地址 </li><li>通过内部总线送入地址加法器(段地址左移4位+偏移地址)</li><li>合成20位物理地址</li><li>通过内部总线送入输入输出控制电路</li><li>通过内部总线送入地址总线</li><li>传入内存</li></ul><p>关于进制：</p><p>一个数据的二进制形式左移1位，相当于该数乘以2</p><p>一个数据的二进制形式左移N位，相当于该数乘以2的N次方</p><p>一个数据的十六进制形式左移1位，相当于该数乘以16；</p><p>一个数据的十进制形式左移1位，相当于该数乘以10</p><p>一个X进制的数据左移1位，相当于该数乘以X</p></blockquote><h3 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h3><blockquote><p>内存并没有分段，段的划分来自于CPU。8086CPU物理地址计算方式使得可以用分段的方式来管理内存。</p></blockquote><p>假设10000H～100FFH的内存单元组成一个段，该段的起始地址(基础地址)位 10000H，段地址位1000H,大小为100H；也可以认为10000H～1007FH、10080H～100FFH的内存单元组成两个段，它们的起始地址(基础地址)为：10000H和10080H，段地址为1000H和1008H，大小都为80H。</p><p>可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul><li>段地址在8086CPU的段寄存器中存放。</li><li>8086CPU由4个段寄存器：CS、DS、SS、ES。</li><li>当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。</li></ul><h3 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h3><ul><li><p>CS和IP时8086CPU中两个最关键的寄存器，它们只是了CPU当前要读取指令的地址。</p></li><li><p>CS：代码段寄存器</p></li><li>IP：指令指针寄存器</li><li><p>8086CPU的工作过程</p><ul><li>在8086CPU中，任何时刻，CPU将<code>CS:IP</code>指向的内容当做指令执行，读取的指令进入指令缓冲器</li><li>IP=IP+所读取指令的长度，从而指向下一条指令</li><li>执行指令</li></ul></li><li><p>在8086CPU加电启动或复位后(CPU刚开始工作时)，CS=FFFFH，IP=0000H，也就是说，8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行</p></li></ul><blockquote><p>CPU根据什么将内存中的信息看作指令？</p><p>CPU将CS:IP指向的内存单元中的内容看作指令，用它们合成指令的物理地址，到内存中读取指令码，执行。</p><p>如果内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过</p></blockquote><h3 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h3><ul><li><p>程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令</p></li><li><p>能够改变CS、IP的内容的指令被统称为<strong>转移指令</strong>。</p></li><li><p>最简单的可以修改CS、IP的指令：<code>jmp</code>指令</p></li><li><p>若想同时修改CS、IP的内容，可用<code>jmp 段地址:偏移地址</code>指令完成。</p><ul><li>用指令中给出的段地址修改CS，偏移地址修改IP</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jmp 2AE3:3</div><div class="line">;执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令</div><div class="line">jmp 3:0B16</div><div class="line">;执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令</div></pre></td></tr></table></figure><ul><li>仅修改IP的内容，可用<code>jmp 某一合法寄存器</code>指令完成<ul><li>用寄存器中的值修改IP</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">;指令执行前：ax=1000H，CS=2000H，IP=0003H</div><div class="line">jmp ax</div><div class="line">;指令执行后：ax=1000H，CS=2000H，IP=1000H</div><div class="line"></div><div class="line">;指令执行前：bx=0B16H，CS=2000H，IP=0003H</div><div class="line">jmp bx</div><div class="line">;指令执行后：bx=0B16H，CS=2000H，IP=0B16H</div></pre></td></tr></table></figure><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><ul><li><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。</p></li><li><p>假设将长度为N(N&lt;=64KB)的一步代码，存在一组地址连续、起始地址为16的倍数的内存单元中，可以认为这段内存时用来存放代码，从而定义了一个代码段。</p></li><li><p>这仅仅是在编程时的一种安排，CPU并不会由于这种安排，就自动地将定义的代码段中的指令当做指令来执行。</p></li><li><p>所以，要让CPU还行放在代码段中的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> asm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编基础知识</title>
      <link href="/asm/bisis.html"/>
      <url>/asm/bisis.html</url>
      
        <content type="html"><![CDATA[<p>背景及组成</p><a id="more"></a><ul><li>汇编语言是直接在硬件之上工作的编程语言，首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程</li><li>关于PC机及CPU无力结构和编程结构的全面研究，在《微机原理与接口》中进行；对计算机一般的结构、功能、性能的研究在一门称为《组成原理》的理论层次更高的课程中进行。汇编课程的研究重点放在如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作</li></ul><h4 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h4><ul><li>机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。</li></ul><h4 id="汇编语言的产生"><a href="#汇编语言的产生" class="headerlink" title="汇编语言的产生"></a>汇编语言的产生</h4><ul><li>汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式</li><li>寄存器，简单来讲是CPU中可以存储数据的器件</li><li>一个能够将汇编指令转换成机器指令的翻译程序为编译器。程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，由计算机最终执行</li></ul><h4 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h4><ul><li>汇编语言由三类指令组成<ul><li>汇编指令：机器码的助记符，有对应的机器码<ul><li>汇编语言的核心</li></ul></li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号：如+、-、*、/等，又编译器识别， 没有对应的机器码</li></ul></li></ul><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><ul><li>指令和数据在存储器中存放，也就是内存。<ul><li>离开了内存，性能再好的CPU也无法工作</li><li>磁盘上的数据如果不读到内存中，就无法被CPU使用</li></ul></li></ul><h4 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h4><ul><li>在内存中，二者都是二进制信息。</li></ul><h4 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h4><ul><li>存储器被划分成若干个存储单元，每个存储单元从0开始编号<ul><li>例如一个存储器有128个存储单元，编号为0～127</li></ul></li><li>一个存储单元能存储一个Byte，即8个二进制位。<ul><li>一个存储器有128个存储单元，它可以存储128Byte</li></ul></li><li>微机存储器的容量是以字节为最小单位来计算的</li></ul><h4 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h4><ul><li>CPU要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定要读取哪一个存储单元中的数据</li><li>CPU在读写数据时还要指明，要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据</li><li>CPU要向进行数据的读写，必须和外部器件(芯片)进行交互<ul><li>存储单元的地址(地址信息)</li><li>器件的选择，读或写的命令(控制信息)</li><li>读或写的数据(数据信息)</li></ul></li><li>电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接CPU和其他芯片的导线，通常称为总线。</li><li>总线从逻辑上又分为3种<ul><li>地址总线</li><li>控制总线</li><li>数据总线</li></ul></li></ul><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><ul><li>CPU是通过地址总线来指定存储器单元的。可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址</li><li>一个CPU有N根地址总线，则可以说这个CPU的地址总线宽度为N。这样的CPU最多可以寻找2的N次方个内存单元</li><li>寻址能力(KB)=2的地址总线根数次方</li></ul><p><del>地址总线上发送的地址信息.jpg</del></p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><ul><li>CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。</li><li>数据总线宽度决定了CPU和外界的数据传送速度</li><li>8根数据总线一次可传送一个8位二进制(一个字节)数据，16根总线一次可传送两个字节</li><li>一根数据总线一次可传送1位二进制</li></ul><h4 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h4><ul><li>CPU对外部器件的控制是通过控制总线来进行的。控制总线是个总称，它是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力</li></ul><h4 id="检测点"><a href="#检测点" class="headerlink" title="检测点"></a>检测点</h4><p>Q：1个CPU的寻址能力为8KB，那么它的地址总线的宽度为13位</p><p>A：</p><ul><li>一个存储单元能存储1Byte</li><li>一个CPU有N个地址总线，那么最多寻找2的N次方个存储单元(Byte)</li><li>题目中寻址能力为8KB=1024*8=8192Byte</li><li>2的N次方=8192Byte，N=13</li></ul><h4 id="内存地址空间-概述"><a href="#内存地址空间-概述" class="headerlink" title="内存地址空间(概述)"></a>内存地址空间(概述)</h4><ul><li>一个CPU的地址总线宽度为10，那么可以寻址2的10次方=1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。</li></ul><h4 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h4><ul><li>每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，通过总线相连(地址总线、数据总线、控制总线)</li><li>器件包括：CPU、存储器、外围芯片组、扩展插槽(RAM内存条和各类接口卡)</li></ul><h4 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h4><ul><li>CPU对外部设备(显示器、音箱等)都不能直接控制，直接控制这些设备进行工作的插在扩展插槽上的接口卡</li><li>扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连</li><li>CPU通过总看向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。</li></ul><h4 id="各类存储器芯片"><a href="#各类存储器芯片" class="headerlink" title="各类存储器芯片"></a>各类存储器芯片</h4><ul><li>一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的，不同的器件。</li><li>从读写属性上看分为两类：随机存储器(RAM)和只读存储器(ROM)</li><li>随机存储器RAM：可读可写、必须带电、关机后存储内容丢失</li><li>只读存储器ROM：只能读取不能写入，关机后存储内容不丢失</li></ul><h5 id="随机存储器"><a href="#随机存储器" class="headerlink" title="随机存储器"></a>随机存储器</h5><ul><li>存放供CPU使用的绝大部分程序和数据</li><li>主随机存储器一般由两个位置上的RAM组成<ul><li>装在主板上的RAM</li><li>插在扩展卡槽上的RAM</li></ul></li></ul><h5 id="装有BIOS的ROM"><a href="#装有BIOS的ROM" class="headerlink" title="装有BIOS的ROM"></a>装有BIOS的ROM</h5><ul><li>BIOS是由主办和各类接口卡(显卡、网卡等)厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出</li><li>在主板和某些接口卡上插有存储相应BIOS的ROM</li></ul><h5 id="接口卡上的RAM"><a href="#接口卡上的RAM" class="headerlink" title="接口卡上的RAM"></a>接口卡上的RAM</h5><ul><li>某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM<ul><li>最典型的是显卡上RAM，一般称为显存。显卡随时将显存中的数据向显示器上输出。也就是说，将需要显示的内容写入显存，就会出现在显示器上</li></ul></li></ul><h4 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h4><ul><li>CPU在操作所有物理存储器时，把他们都当做内存来对待，总的看作一个由若干存储单元组成的逻辑存储器，也就是内存地址空间。每个物理存储器在这个逻辑存储器中占有一段地址段，即一段地址空间。</li><li>内存地址空间的大小受CPU地址总线宽度的限制。</li><li>在基于一个计算机硬件系统编程时，必须知道这个系统中的内存地址空间分配情况</li><li>想在某类存储器中读写数据时，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作时在预期的存储器中进行</li><li>不同的计算机系统的内存地址空间的分配情况时不同的</li></ul>]]></content>
      
      
      <categories>
          
          <category> asm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机类加载时机</title>
      <link href="/JVM/clzloadtime.html"/>
      <url>/JVM/clzloadtime.html</url>
      
        <content type="html"><![CDATA[<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Java语言里面，类型的加载、连接和初始化过程都是在<strong>程序运行期间完成</strong>的，这种策略虽然会对类加载时增加一些<strong>性能消耗</strong>，但是<strong>提供高度的灵活性</strong>。动态扩展的语言特性就是以来运行期动态加载和动态连接这个特点实现的。</p></blockquote><ul><li>编写一个面向接口的应用程序，可以等到运行时再指定实际的实现类；可以通过预定义或自定义的类加载器，让一个本地的应用程序可以从网络或其他地方加载一个二进制流作为程序代码的一部分。</li></ul><p><strong>约定</strong></p><p>类：类、接口</p><p>Class文件：二进制字节流</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>加载到虚拟机内存开始，到卸载出内存，整个生命周期包括</p><ul><li>加载Loading</li><li>连接Linking<ul><li>验证Verification</li><li>准备Preparation</li><li>解析Resolution</li></ul></li><li>初始化Initialization</li><li>使用Using</li><li>卸载Unloading</li></ul><h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>加载、验证、准备、初始化和卸载的<strong>开始顺序</strong>是确定的，解析则不一定，在某些情况下可以在初始化阶段之后再开始(为了支持Java语言的运行时绑定，也称动态绑定或晚期绑定)。这些阶段通常都是互相交叉的混合进行，通常会在一个阶段执行的过程中调用、激活另外一个阶段。</p><p>虚拟机规范没有约束何时进行类加载，但是严格规定了初始化的时机(加载、验证、准备在这之前开始了)，<strong>有且只有</strong></p><ul><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>指令时<ul><li>如果类没有进行过初始化，则先触发其初始化</li><li>使用new关键字实例化对象</li><li>读取或设置一个类的静态字段(<code>final</code>修饰，<strong>已在编译器把结果放入常量池的静态字段除外</strong>)</li><li>调用一个类的静态方法</li></ul></li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用</li><li>初始化一个类，如果其父类没有初始化，先触发父类的初始化</li><li>虚拟机启动时，初始化主类(<code>main()</code>)</li><li>使用动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果是<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法举兵，并且对应的类没有进行过初始化，则先触发具柄对应类的初始化</li></ul><h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p><strong>除主动引用之外，所有引用类的方式都不会触发其初始化，称为被动引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">System.out.println(<span class="string">"SuperClass init"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/********************************************/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</div><div class="line"><span class="keyword">static</span>&#123;</div><div class="line">System.out.println(<span class="string">"SubClass init"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/********************************************/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">System.out.println(<span class="string">"ConstClass init"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/********************************************/</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//一、子类引用父类静态字段</span></div><div class="line">System.out.println(SubClass.value);</div><div class="line"><span class="comment">//二、通过数组定义来引用类</span></div><div class="line">SuperClass[] sca=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment"> * 三、</span></div><div class="line"><span class="comment"> * 常量在编译阶段会存入调用类的常量池中</span></div><div class="line"><span class="comment"> * 本质上并没有直接引用到定义常量的类</span></div><div class="line"><span class="comment"> * 因此不会除法定义常量的类的初始化</span></div><div class="line"><span class="comment"> */</span></div><div class="line">System.out.println(ConstClass.HELLOWORLD);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>通过其子类来引用父类中定义的静态字段，只会触发父类的初始化，子类不会被初始化，对于是否触发子类的加载和验证，取决于具体实现。Sun HotSpot可通过<code>-XX:+TraceClassLoading</code>观察。</li><li>通过数组定义来引用类，不会触发父类初始化，虚拟机会自动生成、直接继承<code>java.lang.Object</code>的子类<code>[Lcom/bai/SuperClass</code>类的初始化，创建动作由字节码指令<code>anewarray</code>触发，这个类代表一个元素类型为<code>com.bai.SuperClass</code>的一维数组，数组中应有的属性和方法(可使用的只有被修饰为<code>public</code>的<code>length</code>属性和<code>clone()</code>方法)都被实现在这个类里，也封装了数组元素的访问方法，当检查数组越界时回抛出<code>java.lang.ArrayIndexOutOfBoundsException</code>异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</div><div class="line">    descriptor: ([Ljava/lang/String;)V</div><div class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</div><div class="line">    Code:</div><div class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></div><div class="line">         <span class="number">0</span>: bipush        <span class="number">10</span></div><div class="line">         2: anewarray     #16                 // class com/bai/SuperClass</div><div class="line">         <span class="number">5</span>: astore_1</div><div class="line">         <span class="number">6</span>: <span class="keyword">return</span></div></pre></td></tr></table></figure><ul><li>打印常量值时并没有触发定义常量类的初始化(输出ConstClass init)，虽然在Java源码中引用了<code>ConstClass</code>类中的常量<code>HELLOWORLD</code>，但其实在编译阶段通过常量传播优化，已经将此常量的值<code>hello world</code>存储到了<code>NotInitialization</code>类的常量池中，这两个类在编译成Class之后就不存在任何联系了。</li></ul><hr><p>编译器仍然会为接口生成<code>&lt;clinit&gt;()</code>类构造器，用于初始化接口中所定义的成员变量，接口在初始化时，不要求其父接口全部都完成了初始化，只有在真正使用到父接口时(引用接口中定义的常量)才会初始化。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码指令</title>
      <link href="/JVM/bytecode.html"/>
      <url>/JVM/bytecode.html</url>
      
        <content type="html"><![CDATA[<p>能直接阅读字节码时工作中分析Java代码语义问题的基本技能</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><ul><li>JVM指令的构成<ul><li><strong>一个字节长度</strong><ul><li>0x00~0xFF,0~255</li></ul></li><li><strong>代表某种特定操作含义的数字(操作码,Opcode)</strong></li><li><strong>零到多个代表次操作所需参数(操作数,Operands)</strong>。</li></ul></li><li>架构：面向操作数栈<del>不是寄存器</del></li><li>特点：<ul><li>大多数指令都不包含操作数，只有一个操作码</li><li>非完全独立(Not Orthogonal)<ul><li>并非每种数据类型和每一种操作都有对应的指令</li></ul></li></ul></li></ul></blockquote><ul><li>JVM处理超过一个字节数据的时候，会在运行时从字节中重建出具体数据的结构<ul><li>原因<ul><li>指令长度为1字节</li><li>Class文件格式放弃了编译后代码的操作数长度对其</li></ul></li><li>优点<ul><li>省略填充和建个符号</li><li>编译代码短</li></ul></li><li>缺点</li><li>解释执行字节码时损失一些性能</li></ul></li></ul><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><ul><li>对于大部分与基本数据类型(int、long、short、byte、char、float、double)相关的字节码指令，操作码助记符在首位会以数据类型首字母开头</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iload：从局部变量表中加载int型的数据到操作数栈中</div><div class="line">fload：从局部变量表中加载float型的数据到操作数栈中</div></pre></td></tr></table></figure><ul><li>a代表reference</li><li>大部分指令都没有支持整数类型(byte、char和short)，没有任何指令支持boolean<ul><li>编译器会将byte和short类型数据<strong>带符号扩展(Sign-Extend)</strong>为相应的int类型数据</li><li>将boolean和char类型数据<strong>零位扩展(Zero-Extend)</strong>为相应的int类型数据</li></ul></li></ul><h3 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h3><ul><li>作用<ul><li>将数据在栈帧只能够的局部变量表和操作数栈之间来回传输</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将一个局部变量加载到操作数栈：</span></div><div class="line">*load&lt;_n&gt;：iload、iload_3</div><div class="line"><span class="comment">//将一个数值从操作数栈存储到局部变量表</span></div><div class="line">*store&lt;_n&gt;：astore、astore_2</div><div class="line"><span class="comment">//将一个常量加载到操作数栈</span></div><div class="line">bipush、sipush、idc、idc_w、idc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</div><div class="line"><span class="comment">//扩充局部变量表的访问索引</span></div><div class="line">wide</div></pre></td></tr></table></figure><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><ul><li>作用<ul><li>对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶</li></ul></li><li>分类<ul><li>对整型数据进行运算</li><li>对浮点型数据进行运算</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加法</span></div><div class="line">*add：iadd、ladd、fadd、dadd</div><div class="line"><span class="comment">//减法</span></div><div class="line">*sub：isub、lsub、fsub、dsub</div><div class="line"><span class="comment">//乘法</span></div><div class="line">*mul：imul、lmul、fmul、dmul</div><div class="line"><span class="comment">//除法</span></div><div class="line">*div：idiv、ldiv、fdiv、ddiv</div><div class="line"><span class="comment">//求余</span></div><div class="line">*rem：irem、lrem、frem、drem</div><div class="line"><span class="comment">//取反</span></div><div class="line">*neg：ineg、lneg、fneg、dneg</div><div class="line"><span class="comment">//位移</span></div><div class="line">ishl、ishr、iushr、lshl、lshr、lushr</div><div class="line"><span class="comment">//按位或</span></div><div class="line">ior、lor</div><div class="line"><span class="comment">//按位与</span></div><div class="line">iand、land</div><div class="line"><span class="comment">//按位异或</span></div><div class="line">ixor、lxor</div><div class="line"><span class="comment">//局部变量自增</span></div><div class="line">iinc</div><div class="line"><span class="comment">//比较</span></div><div class="line">dcmpg、dcmpl、fcmpg、fcmpl、lcmp</div></pre></td></tr></table></figure><ul><li>两个int值相加结果超过int范围，将会返回负数</li><li>JVM规范没有明确定义过整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有<strong>除法指令(idiv和ldiv)</strong>以及<strong>求余指令(irem和lrem)</strong> 中当出现<strong>除数为零</strong>时会导致虚拟机抛出<strong><code>ArithmeticException</code></strong>异常，其余任何整型数运算场景都不应抛出运行时异常。</li><li>JVM规范要求JVM必须完全支持 <a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="external">IEEE 754</a>中定义的非规约形式的浮点数值(Denormalized Floating-Point Numbers)和逐级下溢(Gradual Underflow)的运算规则。<ul><li>对于浮点数，当最小值超过范围的时候，会逐级下溢；当最大值超过范围的时候，会发生上溢。</li></ul></li></ul><blockquote><p>如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为<strong>非规约形式的浮点数</strong>。一般是某个数字<strong>相当</strong>接近零时才会使用非规约型式来表示。 IEEE 754标准规定：<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1</strong>。</p></blockquote><ul><li>浮点数运算时，默认的舍入模式为向最接近数的精确值，优先选择最低有效位位零的。</li><li>浮点数转整数的时候采用的时向零舍入，即直接将小数位舍掉。</li><li>如果计算的结果没有明确定义，不抛异常，返回<code>NaN</code>。</li><li>对于long类型数值比较时，采用带符号的比较方式；对于浮点数(dcmpg、dcmpl、fcmpg、fcmpl)采用无信号比较方式。</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p>JVM支持隐式宽化转换(Widening Numberic Conversions，小范围类型向大范围类型的安全转换)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int  -&gt; long、float、double</div><div class="line">long -&gt; float、double</div><div class="line">float-&gt; double</div></pre></td></tr></table></figure><p>必须显式使用转换指令处理窄化类型转换(Narrowing Numeric Conversions)。导致转换结果产生不同的正负号(符号在高位)、数量级，导致精度丢失。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f</div></pre></td></tr></table></figure><ul><li>将int或long类型窄化转换为类型T的时候，将丢弃除最低位数据类型长度字节以外的内容。</li><li>浮点值窄化为int或long规则<ul><li>浮点值为<code>NaN</code>，返回int或long的0</li><li>浮点值不是无穷大，采用向零舍入模式取整，符合范围则返回，否则根据结果值的符号，转换为目标类型可表示的最大或最小整数。</li></ul></li><li>double&gt;float<ul><li>最接近数摄入模式</li><li>绝对值太小则返回float类型的正负零</li><li>太大则返回float类型的正负无穷大</li><li>double的NaN返回float的NaN</li></ul></li><li>永远不会抛异常</li></ul><h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><p>类实例和数组的创建和使用采用不同的字节码指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/****************类*******************/</span></div><div class="line"><span class="comment">//创建类实例</span></div><div class="line"><span class="keyword">new</span></div><div class="line"><span class="comment">//访问类字段(static)和实例字段(非static)</span></div><div class="line">getfield、putfield、getstatic、putstatic</div><div class="line"><span class="comment">//检查类实例类型</span></div><div class="line"><span class="keyword">instanceof</span>、checkcast</div><div class="line"><span class="comment">/****************数组*******************/</span></div><div class="line"><span class="comment">//创建数组</span></div><div class="line">newarray、anewarray、nultianewarray    </div><div class="line"><span class="comment">//把一个数组元素加载到操作数栈</span></div><div class="line">baload、caload、saload、iaload、laload、faload、daload、aaload</div><div class="line"><span class="comment">//把一个操作数栈的值存储到数组元素中</span></div><div class="line">bastore、castore、sastore、iastore、fastore、dastore、aastore</div><div class="line"><span class="comment">//获取数组长度</span></div><div class="line">arraylength</div></pre></td></tr></table></figure><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p>JVM提供一些用于直接操作操作数栈的指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//栈顶一个或两个元素出栈</span></div><div class="line">pop、pop2</div><div class="line"><span class="comment">//复制栈顶一个或两个数值，并将复制值或双份复制值重新压入栈顶</span></div><div class="line">dup、dup2、dup_x1、dup_x2、dup2_1、dup2_x2</div><div class="line"><span class="comment">//栈顶的两个数值互换</span></div><div class="line">swap</div></pre></td></tr></table></figure><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><p>可以让JVM从指定位置(而不是控制转移指令的下一条指令)继续执行程序，从概念模型上可以认为是修改PC寄存器的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//条件分支</span></div><div class="line">ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne</div><div class="line"><span class="comment">//复合条件分支</span></div><div class="line">tableswitch、lookupswitch</div><div class="line"><span class="comment">//无条件分支</span></div><div class="line">goto、goto_w、jsr、jsr_w、ret</div></pre></td></tr></table></figure><ul><li>对于boolean、byte、char、short类型是通过int类型的比较指令完成</li><li>对于long、float、double类型，先执行对应类型的指令，运算指令会返回一个整型值到操作数栈中，再执行int类型的条件分支比较操作来完整整个分支跳转。</li></ul><h3 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*****************分派逻辑固化在JVM内部*****************/</span></div><div class="line"><span class="comment">//调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派、Java中最常见的分派方式)</span></div><div class="line">invokevirtual</div><div class="line"><span class="comment">//调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用</span></div><div class="line">invokeinterface</div><div class="line"><span class="comment">//调用需要特殊处理的实例方法，如：实例初始化方法、私有方法、父类指令</span></div><div class="line">invokespecial</div><div class="line"><span class="comment">//调用类方法(static method)</span></div><div class="line">invokestatic</div><div class="line"><span class="comment">/********分派逻辑是由用户所设定的引导方法决定的********/</span></div><div class="line"><span class="comment">//在运行时动态解析出调用点限定符所引用的方法，并执行</span></div><div class="line">invokedynamic</div></pre></td></tr></table></figure><p>方法<strong>调用指令</strong>与数据类型无关，方法<strong>返回指令</strong>是根据返回值的类型区分的。</p><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p>Java程序中显示抛出异常(<code>throw</code>)由<code>athrow</code>指令完成，而处理异常(catch语句)不是由字节码指令来完成的(取消了<code>jsr</code>和<code>ret</code>指令，采用<strong>异常表</strong>来完成)。</p><h3 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h3><p>JVM支持<strong>方法级的同步</strong>和<strong>方法内部一段指令序列的同步</strong>。都是由<code>Monitor</code>管程支持的。</p><h4 id="方法级同步"><a href="#方法级同步" class="headerlink" title="方法级同步"></a>方法级同步</h4><blockquote><p>方法级的同步是隐式的，无需通过字节码指令来控制，实现在方法调用和返回操作之中。JVM可以从方法常量池的方法表结构中的<code>ACC_SYCHRONIZED</code>访问标识得知一个方法是否为同步方法。</p></blockquote><ul><li>方法调用，检查方法的<code>ACC_SYCHRONIZED</code>访问标志是否设置，如果有<ul><li>执行线程就要求先成功持有管程(其他任何线程都无法再获得同一管程)</li><li>执行方法</li><li>执行完毕<ul><li>没有抛出异常，释放管程</li><li>抛出异常，并且在方法内部无法处理此异常，则在异常抛到同步方法之外时自动释放管程</li></ul></li></ul></li></ul><h4 id="指令序列同步"><a href="#指令序列同步" class="headerlink" title="指令序列同步"></a>指令序列同步</h4><p>由Java语言中的<code>synchronized</code>语句块表示，由<code>monitorenter(开始同步)</code>和<code>monitorexit(退出同步)</code>两条指令来支持。</p><p>正确实现synchronized关键字需要Javac编译器与JVM两者共同协作支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyMe</span><span class="params">(Foo f)</span></span>&#123;</div><div class="line"><span class="keyword">synchronized</span>(f)&#123;</div><div class="line">doSomething();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><code>javac Test.java</code></li><li><code>javap -v Test</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">onlyMe</span><span class="params">(Test$Foo)</span></span>;</div><div class="line">    descriptor: (LTest$Foo;)V</div><div class="line">    flags: (<span class="number">0x0000</span>)</div><div class="line">    Code:</div><div class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">2</span></div><div class="line">         <span class="number">0</span>: aload_1<span class="comment">//将对象f入栈</span></div><div class="line">         <span class="number">1</span>: dup<span class="comment">//复制栈顶元素(f的引用)</span></div><div class="line">         <span class="number">2</span>: astore_2<span class="comment">//将栈顶元素存储到局部变量表Slot 2中</span></div><div class="line">         <span class="number">3</span>: monitorenter<span class="comment">//以栈顶元素(f)作为锁，开始同步</span></div><div class="line">         <span class="number">4</span>: aload_0<span class="comment">//将局部变量Slot 0(this)的元素入栈</span></div><div class="line">         5: invokevirtual #2                //调用doSomething方法</div><div class="line">         <span class="number">8</span>: aload_2<span class="comment">//将局部变量Slot 2元素(f)入栈</span></div><div class="line">         <span class="number">9</span>: monitorexit<span class="comment">//退出同步</span></div><div class="line">        <span class="number">10</span>: goto          <span class="number">18</span><span class="comment">//方法正常结束，跳转到18返回</span></div><div class="line">        <span class="number">13</span>: astore_3<span class="comment">//异常路径，见下面异常表的Target13</span></div><div class="line">        <span class="number">14</span>: aload_2<span class="comment">//将局部变量Slot 2元素(f)入栈</span></div><div class="line">        <span class="number">15</span>: monitorexit<span class="comment">//退出同步</span></div><div class="line">        <span class="number">16</span>: aload_3<span class="comment">//将局部变量Slot 3元素(异常对象)入栈</span></div><div class="line">        <span class="number">17</span>: athrow<span class="comment">//吧异常对象重新抛给onlyMe方法的调用者</span></div><div class="line">        <span class="number">18</span>: <span class="keyword">return</span><span class="comment">//方法正常返回</span></div><div class="line">      Exception table:</div><div class="line">         from    to  target type</div><div class="line">             <span class="number">4</span>    <span class="number">10</span>    <span class="number">13</span>   any</div><div class="line">            <span class="number">13</span>    <span class="number">16</span>    <span class="number">13</span>   any</div></pre></td></tr></table></figure><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令。</p><p>为了保证在方法异常完成时，monitorenter和monitorexit指令依旧可以正确配对执行，编译器会自动产生一个异常处理器，它可以处理所有异常，目的是为了执行monitorexit指令</p><hr><p>JVM规范推荐在满足规范的条件下对具体实现作出修改和优化。</p><p>JVM可以将输入JVM代码在加载和执行时翻译成两种不同的指令集</p><ul><li>另外一种虚拟机的指令集</li><li>宿主机CPU的本地指令集(<code>JIT</code>)</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">JVM Specifications</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class文件详述(2)</title>
      <link href="/JVM/classDetail2.html"/>
      <url>/JVM/classDetail2.html</url>
      
        <content type="html"><![CDATA[<ul><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul><a id="more"></a><p>由于上一篇文章中实例代码没有声明字段，所以本篇内容变更示例代码</p><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> m + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>class文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="function">CA FE BA <span class="title">BE</span><span class="params">(Class魔数)</span></span></div><div class="line"><span class="function">--------------版本号-------------------</span></div><div class="line"><span class="function">00 00（次版本号） </span></div><div class="line"><span class="function">00 35（主版本号)</span></div><div class="line"><span class="function">--------------常量池-------------------</span></div><div class="line"><span class="function">00 13（十进制19，18个常量） </span></div><div class="line"><span class="function">--1--</span></div><div class="line"><span class="function">0<span class="title">A</span><span class="params">(十进制<span class="number">10</span>，CONSTANT_Methodref_info)</span></span></div><div class="line"><span class="function">00 04<span class="params">(<span class="number">4</span>，指向声明方法的类描述符CONSTANT_Class_info的索引项)</span></span></div><div class="line"><span class="function">00 0<span class="title">F</span><span class="params">(<span class="number">15</span>，指向名称及类型描述符CONSTANT_NameAndType_info的索引项)</span></span></div><div class="line"><span class="function">--2--    </span></div><div class="line"><span class="function">09<span class="params">(十进制<span class="number">9</span>,CONSTANT_Fieldref_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(<span class="number">3</span>，指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项)</span> </span></div><div class="line"><span class="function">00 10<span class="params">(<span class="number">16</span>，指向名称及类型描述符CONSTANT_NameAndType_info的索引项)</span></span></div><div class="line"><span class="function">--3--    </span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span></span></div><div class="line"><span class="function">00 11<span class="params">(常量池中第<span class="number">17</span>项)</span></span></div><div class="line"><span class="function">--4--</span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span> </span></div><div class="line"><span class="function">00 12<span class="params">(常量池中第<span class="number">18</span>项)</span></span></div><div class="line"><span class="function">--5--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 01<span class="params">(字符串长度是<span class="number">1</span>字节)</span></span></div><div class="line"><span class="function">6<span class="title">D</span><span class="params">(十进制<span class="number">109</span>，字母m)</span></span></div><div class="line"><span class="function">--6--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 01<span class="params">(字符串长度是<span class="number">1</span>字节)</span></span></div><div class="line"><span class="function">49（十进制73，字母I)</span></div><div class="line"><span class="function">--7--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 06<span class="params">(字符串长度是<span class="number">6</span>字节)</span></span></div><div class="line"><span class="function">3C 69 6E 69 74 3E（&lt;init&gt;）</span></div><div class="line"><span class="function">--8--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(字符串长度是<span class="number">3</span>字节)</span></span></div><div class="line"><span class="function">28 29 56<span class="params">(()</span>v)</span></div><div class="line"><span class="function">--9--    </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">0004<span class="params">(字符串长度是<span class="number">4</span>字节)</span></span></div><div class="line"><span class="function">43 6F 64 65<span class="params">(Code)</span></span></div><div class="line"><span class="function">--10-- </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 0<span class="title">F</span><span class="params">(字符串长度是<span class="number">15</span>字节)</span></span></div><div class="line"><span class="function">4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65<span class="params">(LineNumberTable)</span></span></div><div class="line"><span class="function">--11-- </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(字符串长度是<span class="number">3</span>字节)</span></span></div><div class="line"><span class="function">69 6E 63<span class="params">(inc)</span></span></div><div class="line"><span class="function">--12-- </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(字符串长度是<span class="number">3</span>字节)</span></span></div><div class="line"><span class="function">28 29 49<span class="params">(()</span>I)</span></div><div class="line"><span class="function">--13--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 0<span class="title">A</span><span class="params">(字符串长度是<span class="number">10</span>字节)</span> </span></div><div class="line"><span class="function">53 6F 75 72 63 65 46 69 6C 65<span class="params">(SourceFile)</span></span></div><div class="line"><span class="function">--14--</span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 0<span class="title">E</span><span class="params">(字符串长度是<span class="number">14</span>字节)</span> </span></div><div class="line"><span class="function">54 65 73 74 43 6C 61 73 73 2E 6A 61 76 61<span class="params">( TestClass.java)</span></span></div><div class="line"><span class="function">--15--   </span></div><div class="line"><span class="function">0<span class="title">C</span><span class="params">(CONSTANT_NameAndType_info)</span></span></div><div class="line"><span class="function">00 07<span class="params">(<span class="number">7</span>，指向该字段或方法名称常量项的索引,&lt;init&gt;)</span></span></div><div class="line"><span class="function">00 08<span class="params">(<span class="number">8</span>，指向该字段或方法描述符常量项的索引,()</span>v)</span></div><div class="line"><span class="function">--16--  </span></div><div class="line"><span class="function">0<span class="title">C</span><span class="params">(CONSTANT_NameAndType_info)</span></span></div><div class="line"><span class="function">00 05<span class="params">(<span class="number">5</span>，指向该字段或方法名称常量项的索引,m)</span></span></div><div class="line"><span class="function">00 06<span class="params">(<span class="number">6</span>，指向该字段或方法描述符常量项的索引,I)</span> </span></div><div class="line"><span class="function">--17--  </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 0<span class="title">E</span><span class="params">(字符串长度是<span class="number">14</span>字节)</span></span></div><div class="line"><span class="function">74 65 73 74 2F 54 65 73 74 43 6C 61 73 73<span class="params">(test/TestClass)</span></span></div><div class="line"><span class="function">--18--  </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 10<span class="params">(字符串长度是<span class="number">16</span>字节)</span> </span></div><div class="line"><span class="function">6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74<span class="params">(java/lang/Object)</span></span></div><div class="line"><span class="function">--------------访问标志-------------------</span></div><div class="line"><span class="function">00 21<span class="params">(ACC_PUBLIC、ACC_SUPER，<span class="number">0x0001</span>|<span class="number">0x0020</span>=<span class="number">0x0021</span>)</span>  </span></div><div class="line"><span class="function">--------------类索引-------------------</span></div><div class="line"><span class="function">00 03<span class="params">(<span class="number">3</span>，this_class，类索引为<span class="number">3</span>，常量池中第<span class="number">3</span>项：test/TestClass)</span></span></div><div class="line"><span class="function">--------------父类索引-------------------    </span></div><div class="line"><span class="function">00 04<span class="params">(<span class="number">4</span>，super_class，父类索引为<span class="number">4</span>，常量池中第<span class="number">4</span>项：java/lang/Object)</span></span></div><div class="line"><span class="function"><span class="params">(类索引、父类索引各自指向CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串）</span></span></div><div class="line"><span class="function"><span class="params">--------------接口索引-------------------</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">00</span> <span class="number">00</span>(<span class="number">0</span>，interfaces_count，接口计数器，表示索引表的容量)</span></span></div><div class="line"><span class="function">--------------字段表集合-------------------</span></div><div class="line"><span class="function">00 01（计数器容量：定义了1个字段）</span></div><div class="line"><span class="function">00 02 <span class="params">(访问标志：ACC_PRIVATE）</span></span></div><div class="line"><span class="function"><span class="params"><span class="number">00</span> <span class="number">05</span>(<span class="number">5</span>，指向该字段或方法名称常量项的索引,m)</span></span></div><div class="line"><span class="function">00 06<span class="params">(<span class="number">6</span>，descriptor_index,I,<span class="keyword">int</span>)</span></span></div><div class="line"><span class="function">00 00<span class="params">(属性表计数器)</span> </span></div><div class="line"><span class="function">--------------方法表集合-------------------       </span></div><div class="line"><span class="function">00 02<span class="params">(计数器容量：<span class="number">2</span>个方法,inc()</span>和编译器增加的实例构造器&lt;init&gt;)</span></div><div class="line"><span class="function">00 01<span class="params">(访问标志：ACC_PUBLIC)</span> </span></div><div class="line"><span class="function">00 07<span class="params">(名称索引：常量池第<span class="number">7</span>项,&lt;init&gt;)</span></span></div><div class="line"><span class="function">00 08<span class="params">(描述符索引：常量池第<span class="number">8</span>项,()</span>v)</span></div><div class="line"><span class="function">00 01<span class="params">(属性表计数器：<span class="number">1</span>项属性)</span></span></div><div class="line"><span class="function">--------------属性表集合------------------- </span></div><div class="line"><span class="function">---Code属性开始---       </span></div><div class="line"><span class="function">00 09<span class="params">(attribute_name_index：常量池第<span class="number">9</span>项，Code)</span></span></div><div class="line"><span class="function">00 00 00 1<span class="title">D</span><span class="params">(attribute_length：<span class="number">29</span>)</span></span></div><div class="line"><span class="function">00 01<span class="params">(max_stack：<span class="number">1</span>)</span></span></div><div class="line"><span class="function">00 01<span class="params">(max_locals：<span class="number">1</span>)</span> </span></div><div class="line"><span class="function">00 00 00 05<span class="params">(code_length：<span class="number">5</span>)</span></span></div><div class="line"><span class="function">---       </span></div><div class="line"><span class="function">2<span class="title">A</span><span class="params">(对应指令为aload_0，将低<span class="number">0</span>个Slot槽位为reference类型的本地变量推送到栈的顶端)</span></span></div><div class="line"><span class="function"><span class="title">B7</span><span class="params">(对应指令为invokespecial，将栈顶的reference类型的数据所指向的对象作为方法的接收者，调用此对象的实例构造方法。这条指令带有一个u2类型的参数，为具体调用的哪一个方法，指向常量池中一个 </span></span></div><div class="line"><span class="function"><span class="params">CONSTANT_Methodref_info类型常量，即此方法的符号应用。 )</span></span></div><div class="line"><span class="function">00 01<span class="params">(方法的符号引用,常量池中第<span class="number">1</span>项,java/lang/Object &lt;init&gt;V)</span></span></div><div class="line"><span class="function"><span class="title">B1</span><span class="params">(对应指令为return，含义为返回此方法，返回值为<span class="keyword">void</span>。这条指令执行完后当前方法结束)</span></span></div><div class="line"><span class="function">---       </span></div><div class="line"><span class="function">00 00<span class="params">(exception_table_length)</span></span></div><div class="line"><span class="function">00 01<span class="params">(attributes_count：<span class="number">1</span>)</span></span></div><div class="line"><span class="function">---       </span></div><div class="line"><span class="function">00 0<span class="title">A</span><span class="params">(十进制：<span class="number">10</span>,常量池中第<span class="number">10</span>项,LineNumberTable)</span></span></div><div class="line"><span class="function">00 00 00 06<span class="params">(属性长度：<span class="number">6</span>)</span></span></div><div class="line"><span class="function">00 01<span class="params">(line_number_table_length：<span class="number">1</span>)</span> </span></div><div class="line"><span class="function">00 00<span class="params">(字节码编号：<span class="number">0</span>)</span></span></div><div class="line"><span class="function">00 03<span class="params">(Java源码行号：<span class="number">3</span>)</span></span></div><div class="line"><span class="function">---Code属性结束---  </span></div><div class="line"><span class="function">00 01<span class="params">(<span class="keyword">public</span>)</span></span></div><div class="line"><span class="function">00 0<span class="title">B</span><span class="params">(name_index：<span class="number">11</span>,inc)</span></span></div><div class="line"><span class="function">00 0<span class="title">C</span><span class="params">(description_index:<span class="number">12</span>,()</span>I)</span></div><div class="line"><span class="function">00 01<span class="params">(属性计数器：<span class="number">1</span>)</span> </span></div><div class="line"><span class="function">---Code属性开始---    </span></div><div class="line"><span class="function">00 09<span class="params">(属性名称：常量池第<span class="number">9</span>项，Code)</span></span></div><div class="line"><span class="function">00 00 00 1<span class="title">F</span><span class="params">(属性长度：<span class="number">31</span>)</span></span></div><div class="line"><span class="function">00 02<span class="params">(max_stack：<span class="number">2</span>)</span></span></div><div class="line"><span class="function">00 01<span class="params">(max_locals：<span class="number">1</span>)</span></span></div><div class="line"><span class="function">00 00 00 07<span class="params">(code_length：<span class="number">7</span>)</span></span></div><div class="line"><span class="function">2<span class="title">A</span><span class="params">(对应指令为aload_0，将低<span class="number">0</span>个Slot槽位为reference类型的本地变量推送到栈的顶端)</span></span></div><div class="line"><span class="function"><span class="title">B4</span><span class="params">(getfield,获取对象字段的值)</span></span></div><div class="line"><span class="function">00 02<span class="params">(方法的符号引用,常量池中第<span class="number">2</span>项,m和i)</span></span></div><div class="line"><span class="function">04<span class="params">(iconst_1,<span class="number">1</span>(<span class="keyword">int</span>)</span>值入栈)  </span></div><div class="line"><span class="function">60<span class="params">(iadd,将栈顶两<span class="keyword">int</span>类型数相加，结果入栈)</span></span></div><div class="line"><span class="function"><span class="title">AC</span><span class="params">(ireturn,返回<span class="keyword">int</span>类型值)</span></span></div><div class="line"><span class="function">00 00<span class="params">(exception_table_length)</span></span></div><div class="line"><span class="function">00 01<span class="params">(attribute_count)</span></span></div><div class="line"><span class="function">00 0<span class="title">A</span><span class="params">(十进制：<span class="number">10</span>,常量池中第<span class="number">10</span>项,LineNumberTable)</span></span></div><div class="line"><span class="function">00 00 00 06<span class="params">(属性长度：<span class="number">6</span>)</span></span></div><div class="line"><span class="function">00 01<span class="params">(line_number_table_length：<span class="number">1</span>)</span> </span></div><div class="line"><span class="function">00 00<span class="params">(字节码编号：<span class="number">0</span>)</span></span></div><div class="line"><span class="function">00 07<span class="params">(Java源码行号：<span class="number">7</span>)</span></span></div><div class="line"><span class="function">---Code属性结束---       </span></div><div class="line"><span class="function">--sourceFile--       </span></div><div class="line"><span class="function">00 01<span class="params">(<span class="keyword">public</span>)</span></span></div><div class="line"><span class="function">00 0<span class="title">D</span><span class="params">(name_index：<span class="number">13</span>,SourceFile)</span> </span></div><div class="line"><span class="function">00 00 00 02<span class="params">(attribute_length:<span class="number">2</span>)</span></span></div><div class="line"><span class="function">00 0<span class="title">E</span> <span class="params">(soucefile_index:<span class="number">14</span>,TestClass.java)</span></span></div></pre></td></tr></table></figure><h3 id="类索引-this-class"><a href="#类索引-this-class" class="headerlink" title="类索引(this_class)"></a>类索引(this_class)</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>确定这个类的全限定名</li><li>指向CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</li></ul><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>访问标志之后</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>一个u2类型的数据</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span> <span class="number">01</span>(<span class="number">1</span>，this_class，类索引为<span class="number">1</span>，常量池中第一项：test/Test)</div></pre></td></tr></table></figure><h3 id="父类索引-super-class"><a href="#父类索引-super-class" class="headerlink" title="父类索引(super_class)"></a>父类索引(super_class)</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>确定这个类的父类全限定名</li><li>父类索引各自指向CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串</li></ul><h4 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h4><ul><li>类索引之后</li></ul><h4 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h4><ul><li>一个u2类型的数据</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>Java不允许多重继承，父类索引只有一个</li><li>除了<code>java.lang.Object</code>之外，所有类都有父类，父类都不为0</li></ul><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">00</span> <span class="number">03</span>(<span class="number">3</span>，super_class，父类索引为<span class="number">3</span>，常量池中第三项：java/lang/Object)</div></pre></td></tr></table></figure><h3 id="接口索引集合-interfaces"><a href="#接口索引集合-interfaces" class="headerlink" title="接口索引集合(interfaces)"></a>接口索引集合(interfaces)</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ul><li>描述这个类实现了哪些接口<ul><li>这些被实现的接口将按<code>implements</code>语句(如果类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中</li></ul></li></ul><h4 id="位置-2"><a href="#位置-2" class="headerlink" title="位置"></a>位置</h4><p>父类索引之后</p><h4 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h4><ul><li>u2类型的数据：接口计数器interfaces_count<ul><li>表示索引表的容量</li><li>如果没有实现任何接口，则为0</li></ul></li></ul><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00(0，interfaces_count，接口计数器，表示索引表的容量，0为没有实现任何接口)</div></pre></td></tr></table></figure><blockquote><p>Class文件中由这三项数据来确定这个类的继承关系</p></blockquote><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><p>字段表<code>field_info</code>，用来描述接口或者类中声明的变量</p><p>字段<code>field</code>，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</p><h4 id="位置-3"><a href="#位置-3" class="headerlink" title="位置"></a>位置</h4><p>接口索引后</p><h4 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h4><ul><li>字段的作用域(public、private、protected)</li><li>是实例变量还是类变量(static修饰符)</li><li>可变性(final)</li><li>并发可见性(volatile，是否强制从主内存读写)</li><li>是否被序列化(transient修饰符)</li></ul><p>上述各个修饰符都是布尔值，用标志位来表示</p><ul><li>字段名字</li><li>字段的数据类型</li></ul><p>上述内容不固定，只能引用常量池中的常量来描述。</p><p><strong>字段表结构见下表</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p><strong>access_flags字段访问标志见下表</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>字段是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>字段是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>字段是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>字段是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>字段是否final</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>字段是否volatile</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>字段是否transient</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>字段是否由编译器自动产生的</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>字段是否enum</td></tr></tbody></table><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><code>ACC_PUBLIC</code>、<code>ACC_PRIVATE</code>、<code>ACC_PROTECTED</code>三者只能选其一</li><li><code>ACC_FINAL</code>、<code>ACC_VOLATILE</code>二者只能选其一</li><li>接口中字段必须有<code>ACC_PUBLIC</code>、<code>ACC_STATIC</code>、<code>ACC_FINAL</code>标志，Java语言规则决定。</li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><code>name_index</code><ul><li>对常量池的引用</li><li>字段的简单名称</li></ul></li><li><code>descriptor_index</code><ul><li>对常量池的引用</li><li>字段和方法的描述符</li></ul></li></ul><blockquote><ul><li>全限定名<ul><li>test/TestClass</li><li>用<code>;</code>分隔</li></ul></li><li>简单名称<ul><li>没有类型和参数修饰的方法或者字段名称</li><li><code>m</code>和<code>inc</code></li></ul></li><li>描述符<ul><li>用来描述字段的数据类型、方法的参数列表（数量、类型、顺序）、返回值</li></ul></li></ul></blockquote><ul><li>描述符标识字符含义表</li></ul><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void</td></tr><tr><td>L</td><td>对象类型，如Ljava/lang/Object</td></tr></tbody></table><ul><li>基本数据类型及无返回值：大写字母</li><li>对象类型：L+对象的全限定名</li><li>数组：每一维度用一个前置的<code>[</code><ul><li><code>int[]</code> &gt; <code>[I</code></li><li><code>java.lang.String[][]</code> &gt; <code>[[Ljava/lang/String;</code></li></ul></li><li><p>方法：</p><ul><li>顺序：先参数列表，后返回值<ul><li><code>void inc()</code> &gt; <code>()V</code></li><li><code>java.lang.String toString()</code> &gt; <code>()Ljava/lang/String;</code></li><li><code>int testF(char[] args1, int arg2 , char[] arg3)</code> &gt; <code>([CI[C)I</code></li></ul></li></ul></li><li><p>字段表中不会列出超类或者父接口中继承而来的字段</p></li><li><p>但有可能列出原本Java代码中不存在的字段</p><ul><li>内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段</li></ul></li><li><p>Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的</p></li></ul><h4 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">--------------字段表集合-------------------</div><div class="line"><span class="number">00</span> <span class="number">01</span>（计数器容量：定义了<span class="number">1</span>个字段）</div><div class="line"><span class="number">00</span> <span class="number">02</span> (访问标志：ACC_PRIVATE）</div><div class="line"><span class="number">00</span> <span class="number">05</span>(<span class="number">5</span>，指向该字段或方法名称常量项的索引,m)</div><div class="line"><span class="number">00</span> <span class="number">06</span>(<span class="number">6</span>，descriptor_index,I,<span class="keyword">int</span>)</div><div class="line"><span class="number">00</span> <span class="number">00</span>(属性表计数器)</div></pre></td></tr></table></figure><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><p><code>method_info</code>,对方法的描述</p><h4 id="位置-4"><a href="#位置-4" class="headerlink" title="位置"></a>位置</h4><p>字段表之后</p><h4 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h4><p><strong>方法表结构见下表</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>access_flags</td><td>1</td></tr><tr><td>u2</td><td>name_index</td><td>1</td></tr><tr><td>u2</td><td>descriptor_index</td><td>1</td></tr><tr><td>u2</td><td>attributes_count</td><td>1</td></tr><tr><td>attributes_info</td><td>attributes</td><td>attributes_count</td></tr></tbody></table><p><strong>方法访问标志见下表</strong></p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>方法是否public</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>方法是否private</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>方法是否protected</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>方法是否static</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>方法是否final</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>方法是否synchronized</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>方法是否由编译器产生的桥接方法</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>方法是否接受不定参数</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>方法是否native</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>方法是否abstract</td></tr><tr><td>ACC_STRICTFP</td><td>0x0800</td><td>方法是否strictfp</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>方法是否由编译器自动产生</td></tr></tbody></table><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul><li><p>方法里的代码，经过编译器编译成字节码指令后，存在方法属性表集合中一个名为<code>Code</code>的属性里面，之后有详解</p></li><li><p>如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息</p></li><li><p>可能会出现由编译器自动添加的方法，之后有详解</p><ul><li>最典型：类构造器<code>&lt;clinit&gt;</code></li><li>实例构造器<code>&lt;init&gt;</code></li></ul></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">根据虚拟机规范中对重载的定义(4.7.9)</a>，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合(不包含返回值)，也就是说无法只依靠返回值的不同来对一个已有方法进行重载。但是<strong>在Class文件格式中</strong>，特征签名只要描述符不是完全一致的两个方法也可以共存，也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同意Class文件中。</p></li></ul><h4 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">--------------方法表集合-------------------       </div><div class="line"><span class="number">00</span> <span class="number">02</span>(计数器容量：<span class="number">2</span>个方法,inc()和编译器增加的实例构造器&lt;init&gt;)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(访问标志：ACC_PUBLIC) </div><div class="line"><span class="number">00</span> <span class="number">07</span>(名称索引：常量池第<span class="number">7</span>项,&lt;init&gt;)</div><div class="line"><span class="number">00</span> <span class="number">08</span>(描述符索引：常量池第<span class="number">8</span>项,()v)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(属性表计数器：<span class="number">1</span>项属性)</div></pre></td></tr></table></figure><h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><p><code>attribute_info</code>，用于描述某些场景专有的信息</p><h4 id="位置-5"><a href="#位置-5" class="headerlink" title="位置"></a>位置</h4><p>方法表之后</p><h4 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h4><p>为了能正确解析Class文件，<a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">在最新的JVM规范中，预定义了一些属性4.7</a>。</p><p><strong>其中，4个属性对于Java正确解释类文件至关重要</strong></p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Code</td><td>方法表</td><td>Java代码编译成的字节码指令</td></tr><tr><td>ConstantValue</td><td>字段表</td><td>final关键字定义的常量值</td></tr><tr><td>StackMapTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td>BootstrapMethods</td><td>类文件</td><td>JDK1.7新增，用于保存invokedynamic指令引用的引导方法限定符</td></tr></tbody></table><p><strong>其中，9个属性对JVM解释Class文件不重要，但对Java SE的类库或者工具解释Class文件有用，可选</strong></p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td>InnerClasses</td><td>类文件</td><td>内部类列表</td></tr><tr><td>EnclosingMethod</td><td>类文件</td><td>仅当一个类为局部类或者匿名类时才能拥有这个属性，标识着歌类所在的外围方法</td></tr><tr><td>Synthetic</td><td>类、方法表、字段表</td><td>标识方法或字段为编译器自动生成的</td></tr><tr><td>Signature</td><td>类、方法表、字段表</td><td>JDK1.5新增，用于支持泛型情况下的方法签名。在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或参数化类型，由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，这个属性会记录泛型签名信息。</td></tr><tr><td>SourceFile</td><td>类文件</td><td>记录源文件名称</td></tr><tr><td>LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td>LocalVariableTable</td><td>类</td><td>方法的局部变量描述</td></tr><tr><td>LocalVariableTypeTable</td><td>类</td><td>JDK1.5新增，它使用特征签名代替描述符，是为了引入泛型语法后能描述泛型参数化类型而添加</td></tr></tbody></table><p><strong>其中，13个属性对JVM解释Class文件不重要，但包含有关类文件的元数据，这些元数据要么由Java SE平台的类库公开，要么由工具提供，可选</strong></p><table><thead><tr><th>属性名称</th><th>使用位置</th><th>含义</th></tr></thead><tbody><tr><td>SourceDebugExtension</td><td>类</td><td>JDK1.6新增，用于存储额外的调试信息。譬如在进行JSP文件调试时，无法通过Java堆栈定位到JSP文件的行号，JSR-45规范为这些非Java语言编写，却需要编译成字节码并运行在JVM中的程序提供了一个进行调试的标准机制。</td></tr><tr><td>Deprecated</td><td>类、方法表、字段表</td><td>被声明为deprecated的方法和字段</td></tr><tr><td>RuntimeVisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK1.5新增，为动态注解提供支持，用于指明哪些注解是运行时(反射调用)可见的</td></tr><tr><td>RuntimeInvisibleAnnotations</td><td>类、方法表、字段表</td><td>JDK1.5新增，为动态注解提供支持，用于指明哪些注解是运行时(反射调用)不可见的</td></tr><tr><td>RuntimeVisibleParameterAnnotations</td><td>方法表</td><td>JDK1.5新增，用于指明哪些方法参数是运行时(反射调用)可见的</td></tr><tr><td>RuntimeInvisibleParameterAnnotations</td><td>方法表</td><td>JDK1.5新增，用于指明哪些方法参数是运行时(反射调用)不可见的</td></tr><tr><td>RuntimeVisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>可变长度属性，记录使用的类型运行时可见注释。还记录泛型类、接口、方法和构造函数的类型参数声明的注释。最多有一个。</td></tr><tr><td>RuntimeInvisibleTypeAnnotations</td><td>类、方法表、字段表、Code属性</td><td>可变长度属性，记录使用的类型运行时不可见注释。还记录泛型类、接口、方法和构造函数的类型参数声明的注释。最多有一个。</td></tr><tr><td>AnnotationDefault</td><td>方法表</td><td>可变长度属性，记录使用的注释类型元素的默认值，最多只有一个</td></tr><tr><td>MethodParameters</td><td>方法表</td><td>可变长度属性，记录有关方法的形式参数的信息，例如它们的名称，最多只有一个</td></tr><tr><td>Module</td><td>类的属性表</td><td>可变长度属性，记录模块所需的模块；模块导出和打开的包；以及模块使用和提供的服务，最多只有一个</td></tr><tr><td>ModulePackages</td><td>类的属性表</td><td>可变长度属性，记录模块属性导出或打开的模块的所有包，以及记录在Module属性中的服务实现的所有包，还可以记录模块中既不导出也不打开或包含服务实现的包</td></tr><tr><td>ModuleMainClass</td><td>类的属性表</td><td>固定长度属性，记录模块的主类</td></tr></tbody></table><p><strong>属性表结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th></tr></thead><tbody><tr><td>u2</td><td>attribute_name_index</td><td>1</td></tr><tr><td>u4</td><td>attribute_length</td><td>1</td></tr><tr><td>u1</td><td>info</td><td>attribute_length</td></tr></tbody></table><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ul><li><p>不要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，JVM运行时会忽略掉不认识的属性</p></li><li><p>每个属性的名称需要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示，属性之的结构可以完全自定义，只需要通过一个u4长度的属性说明占用的位数即可。</p></li><li>具体属性格式可查询<a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">JVM规范(4.7.2-4.7.27)</a></li></ul><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">---Code属性开始---       </div><div class="line"><span class="number">00</span> <span class="number">09</span>(attribute_name_index：常量池第<span class="number">9</span>项，Code)</div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1</span>D(attribute_length：<span class="number">29</span>)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(max_stack：<span class="number">1</span>)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(max_locals：<span class="number">1</span>) </div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>(code_length：<span class="number">5</span>)</div><div class="line">---       </div><div class="line"><span class="number">2</span>A(对应指令为aload_0，将低<span class="number">0</span>个Slot槽位为reference类型的本地变量推送到栈的顶端)</div><div class="line">B7(对应指令为invokespecial，将栈顶的reference类型的数据所指向的对象作为方法的接收者，调用此对象的实例构造方法。这条指令带有一个u2类型的参数，为具体调用的哪一个方法，指向常量池中一个 </div><div class="line">CONSTANT_Methodref_info类型常量，即此方法的符号应用。 )</div><div class="line"><span class="number">00</span> <span class="number">01</span>(方法的符号引用,常量池中第<span class="number">1</span>项,java/lang/Object &lt;init&gt;V)</div><div class="line">B1(对应指令为<span class="keyword">return</span>，含义为返回此方法，返回值为<span class="keyword">void</span>。这条指令执行完后当前方法结束)</div><div class="line">---       </div><div class="line"><span class="number">00</span> <span class="number">00</span>(exception_table_length)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(attributes_count：<span class="number">1</span>)</div><div class="line">---       </div><div class="line"><span class="number">00</span> <span class="number">0</span>A(十进制：<span class="number">10</span>,常量池中第<span class="number">10</span>项,LineNumberTable)</div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span>(属性长度：<span class="number">6</span>)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(line_number_table_length：<span class="number">1</span>) </div><div class="line"><span class="number">00</span> <span class="number">00</span>(字节码编号：<span class="number">0</span>)</div><div class="line"><span class="number">00</span> <span class="number">03</span>(Java源码行号：<span class="number">3</span>)</div><div class="line">---Code属性结束---  </div><div class="line"><span class="number">00</span> <span class="number">01</span>(<span class="keyword">public</span>)</div><div class="line"><span class="number">00</span> <span class="number">0</span>B(name_index：<span class="number">11</span>,inc)</div><div class="line"><span class="number">00</span> <span class="number">0</span>C(description_index:<span class="number">12</span>,()I)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(属性计数器：<span class="number">1</span>) </div><div class="line">---Code属性开始---    </div><div class="line"><span class="number">00</span> <span class="number">09</span>(属性名称：常量池第<span class="number">9</span>项，Code)</div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">1F</span>(属性长度：<span class="number">31</span>)</div><div class="line"><span class="number">00</span> <span class="number">02</span>(max_stack,操作数栈深度的最大值：<span class="number">2</span>)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(max_locals,局部变量表所需的存储空间：<span class="number">1</span>(slot))</div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">07</span>(code_length：<span class="number">7</span>)</div><div class="line"><span class="number">2</span>A(对应指令为aload_0，将低<span class="number">0</span>个Slot槽位为reference类型的本地变量推送到栈的顶端)</div><div class="line">B4(getfield,获取对象字段的值)</div><div class="line"><span class="number">00</span> <span class="number">02</span>(方法的符号引用,常量池中第<span class="number">2</span>项,m和i)</div><div class="line"><span class="number">04</span>(iconst_1,<span class="number">1</span>(<span class="keyword">int</span>)值入栈)  </div><div class="line"><span class="number">60</span>(iadd,将栈顶两<span class="keyword">int</span>类型数相加，结果入栈)</div><div class="line">AC(ireturn,返回<span class="keyword">int</span>类型值)</div><div class="line"><span class="number">00</span> <span class="number">00</span>(exception_table_length)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(attribute_count)</div><div class="line"><span class="number">00</span> <span class="number">0</span>A(十进制：<span class="number">10</span>,常量池中第<span class="number">10</span>项,LineNumberTable)</div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">06</span>(属性长度：<span class="number">6</span>)</div><div class="line"><span class="number">00</span> <span class="number">01</span>(line_number_table_length：<span class="number">1</span>) </div><div class="line"><span class="number">00</span> <span class="number">00</span>(字节码编号：<span class="number">0</span>)</div><div class="line"><span class="number">00</span> <span class="number">07</span>(Java源码行号：<span class="number">7</span>)</div><div class="line">---Code属性结束---       </div><div class="line">--sourceFile--       </div><div class="line"><span class="number">00</span> <span class="number">01</span>(<span class="keyword">public</span>)</div><div class="line"><span class="number">00</span> <span class="number">0</span>D(name_index：<span class="number">13</span>,SourceFile) </div><div class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">02</span>(attribute_index:<span class="number">2</span>)</div><div class="line"><span class="number">00</span> <span class="number">0</span>E (soucefile_index:<span class="number">14</span>,TestClass.java)</div></pre></td></tr></table></figure><blockquote><p><code>Slot</code>：JVM为局部变量分配内存所使用的最小单位，长度不超过32位的数据类型(byte、char、float、int、short、boolean和returnAddress)占用1Slot，64位的数据类型(double、long)需要2Slot来存放。当代码执行超过一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用与来分配Slot给各个变量使用，然后计算max_locals的大小.</p></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://chrome.google.com/webstore/detail/binary-converter/nmmgiednmhaeepkimifjolpedolomdhk" target="_blank" rel="external">Chrome Plugin-Binary Converter</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se10/jvms10.pdf" target="_blank" rel="external">JVM规范-JDK1.10</a></p><p><a href="https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings" target="_blank" rel="external">Java bytecode instruction listings</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class文件详述(1)</title>
      <link href="/JVM/classDetail1.html"/>
      <url>/JVM/classDetail1.html</url>
      
        <content type="html"><![CDATA[<ul><li>魔数</li><li>版本</li><li>常量池</li><li>访问标志</li></ul><a id="more"></a><p>示例源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"Hello World"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>示例Class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function">CA FE BA <span class="title">BE</span><span class="params">(Class魔数)</span> </span></div><div class="line"><span class="function">--------------版本号-------------------</span></div><div class="line"><span class="function">00 00（次版本号） </span></div><div class="line"><span class="function">00 34（主版本号)</span></div><div class="line"><span class="function">--------------常量池-------------------</span></div><div class="line"><span class="function">00 22（十进制34，33个常量） </span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span> </span></div><div class="line"><span class="function">00 02（常量池中第二项） </span></div><div class="line"><span class="function">01（CONSTANT_Utf8_info） </span></div><div class="line"><span class="function">00 09（字符串长度9字节） </span></div><div class="line"><span class="function">74<span class="params">(t)</span> 65<span class="params">(e)</span> 73<span class="params">(s)</span> 74<span class="params">(t)</span> 2<span class="title">F</span><span class="params">(/)</span> 54<span class="params">(T)</span> 65<span class="params">(e)</span> 73<span class="params">(s)</span> 74<span class="params">(t)</span> </span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span> </span></div><div class="line"><span class="function">00 04<span class="params">(常量池中第<span class="number">4</span>项)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 10<span class="params">(字符串长度是<span class="number">16</span>字节)</span> </span></div><div class="line"><span class="function">6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 6<span class="title">C</span><span class="params">(l)</span> 61<span class="params">(a)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 2<span class="title">F</span><span class="params">(/)</span> 4<span class="title">F</span><span class="params">(O)</span> 62<span class="params">(b)</span> 6<span class="title">A</span><span class="params">(j)</span> 65<span class="params">(e)</span> 63<span class="params">(c)</span> 74<span class="params">(t)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 06<span class="params">(字符串长度<span class="number">6</span>字节)</span> </span></div><div class="line"><span class="function">3<span class="title">C</span><span class="params">(&lt;)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 69<span class="params">(i)</span> 74<span class="params">(t)</span> 3<span class="title">E</span><span class="params">(&gt;)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(字符串长度<span class="number">3</span>字节)</span> </span></div><div class="line"><span class="function">28<span class="params">(()</span> 29<span class="params">()</span>) 56<span class="params">(V)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 04<span class="params">(字符串长度<span class="number">4</span>字节)</span> </span></div><div class="line"><span class="function">43<span class="params">(C)</span> 6<span class="title">F</span><span class="params">(o)</span> 64<span class="params">(d)</span> 65<span class="params">(e)</span></span></div><div class="line"><span class="function">0<span class="title">A</span><span class="params">(CONSTANT_Methodref_info)</span> </span></div><div class="line"><span class="function">00 03<span class="params">(<span class="number">3</span>，指向声明方法的类描述符CONSTANT_Class_info的索引项)</span></span></div><div class="line"><span class="function">00 09<span class="params">(<span class="number">9</span>，指向名称及类型描述符CONSTANT_NameAndType_info的索引项)</span></span></div><div class="line"><span class="function">0<span class="title">C</span><span class="params">(CONSTANT_NameAndType_info字段或符号的部分引用)</span> </span></div><div class="line"><span class="function">00 05<span class="params">(<span class="number">5</span>，指向该字段或方法名称常量项的索引)</span></span></div><div class="line"><span class="function">00 06<span class="params">(<span class="number">6</span>，指向该字段或方法描述符常量项的索引)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 0<span class="title">F</span><span class="params">(字符串长度<span class="number">15</span>字节)</span></span></div><div class="line"><span class="function">4<span class="title">C</span><span class="params">(L)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 65<span class="params">(e)</span> 4<span class="title">E</span><span class="params">(N)</span> 75<span class="params">(u)</span> 6<span class="title">D</span><span class="params">(m)</span> 62<span class="params">(b)</span> 65<span class="params">(e)</span> 72<span class="params">(r)</span> 54<span class="params">(T)</span> 61<span class="params">(a)</span> 62<span class="params">(b)</span> 6<span class="title">C</span><span class="params">(l)</span> 65<span class="params">(e)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 12<span class="params">(字符串长度<span class="number">18</span>字节)</span></span></div><div class="line"><span class="function">4<span class="title">C</span><span class="params">(L)</span> 6<span class="title">F</span><span class="params">(o)</span> 63<span class="params">(c)</span> 61<span class="params">(a)</span> 6<span class="title">C</span><span class="params">(l)</span> 56<span class="params">(V)</span> 61<span class="params">(a)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 61<span class="params">(a)</span> 62<span class="params">(b)</span> 6<span class="title">C</span><span class="params">(l)</span> 65<span class="params">(e)</span> 54<span class="params">(T)</span> 61<span class="params">(a)</span> 62<span class="params">(b)</span> 6<span class="title">C</span><span class="params">(l)</span> 65<span class="params">(e)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 04<span class="params">(字符串长度<span class="number">4</span>字节)</span> </span></div><div class="line"><span class="function">74<span class="params">(t)</span> 68<span class="params">(h)</span> 69<span class="params">(i)</span> 73<span class="params">(s)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 0<span class="title">B</span><span class="params">(字符串长度<span class="number">11</span>字节)</span></span></div><div class="line"><span class="function">4<span class="title">C</span><span class="params">(L)</span> 74<span class="params">(t)</span> 65<span class="params">(e)</span> 73<span class="params">(s)</span> 74<span class="params">(t)</span> 2<span class="title">F</span><span class="params">(/)</span> 54<span class="params">(T)</span> 65<span class="params">(e)</span> 73<span class="params">(s)</span> 74<span class="params">(T)</span> 3<span class="title">B</span><span class="params">(;)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 04<span class="params">(字符串长度<span class="number">4</span>字节)</span> </span></div><div class="line"><span class="function">6<span class="title">D</span><span class="params">(m)</span> 61<span class="params">(a)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 16<span class="params">(字符串长度<span class="number">22</span>字节)</span> </span></div><div class="line"><span class="function">28<span class="params">(()</span> 5<span class="title">B</span><span class="params">([)</span> 4<span class="title">C</span><span class="params">(L)</span> 6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 6<span class="title">C</span><span class="params">(l)</span> 61<span class="params">(a)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 2<span class="title">F</span><span class="params">(/)</span> 53<span class="params">(S)</span> 74<span class="params">(t)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 3<span class="title">B</span><span class="params">(;)</span> 29<span class="params">()</span>) 56<span class="params">(V)</span> </span></div><div class="line"><span class="function">09<span class="params">(CONSTANT_Fieldref_info)</span> </span></div><div class="line"><span class="function">00 11<span class="params">(<span class="number">17</span>，指向声明字段的类或者接口描述符CONSTANT_Class_info的索引项)</span> </span></div><div class="line"><span class="function">00 13<span class="params">(<span class="number">19</span>，指向字段描述符CONSTANT_NameAndType的索引项)</span> </span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span> </span></div><div class="line"><span class="function">00 12<span class="params">(<span class="number">18</span>，指向全限定名常量项的索引)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 10<span class="params">(字符串长度<span class="number">16</span>字节)</span></span></div><div class="line"><span class="function">6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 6<span class="title">C</span><span class="params">(l)</span> 61<span class="params">(a)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 2<span class="title">F</span><span class="params">(/)</span> 53<span class="params">(s)</span> 79<span class="params">(y)</span> 73<span class="params">(s)</span> 74<span class="params">(t)</span> 65<span class="params">(e)</span> 6<span class="title">D</span><span class="params">(m)</span></span></div><div class="line"><span class="function">0<span class="title">C</span><span class="params">(CONSTANT_NameAndType_info)</span> </span></div><div class="line"><span class="function">00 14<span class="params">(<span class="number">20</span>，指向该字段或方法名称常量项的索引)</span></span></div><div class="line"><span class="function">00 15<span class="params">(<span class="number">21</span>，指向该字段或方法描述符常量项的索引)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 03<span class="params">(字符串长度<span class="number">3</span>字节)</span> </span></div><div class="line"><span class="function">6<span class="title">F</span><span class="params">(o)</span> 75<span class="params">(u)</span> 74<span class="params">(t)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 15<span class="params">(字符串长度<span class="number">21</span>字节)</span> </span></div><div class="line"><span class="function">4<span class="title">C</span><span class="params">(L)</span> 6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 69<span class="params">(i)</span> 6<span class="title">F</span><span class="params">(o)</span> 2<span class="title">F</span><span class="params">(/)</span> 50<span class="params">(P)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 74<span class="params">(t)</span> 53<span class="params">(S)</span> 74<span class="params">(t)</span> 72<span class="params">(r)</span> 65<span class="params">(e)</span> 61<span class="params">(a)</span> 6<span class="title">D</span><span class="params">(m)</span> 3<span class="title">B</span><span class="params">(;)</span> </span></div><div class="line"><span class="function">08<span class="params">(CONSTANT_String_info)</span></span></div><div class="line"><span class="function">00 17<span class="params">(<span class="number">23</span>，指向字符串字面量的索引)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 0<span class="title">B</span><span class="params">(字符串长度<span class="number">11</span>字节)</span>  </span></div><div class="line"><span class="function">48<span class="params">(H)</span> 65<span class="params">(e)</span> 6<span class="title">C</span><span class="params">(l)</span> 6<span class="title">C</span><span class="params">(l)</span> 6<span class="title">F</span><span class="params">(o)</span> 20<span class="params">( )</span> 57<span class="params">(W)</span> 6<span class="title">F</span><span class="params">(o)</span> 72<span class="params">(r)</span> 6<span class="title">C</span><span class="params">(l)</span> 64<span class="params">(d)</span> </span></div><div class="line"><span class="function">0<span class="title">A</span><span class="params">(CONSTANT_Methodref_info)</span></span></div><div class="line"><span class="function">00 19<span class="params">(<span class="number">25</span>，指向声明方法的类描述符CONSTANT_Class_info的索引项)</span></span></div><div class="line"><span class="function">00 1<span class="title">B</span><span class="params">(<span class="number">27</span>，指向名称及类型描述符CONSTANT_NameAndType的索引项)</span></span></div><div class="line"><span class="function">07<span class="params">(CONSTANT_Class_info)</span></span></div><div class="line"><span class="function">00 1<span class="title">A</span><span class="params">(<span class="number">26</span>，指向全限定名常量项的索引)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 13<span class="params">(字符串长度<span class="number">19</span>字节)</span></span></div><div class="line"><span class="function">6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 69<span class="params">(i)</span> 6<span class="title">F</span><span class="params">(o)</span> 2<span class="title">F</span><span class="params">(/)</span> 50<span class="params">(P)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 74<span class="params">(t)</span> 53<span class="params">(S)</span> 74<span class="params">(t)</span> 72<span class="params">(r)</span> 65<span class="params">(e)</span> 61<span class="params">(a)</span> 6<span class="title">D</span><span class="params">(m)</span> </span></div><div class="line"><span class="function">0<span class="title">C</span><span class="params">(CONSTANT_NameAndType_info)</span> </span></div><div class="line"><span class="function">00 1<span class="title">C</span><span class="params">(<span class="number">28</span>，指向该字段或方法名称常量项的索引)</span></span></div><div class="line"><span class="function">00 1<span class="title">D</span><span class="params">(<span class="number">29</span>，指向该字段或方法描述符常量项的索引)</span></span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 07<span class="params">(字符串长度<span class="number">7</span>字节)</span> </span></div><div class="line"><span class="function">70<span class="params">(p)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 74<span class="params">(t)</span> 6<span class="title">C</span><span class="params">(l)</span> 6<span class="title">E</span><span class="params">(n)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 15<span class="params">(字符串长度<span class="number">21</span>字节)</span> </span></div><div class="line"><span class="function">28<span class="params">(()</span> 4<span class="title">C</span><span class="params">(L)</span> 6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 6<span class="title">C</span><span class="params">(l)</span> 61<span class="params">(a)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 2<span class="title">F</span><span class="params">(/)</span> 53<span class="params">(S)</span> 74<span class="params">(t)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 3<span class="title">B</span><span class="params">(;)</span> 29<span class="params">()</span>) 56<span class="params">(V)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span> </span></div><div class="line"><span class="function">00 04<span class="params">(字符串长度<span class="number">4</span>字节)</span> </span></div><div class="line"><span class="function">61<span class="params">(a)</span> 72<span class="params">(r)</span> 67<span class="params">(g)</span> 73<span class="params">(s)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 13<span class="params">(字符串长度<span class="number">19</span>字节)</span> </span></div><div class="line"><span class="function">5<span class="title">B</span><span class="params">([)</span> 4<span class="title">C</span><span class="params">(L)</span> 6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> 2<span class="title">F</span><span class="params">(/)</span> 6<span class="title">C</span><span class="params">(l)</span> 61<span class="params">(a)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 2<span class="title">F</span><span class="params">(/)</span> 53<span class="params">(S)</span> 74<span class="params">(t)</span> 72<span class="params">(r)</span> 69<span class="params">(i)</span> 6<span class="title">E</span><span class="params">(n)</span> 67<span class="params">(g)</span> 3<span class="title">B</span><span class="params">(;)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 0<span class="title">A</span><span class="params">(字符串长度<span class="number">10</span>字节)</span>  </span></div><div class="line"><span class="function">53<span class="params">(S)</span> 6<span class="title">F</span><span class="params">(o)</span> 75<span class="params">(u)</span> 72<span class="params">(r)</span> 63<span class="params">(c)</span> 65<span class="params">(e)</span> 46<span class="params">(F)</span> 69<span class="params">(i)</span> 6<span class="title">C</span><span class="params">(l)</span> 65<span class="params">(e)</span> </span></div><div class="line"><span class="function">01<span class="params">(CONSTANT_Utf8_info)</span></span></div><div class="line"><span class="function">00 09<span class="params">(字符串长度<span class="number">9</span>字节)</span>   </span></div><div class="line"><span class="function">54<span class="params">(T)</span> 65<span class="params">(e)</span> 73<span class="params">(s)</span> 74<span class="params">(t)</span> 2<span class="title">E</span><span class="params">(.)</span> 6<span class="title">A</span><span class="params">(j)</span> 61<span class="params">(a)</span> 76<span class="params">(v)</span> 61<span class="params">(a)</span> </span></div><div class="line"><span class="function">--------------访问标志-------------------</span></div><div class="line"><span class="function">00 21<span class="params">(ACC_PUBLIC、ACC_SUPER，<span class="number">0x0001</span>|<span class="number">0x0020</span>=<span class="number">0x0021</span>)</span></span></div></pre></td></tr></table></figure><h3 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CA FE BA BE</div></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>确定这个文件是否位一个能被虚拟机接受的Class文件</p><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>每个Class文件的头4个字节</p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p><strong>安全</strong>。使用魔数而不是后缀名的理由是后缀名可以随意改动，而文件格式的制定者可以自由的选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。</p><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>在Java语言还称作“Oak”时(1991年前后)确定，据Java开发小组最初的关键成员Patrick Naughton说：“我们一直寻找一些好玩的、容易记忆的东西，它象征着著名咖啡品牌Peet’s Coffee深受欢迎的Baristas咖啡。“</p><h3 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00(次版本号) 00 34(主版本号)</div></pre></td></tr></table></figure><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>标志JDK版本</p><h4 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h4><ul><li>Minor Version次版本号：每个Class文件的第5、6字节</li><li>Major Version主版本号：每个Class文件的第7、8字节</li></ul><h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4><ul><li>起始版本号：45</li><li>JDK1.1后每个大版本发布主版本号向上加1<ul><li>JDK1.0~1.1使用了45.0～45.3</li></ul></li></ul><h4 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h4><p>高版本的JDK能<strong>向下兼容</strong>以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件</p><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>All：<a href="www.sublimetext.com">Sublime Text</a></p><p>Windows：<a href="www.winhex.com">WinHex</a></p><p>Mac：<a href="http://ridiculousfish.com/hexfiend/" target="_blank" rel="external">Hex Fiend</a></p><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><table><thead><tr><th>编译器版本</th><th>十进制</th></tr></thead><tbody><tr><td>1.1</td><td>45</td></tr><tr><td>1.2</td><td>46</td></tr><tr><td>1.3</td><td>47</td></tr><tr><td>1.4</td><td>48</td></tr><tr><td>1.5</td><td>49</td></tr><tr><td>1.6</td><td>50</td></tr><tr><td>1.7</td><td>51</td></tr><tr><td>1.8</td><td>52</td></tr><tr><td>1.9</td><td>53</td></tr></tbody></table><blockquote><p>如果带<code>-target 1.x</code>，Class文件的版本号是目标编译器版本号。</p><p>如：JDK1.7.0</p><ul><li>默认为-target 1.7，则版本号为51.0</li><li>-target 1.6，则版本号为50.0</li><li>-target 1.4，则版本号为48</li></ul></blockquote><p>上图中主版本号为：<code>0x0034</code>，即十进制<code>52</code>，也就是1.8</p><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 22</div></pre></td></tr></table></figure><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><p>Class文件之中的资源仓库</p><h4 id="位置-2"><a href="#位置-2" class="headerlink" title="位置"></a>位置</h4><p>偏移地址：0x00000008</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>Class文件结构中与其他项目关联最多的数据类型</p></li><li><p>占用Class文件空间最大的数据项目之一</p></li><li><p>在Class文件中第一个出现的表类型数据项目</p></li></ul><h4 id="规律-1"><a href="#规律-1" class="headerlink" title="规律"></a>规律</h4><p>常量池中常量是不固定的，所以在需要在入口放置一个类型为<code>u2</code>的数据，代表常量池容量计数值(constant_pool_count)，计数从<code>1</code>开始。</p><blockquote><ul><li>满足后面某些指向常量池的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。</li><li>Class文件结构中只有常量池的容量计数是从1开始的，对于其他集合类型的容量计数，都是从0开始的（包括索引集合、字段表集合、方法表集合等）</li></ul></blockquote><p>例如上面的<code>0x0022</code>,即10进制的<code>34</code>，代表常量池中有<code>33</code>项常量，索引值范围为<code>1～33</code>。</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>常量池中主要存放两大类常量<ul><li>字面量（Literal）：比较接近Java语言层面的常量概念<ul><li>文本字符串、生命为final的常量值等</li></ul></li><li>符号引用（Symbolic Referrences）：编译原理方面的概念<ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ul></li></ul></li></ul><p>Java代码在进行Javac编译的时候，在虚拟机加载Class文件的时候进行动态连接，所以，在Class文件中不会保存各个方法、字段的最终内存布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p><p><strong>下面表格为常量池的项目类型</strong>    </p><table><thead><tr><th>类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串类型字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类中方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口中方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的部分符号引用</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>表示方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>标志方法类型</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>表示一个动态方法调用点</td></tr></tbody></table><p>具体每个常量项的结构，请见Java虚拟机规范。举例：<a href="https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf" target="_blank" rel="external">JVM Specification-1.7-4.41</a></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">07 00 02 01 00 09 74 65 73 74 2F 54 65 73 74</div></pre></td></tr></table></figure><p><code>0x07</code>：<code>CONSTANT_Class_info</code>，类或接口的引用</p><p><strong>下面表格为CONSTANT_Class_info型常量的结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>作用</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td><td>区分常量类型</td></tr><tr><td>u2</td><td>name_index</td><td>1</td><td>全限定名</td></tr></tbody></table><p><code>0x0002</code>：指向常量池中第二项</p><p><code>0x01</code>：<code>CONSTANT_Utf8_info</code>类型的常量</p><p><strong>下面表格为<code>CONSTANT_Utf8_info</code>型常量的结构</strong></p><table><thead><tr><th>类型</th><th>名称</th><th>数量</th><th>作用</th></tr></thead><tbody><tr><td>u1</td><td>tag</td><td>1</td><td>区分常量类型</td></tr><tr><td>u2</td><td>length</td><td>1</td><td>UTF-8的字符串长度是多少字节</td></tr><tr><td>u1</td><td>bytes</td><td>length</td><td>使用UTF-8缩略码表示的字符串</td></tr></tbody></table><blockquote><p><strong>UTF-8缩略编码</strong>：</p><ul><li>从<code>\u0001</code>到<code>\u007f</code>(1~127的ASCII码)的用一个字节表示</li><li>从<code>\u0080</code>到<code>\u07ff</code>之间的所有字符用两个字节表示</li><li>从<code>\u0800</code>到<code>\uffff</code>之间的所有字符用三个字节表示</li></ul></blockquote><p><code>0x0009</code>：UTF-8的字符串长度是9字节</p><p><code>0x74</code>：十进制为116，查询ASC码表可知，为字母<code>t</code>。</p><p>将<code>74 65 73 74 2F 54 65 73 74</code>逐个翻译后为：<code>test/Test</code>，也就是文章开头源码的全限定名。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fv07a7wxmij20w30mngvj.jpg" alt=""></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">07 00 04 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</div></pre></td></tr></table></figure><p><code>0x07</code>：<code>CONSTANT_Class_info</code>，类或接口的引用</p><p><code>0x0004</code>：常量池中第4项</p><p><code>0x01</code>：<code>CONSTANT_Utf8_info</code>型的常量</p><p><code>0x0010</code>：UTF-8的字符串长度是16字节</p><p><code>6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</code>：按照十六进制转为十进制，再查找ASC码表可知内容为：<code>java/lang/Object</code>。</p><blockquote><p>由于Class文件中方法、字段等都需要引用<code>CONSTANT_Utf8_info</code>型常量来描述名称，所以<code>CONSTANT_Utf8_info</code>型常量的最大长度也就是Java中方法、字段名的最大长度，也就是<code>length</code>的最大值，即<code>65535</code>。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将无法编译。</p></blockquote><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>可以用JDK自带工具<code>javap -v ClassName</code>来检查手动翻译内容是否正确，如下图所示</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fv07ankao0j211y140tgl.jpg" alt=""></p><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ul><li>识别一些类或者接口层次的访问信息<ul><li>这个Class是类还是接口<ul><li>类：是否被声明为final</li></ul></li><li>是否定义为<code>public</code>类型</li><li>是否定义为<code>abstract</code>类型</li><li>…</li></ul></li></ul><h4 id="位置-3"><a href="#位置-3" class="headerlink" title="位置"></a>位置</h4><p>常量池结束之后，紧跟着的两个字节代表访问标志(access_flags)</p><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><table><thead><tr><th>名称</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>是否为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>是否被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>是否允许使用invokespecial字节码指令的新语意，invokespecial指令的语意在JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，JDK1.0.2之后便意出来的类的这个标志必须为真</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标识这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象来说，次标志值为真，其他类值为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标识这个类并非由用户代码产生的</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标识这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标识这是一个枚举</td></tr><tr><td>ACC_MODULE(JDK1.10新增)</td><td>0x8000</td><td>标识这是一个模块，不是类或者接口</td></tr></tbody></table><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p><code>Test.class</code>是一个普通的Java类，不是借口、枚举或者注解，被<code>public</code>关键字修饰但没有被声明为<code>final</code>或<code>abstract</code>，并且它使用了JDK 1.8之后的编译器进行编译，因此它的<code>ACC_PUBLIC</code>、<code>ACC_SUPER</code>标志应当为真，而<code>ACC_FINAL</code>、<code>ACC_INTERFACE</code>、<code>ACC_ABSTRACT</code>、<code>ACC_SYNTHETIC</code>、<code>ACC_ANNOTATION</code>、<code>ACC_ENUM</code>这6个标志位应当为假，因此它的<code>access_flags</code>的值应当为：<code>0x0001|0x0020=0x0021</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="external">维基百科-Java Class File</a></p><p><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="external">Oracle-虚拟机规范</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class文件概述</title>
      <link href="/JVM/classSummary.html"/>
      <url>/JVM/classSummary.html</url>
      
        <content type="html"><![CDATA[<p><code>.java</code> &gt; <code>.class</code> &gt; <code>JVM</code> </p><a id="more"></a><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>实现语言无关性的基础仍然是<strong>虚拟机</strong>和<strong>字节码存储格式</strong>。</p><p>Java虚拟机只和Class二进制文件关联，Class文件中包含了<strong>Java虚拟机指令集</strong>和<strong>符号表</strong>以及<strong>若干其它辅助信息</strong>。</p><p>Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此<strong>字节码命令所能提供的语义描述肯定会比Java语言本身更加强大</strong>。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（也可以通过类加载器直接生成）。</p></blockquote><p>Class文件是一组<strong>以8位字节为基础单位的二进制流</strong>，各个数据项目严格按照顺序紧凑地排列，<strong>中间没有任何分隔符</strong>，Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照<strong>高位在前</strong>的方式分割成若干个8个字节进行存储。</p><blockquote><p>大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p><p>小端模式（Little-endian）, 是指数据的高字节保存在内存的高地址中,而数据的低字节保存在内在的低地址中,这种存储模式将地址的高低和数据位 权有效结合起来,高地址部分权值高,低地址部分权值低,和我们的逻辑方法一致;</p></blockquote><p>Java虚拟机规范规定：Class文件个是采用一种类似于C语言结构体的伪结构来存储数据，结构体中只有两种数据：<strong>无符号数</strong>和<strong>表</strong>。</p><h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><ul><li>基本的数据类型</li><li>u1：1个字节；u2：2个字节；u4：4个字节；u8：8个字节</li><li>描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</li></ul><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><ul><li><strong>多个无符号数</strong>或者<strong>其他表作为数据项</strong>构成的复合数据类型</li><li>惯例以<code>_info</code>结尾</li><li>用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">含义</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td style="text-align:center">u4</td><td style="text-align:center">magic</td><td style="text-align:center">魔数</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">minor_version</td><td style="text-align:center">Class文件的小版本</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">major_version</td><td style="text-align:center">Class文件的主版本</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">constant_pool_count</td><td style="text-align:center">常量池数量</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">cp_info</td><td style="text-align:center">constant_pool</td><td style="text-align:center">常量池</td><td style="text-align:center">constant_pool_count-1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">access_flags</td><td style="text-align:center">访问标志</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">this_class</td><td style="text-align:center">类索引集合</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">super_class</td><td style="text-align:center">父类索引集合</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces_count</td><td style="text-align:center">接口索引集合数量</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">interfaces</td><td style="text-align:center">接口索引集合</td><td style="text-align:center">interfaces_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">fields_count</td><td style="text-align:center">字段表集合数量</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">field_info</td><td style="text-align:center">fields</td><td style="text-align:center">字段表集合</td><td style="text-align:center">fields_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">methods_count</td><td style="text-align:center">方法表集合数量</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">mthod_info</td><td style="text-align:center">methods</td><td style="text-align:center">方法表集合</td><td style="text-align:center">methods_count</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes_count</td><td style="text-align:center">属性表集合数量</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">u2</td><td style="text-align:center">attributes</td><td style="text-align:center">属性表集合</td><td style="text-align:center">attributes_count</td></tr></tbody></table><blockquote><p>无论是无符号数还是表，当需要描述同一类型单数量不定的多个数据时，经常会使用<strong>一个前置的容量计数器</strong>加<strong>若干个连续的数据项</strong>的形式，这时称这一系列连续的某一类型的数据位某一类型的集合。</p></blockquote><p>由于没有分隔符，所以Class文件中的内容(上表)的顺序或者数量，甚至是数据存储的字节序(Byte Ordering,Class文件中字节序位Big-Endiam)，哪个字节代表的含义、长度、先后顺序，都是被严格限定的，都不可以改变。</p><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><ul><li><p><a href="https://super2bai.github.io/JVM/classDetail1.html">魔数、版本、常量池</a></p></li><li><p>访问标志</p></li><li>类索引、父类索引与接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se7/jvms7.pdf" target="_blank" rel="external">JVM Specification-1.7</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018.08内蒙避暑之旅</title>
      <link href="/travel/IM.html"/>
      <url>/travel/IM.html</url>
      
        <content type="html"><![CDATA[<p>人生第一次自驾游，选择 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/12720.html" target="_blank" rel="external">内蒙古</a> 绝对是一个很正确的决定。这次的行程历时九天，因为路途比较远还是略有些赶。</p><a id="more"></a><p>具体的行程如下：</p><ul><li>DAY1： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10065.html" target="_blank" rel="external">北京</a> —— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a>  </li><li>DAY2： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> —— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市 </li><li>DAY3： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 森林公园 </li><li>DAY4： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 森林公园—— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市 </li><li>DAY5： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> —— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a>  </li><li>DAY6： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> —— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 白狼镇 </li><li>DAY7： 白狼镇—— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 管理区 </li><li>DAY8： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 管理区—— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a>  </li><li>DAY9： <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> —— <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10065.html" target="_blank" rel="external">北京</a>  </li></ul><p>因为是旺季，酒店大概是淡季的三倍，三个人住宿大概3500，门票大概2500，过路费油费吃饭一共大概3500，没有记账分不太清。</p><h3 id="第一天：北京到锡林浩特，在路上"><a href="#第一天：北京到锡林浩特，在路上" class="headerlink" title="第一天：北京到锡林浩特，在路上"></a>第一天：北京到锡林浩特，在路上</h3><p>一早从 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10065.html" target="_blank" rel="external">北京</a> 出发，走京藏高速—张石高速—锡张高速，除了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10065.html" target="_blank" rel="external">北京</a> 市里有点堵，一路畅通，是路况最好的一段路。全程大概594公里，我们开得不算快，所以一天都在路上，但是路上的风景就足够好了，高速两边有观景台可以停车拍照。 </p><p>天气不太好，一路都是乌云，但是风景也别有特色，好像一路开到了世界尽头。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixlzviy8j211s0sb76y.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixm0mazyj211s0sbjwi.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fuixlzhddlj211s0sbafn.jpg" alt=""></p><p>晚上住在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> 新丝路酒店，商务型酒店，条件不错，位置也在市中心。 </p><p>晚饭在蒙格乐餐厅吃的蒙餐，味道不错石头烤牛肚、酸奶很好吃，酸奶饼特别特别好吃！</p><p> 因为到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> 已经下午六点多，第二天的路程也比较赶，就没有在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> 游玩。</p><h3 id="第二天：锡林浩特到阿尔山，继续赶路。"><a href="#第二天：锡林浩特到阿尔山，继续赶路。" class="headerlink" title="第二天：锡林浩特到阿尔山，继续赶路。"></a>第二天：锡林浩特到阿尔山，继续赶路。</h3><p>第二天一早在酒店吃过早餐继续赶路，走307省道—白霍一级路—203省道。<br>全程大概636公路，路况也很好，但是因为路程太远一天也都在路上，晚上7点到达 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市。<br>住在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 恒悦商务酒店。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市里的酒店非常多，大多都是家庭旅店，条件差不多。<br>说得都是 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/16215.html" target="_blank" rel="external">东北</a> 话，生意人也都比较实在，酒店定错了日期，去哪网不能改，给老板打电话二话不说就给调整了时间。<br>晚上在一家叫粘豆包铁锅炖的馆子吃得地锅，价格跟 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/16215.html" target="_blank" rel="external">东北</a> 差不多。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuixovzml2j211s0sbai0.jpg" alt=""></p><h3 id="第三天：阿尔山森林公园，开始游玩。"><a href="#第三天：阿尔山森林公园，开始游玩。" class="headerlink" title="第三天：阿尔山森林公园，开始游玩。"></a>第三天：阿尔山森林公园，开始游玩。</h3><p>第三天吃过早饭开车前往 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 森林公园，不得不吐槽 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 的早餐又贵又难吃，非常坑爹，所以最好找含早的酒店。</p><p> <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市开车到森林公园西门大概60多公里，景区门票285（门票+园区内观光车票），买票时登记身份证，门票有效期两天，但是景区里的每个景点只能进一次。 </p><p>私家车可以开进景区，但是只能停到景区内的服务区（天池服务区和 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63612.html" target="_blank" rel="external">兴安</a> 服务区），然后乘坐观光车游览。不过观光车早上7点半到下午5点行驶，在这时间外私家车开到景点门口是没人管的。所以可以开车去杜鹃湖看日落。 </p><p>我们住在天池服务区，天池服务区比较大，酒店也比较多，最重要的是观光车是在天池服务区发车的，所以有座位，我们住在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 峰情园酒店，强烈推荐这家，老板人非常好，热情爽快，饭也都在这吃的，在景区里价格也算是实惠了。</p><p>观光路线车有三条路线，当天中午到酒店吃过饭后只有半天时间游览，所以我们选择了天池—三潭峡—地池的路线。由于天气持续不好，所以也没有看到宣传海报上蓝色的天池，景色都沉浸在云雾里。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixt27v5nj211s0sbe2n.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixt209kzj211s0sbdyo.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixt0w33qj211s0sbdmd.jpg" alt=""></p><p>5点以后又开车去杜鹃湖，可惜也没看到日落的美景，只有昏暗的湖水，还有98年大火的遗迹。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixsyt6jtj211s0p6797.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuixsysv5rj211s0p643m.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixsyv6dcj211s0p6499.jpg" alt=""></p><p>可能由于阴雨的关系，非常冷，本想来避暑的我，感觉像是过了个冬。万幸带了秋裤，而且老板晚上给烧了暖气，非常暖和。 </p><p>家人前天被蚊子叮了个包发炎了，老板很好给拿了自己泡的药酒，我们第二天走的时候还给带了不少，真的非常感谢。</p><h3 id="第四天：阿尔山森林公园，继续游览。"><a href="#第四天：阿尔山森林公园，继续游览。" class="headerlink" title="第四天：阿尔山森林公园，继续游览。"></a>第四天：阿尔山森林公园，继续游览。</h3><p>第四天继续游览 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 森林公园，依旧是阴天，所以也没有早起看日出。如果天气好的话，可以在服务区旁边的不冻河观赏日出。<br>今天的游览路线是驼峰岭天池—龟背岩—石塘林。到驼峰岭以后还可以坐观光车到大峡谷，我们没有去。龟背岩在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/63612.html" target="_blank" rel="external">兴安</a> 服务区，游玩完直接在这里吃得午饭。3点多返回酒店开车离开森林公园回 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a>市。</p><p> <img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fuixwdrj2gj211s0p6gth.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixwdp2ufj211s0p6n7x.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixwgbtw0j211s0p67dh.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuixwghjzmj211s0p6amh.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixwgedm7j211s0p6akj.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuixwdyjlyj211s0p67bc.jpg" alt=""></p><p>晚上住在另一个家庭宾馆，隔音不太好。吃了顿烤串，叫源路缘久香，味道不错，尤其锡纸鲫鱼。价格不算便宜，可以接受。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuixwdy9h5j211s11sncw.jpg" alt=""></p><h3 id="第五天：阿尔山市—满洲里，边走边玩。"><a href="#第五天：阿尔山市—满洲里，边走边玩。" class="headerlink" title="第五天：阿尔山市—满洲里，边走边玩。"></a>第五天：阿尔山市—满洲里，边走边玩。</h3><p>第五天一早吃过又一顿坑爹的早饭以后去看了看 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 火车站，可惜在维修，被绿色的网子围着，没有见到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/21536.html" target="_blank" rel="external">中国</a> 最美的火车站有些遗憾。 </p><p>今天要出发开往 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> ，走203省道，沿途去了玫瑰峰和 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 口岸。玫瑰峰没有卖门票，就在外围看了玫瑰峰，买门票可以爬上去，不算高。玫瑰峰的石头是红色的，因此得名。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy13354hj211s0sbafx.jpg" alt=""></p><p><a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 口岸不在203省道沿途，需要绕路，不过不算太远。口岸连接 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14293.html" target="_blank" rel="external">蒙古</a> 国，门票40，可以做游览车到口岸国门和连接 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14293.html" target="_blank" rel="external">蒙古</a> 的口岸大桥。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuiy1162jhj211s0sbtg9.jpg" alt=""></p><p>返回203省道继续开往 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> ，这一段路非常荒凉，服务区都没建好呢，上厕所只能回归大自然。所以一定要加好油再出发，并且准备好路上吃的午饭。</p><p> <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> 大概420多公里，路况也不错，还有100公里的时候看到有一个金沙滩景区的指示牌，拐进去开了一下发现连售票处都还没建好呢，可以跨进门口拦的一道铁链走进景区，里面就是呼伦湖了，湖水和天 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/64550.html" target="_blank" rel="external">连城</a> 一片，湖边又有草原，真的很美。</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fuiy1128a6j211s0sbdjg.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuiy110fzej211s0sbaf2.jpg" alt=""></p><p>到了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> 已经是傍晚了，先去酒店办理了入住，住在金牛商务宾馆，就在步行街旁边很方便。 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> 有家很有名的俄餐叫卢布里西餐厅，但实在太火了我到走也没吃上。最后吃了蒙餐，吃饭的时候路灯已经亮了， <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> 的夜晚金碧辉煌的。晚上在步行街逛了逛，都是 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14293.html" target="_blank" rel="external">蒙古</a> 和 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10300.html" target="_blank" rel="external">俄罗斯</a> 商品的小店，讲价后不算贵，可以买些特产。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy13e8m0j211s0sc46y.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuiy13krnij211s0scajb.jpg" alt=""></p><h3 id="第六天：满洲里—白狼镇，从热闹到安静。"><a href="#第六天：满洲里—白狼镇，从热闹到安静。" class="headerlink" title="第六天：满洲里—白狼镇，从热闹到安静。"></a>第六天：满洲里—白狼镇，从热闹到安静。</h3><p>第六天上午去了套娃广场和国门景区。套娃广场门票140，其实是个游乐园，里面的游乐设施不太多，适合小朋友玩。中间的广场有很多套娃，也有演出可以看。如果没什么兴趣在门口看看超大的套娃型酒店就可以了。</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fuiy48rha7j211s0sbaj6.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy48iag3j211s0sb478.jpg" alt=""></p><p>国门景区门票80，小火车20，我觉得小火车没必要买，其实很近。景区里能看到41号界碑，登上国门可以看到对面的 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10300.html" target="_blank" rel="external">俄罗斯</a> 的国门。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy467pp1j211s0sb7bd.jpg" alt=""></p><p>离开 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/14939.html" target="_blank" rel="external">满洲里</a> 已经下午2点了，时间有点赶，走203省道经 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市再走303省道到白狼镇。303省道非常难走，尤其我们走的时候已经黑了，当时真有点后悔选了这个地方，还不如住在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/10390.html" target="_blank" rel="external">阿尔山</a> 市里。但是到了白狼镇鹿村的洮源度假新村觉得还是来值了，一下车就看到满天星星，也能看见银河，已经很多年没有见过这样漫天星斗了。</p><h3 id="第七天：白狼镇—乌拉盖管理区。"><a href="#第七天：白狼镇—乌拉盖管理区。" class="headerlink" title="第七天：白狼镇—乌拉盖管理区。"></a>第七天：白狼镇—乌拉盖管理区。</h3><p>早上起来在度假村里逛了逛，空气特别好。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuiy7xt24oj211s0sc46z.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy7xeu1tj211s0scwkr.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuiy7vpb4fj211s0sck58.jpg" alt=""></p><p>上午去了白狼峰景区，景区门票80，可以把车开到景区里山脚下的停车场。我们上去的时候下着大雾，除了我们只有另外一家人，其实山不太高，1000来级台阶，但是因为雾太大能见度最多20米，所以爬山的时候既看不到山顶也看不到山下，感觉像进了仙境。爬上山以后风把雾吹走了，看到了山下的风景，运气非常好。</p><p>白狼峰上都是冰川遗迹，有很多山地鼠兔，非常可爱。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuiy7v86qjj211s0scad1.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy7w8arvj211s0sc7mu.jpg" alt=""></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuiy7wo1h7j211s0scwi3.jpg" alt=""></p><p>从白狼峰下来回到鹿村随便找了家农家乐吃了个饭，鹿村非常小，没有几户人家，游客就更少了。去吃饭的时候厨师都上山去了，村里非常安静。以后有机会真想来这里住一个月。 </p><p>下午出发去 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 草原，走303省路到203省路再到101省路，晚上住在 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 管理区的豪驿宾馆。进入101省道就进入 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 草原腹地了，真的有无边无际的感觉。晚上在酒店旁边的火锅店吃了一顿我觉得最好吃的火锅，就在酒店旁边50米吧，是我吃过最好吃的牛肉，价格也便宜肉都是30-35。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuiy7v9dm7j211s0scq73.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiy7vedbtj211s0scdre.jpg" alt=""></p><h3 id="第八天：乌拉盖—锡林浩特，草原游乐。"><a href="#第八天：乌拉盖—锡林浩特，草原游乐。" class="headerlink" title="第八天：乌拉盖—锡林浩特，草原游乐。"></a>第八天：乌拉盖—锡林浩特，草原游乐。</h3><p>听从了酒店老板的建议，第八天上去了九曲湾景区。景区门票50，有180的套票，包含观光车蒙族迎宾骑马滑草民族服装拍照等，喜欢玩的话还是挺划算的。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fuiybupkcpj211s0p6th3.jpg" alt=""></p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fuiybudof9j211s0p643l.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fuiybtzg99j211s0p6q7u.jpg" alt=""></p><p>中午回 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/149470.html" target="_blank" rel="external">乌拉盖</a> 管理区吃了饭，然后走101省道-白霍一级路-307省道回到 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> ，不得不吐槽307省道，去的时候是新路路况超好的，回程的路是旧路，一对比非常有落差。</p><p> 晚上到了 <a href="http://www.mafengwo.cn/travel-scenic-spot/mafengwo/20235.html" target="_blank" rel="external">锡林浩特</a> 还是住了之前的酒店，去鲜羔楼吃的涮肉，也是便宜好吃。</p><h3 id="第九天：锡林浩特—北京。堵。"><a href="#第九天：锡林浩特—北京。堵。" class="headerlink" title="第九天：锡林浩特—北京。堵。"></a>第九天：锡林浩特—北京。堵。</h3><p>最后一天的行程就是回家，因为怕堵车早上点就出发，还是在进京的时候堵了好久，晚上6点才到家。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fuiyi26hi8j20u01hcn0o.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> travel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>故障案例总结</title>
      <link href="/JVM/problem.html"/>
      <url>/JVM/problem.html</url>
      
        <content type="html"><![CDATA[<p>实际运行中的解决方案</p><a id="more"></a><h2 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于交互性强、对停顿时间敏感的系统，可以给Java虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制的足够低，至少要低到不会影响用户使用。例如以天为频率就可以通过在深夜执行定时任务来触发Full GC甚至自动重启应用服务器来保持内存可用空间在一个稳定的水平。</p><p>控制Full GC频率的关键在于大多数对象的生存时间不应太长，尤其是不能有大批的、长生存时间的大对象产生，这样才能保证老年代的稳定。</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>在高性能硬件上部署程序，目前主要有两种方式：</p><ul><li>通过64位JDK来使用大内存</li><li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源</li></ul><h3 id="64位JDK来管理大内存"><a href="#64位JDK来管理大内存" class="headerlink" title="64位JDK来管理大内存"></a>64位JDK来管理大内存</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>内存回收导致的长时间停顿</li><li>现阶段，64位JDK的性能测试结果普遍低于32位JDK</li><li>需要保证程序足够稳定（因为这种应用要是产生堆溢出几乎就无法产生堆转储快照，快照文件10+GB，无法进行分析）</li><li>64位消耗的内存比32位大（指针膨胀、数据类型对齐补白等因素 ）</li></ul><h3 id="32位集群"><a href="#32位集群" class="headerlink" title="32位集群"></a>32位集群</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>一台物理机器上启动多个应用服务器进程，采用不同的端口，前端搭建负载均衡器，反向代理分配请求，使用无session的亲和式集群。</p><blockquote><p>亲和式集群：均衡器按一定的规则算法（一般根据SessionID分配）将一个固定的请求永远分配到固定的一个节点处理。</p></blockquote><p>由于一台物理机器，所以无需考虑下列问题：</p><ul><li>状态保留</li><li>热转移</li><li>精准的负载均衡</li></ul><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li>尽量避免节点竞争全局的资源<ul><li>磁盘竞争：各个节点如果同时反问某个磁盘文件（并发写操作），很容易导致IO异常</li></ul></li><li>很难最高效率地利用某些资源池<ul><li>连接池：一般都是在各个节点建立独立的连接池，这会导致一些节点池满了，而另外一个节点仍有较多空余。尽管可以使用集中式JNDI，但又一定复杂性并且可能带来额外的性能开销</li></ul></li><li>各个节点仍然不可避免的受到32位的内存限制<ul><li>在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆外内存开销，堆一般最多只能开到1.5G。在某些Linux或UNIX系统中，可以提升到3G乃至接近4G的内存，但32位中仍受到最高4G内存的限制</li></ul></li><li>大量使用本地缓存<ul><li>大量使用HashMap作为K/V缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点都有一份缓存，可以考虑把本地缓存改为集中式</li></ul></li></ul><h2 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[org.eclipose.jetty.util.log] handle fialed java.lang.OutOfMemoryError:null</div><div class="line">    at sun.misc.Unsafe.allocateMemory(Native Method)</div><div class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:99)</div><div class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:288)</div></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>NIO操作需要使用到Direct Memory内存，垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory只能等待老年代满了后Full GC，然后顺便清理内存的废弃对象。不然只能等到抛出内存溢出异常时，先<code>catch</code>掉，再在<code>catch</code>块里调用<code>System.gc()</code>。如果<code>-XX:DisableExplicitGC</code>被打开，虚拟机会忽略掉手动调用GC的代码，使得 System.gc()的调用就会变成一个空调用，完全不会触发任何GC，就只能在堆中还有许多空闲内存时，抛出内存溢出异常了。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>除了Java堆和永久代外，还有其它地方也会占用较多的内存，所有的内存总和受到操作系统进程最大内存的限制</p><ul><li>Direct Memory：可通过<code>-XX:MaxDirectMemorySize</code>调整大小，内存不足时抛出<code>OutOfMemoryError</code>或者<code>OutOfMemoryError:Direct buffer memory</code></li><li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出<code>StackOverflowError</code>(纵向无法分配，即无法分配新的栈帧)或者<code>OutOfMemoryError: unable to create new native thread</code>(横向无法分配，即无法建立新的线程)</li><li>Socket缓冲区：每个Socket连接都有Receive和Send两个缓存去，分别占大约37KB和25KB内存<del>数字来源？求科普</del>，连接多的话这块内存占用也比较可观。如果无法分配，则可能回抛出<code>IOException: Too many open files</code>异常</li><li>JNI代码：如果代码中使用JNI调用本地库，本地库所使用的内存也不在堆中</li><li>虚拟机和GC：执行时会消耗一定内存</li></ul><h2 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h2><p>如果Java程序执行时需要调用外部Shell脚本，通过<code>Runtime.getRuntime().exec()</code>虽然可以达到目的，但在虚拟机中是非常消耗资源的操作，即使外部命令本身能很快执行完毕，频繁调用时创建进程的开销也非常可观。</p><blockquote><p>Java虚拟机执行这个命令的过程是：</p><ul><li>克隆一个和当前虚拟机拥有一样环境变量的进行</li><li>用新的进程执行命令</li><li>退出这个进程</li></ul><p>频繁执行时，系统的消耗会很大，不仅是CPU，内存负担也很重</p></blockquote><p>如果Shell脚本仅仅是例如获取系统信息这种Java API可以做到的事情，改为用Java API去获取这些信息更好。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK的可视化工具</title>
      <link href="/JVM/tool.html"/>
      <url>/JVM/tool.html</url>
      
        <content type="html"><![CDATA[<p>对性能瓶颈问题来源定位的可视化工具</p><a id="more"></a><ul><li>OutOfMemoryError</li><li>内存泄漏</li><li>线程死锁</li><li>锁争用(Lock Contention)</li><li>Java进程消耗CPU过高</li></ul><p>在JDK6u7后，VisualVM作为Sun的JDK发行版的标准部分，可以替代例如<code>jinfo</code>、<code>jmap</code>、<code>jstack</code>、<code>jstat</code>和<code>jConsole</code>。</p><h3 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html" target="_blank" rel="external">JConsole</a></h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>版本：JDK1.5+</p><blockquote><p>Java Monitoring and Management Console，基于JMX的可视化监视、管理工具。</p></blockquote><p><strong>JMX</strong>（Java Management Extensions，即管理Java的扩展），这种机制可以方便的管理正在运行中的Java程序。常用于管理线程、内存、日志级别、服务重启、系统环境等。一个JMX管理资源可以是一个Java应用、一个服务或一个设备，它们可以用Java开发，或者至少能用Java进行包装，并且能被置入JMX框架中，从而成为JMX的一个管理构件(Managed Bean)，简称MBean。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>命令行中输入<code>jconsole</code>回车，将自动搜索出本机运行的所有进程，双击选择要监控的进程即可，也可以远程连接服务器。</p><ul><li>概述<ul><li>堆内存使用量、线程、类、CPU使用情况</li><li>对着图右击可以保存数据到CVS文件</li></ul></li><li>内存<ul><li>可视化的<code>jstat</code>，用于监视受收集器管理的虚拟机内存的变化趋势</li><li>查看不同内存(堆内存、非堆内存)，使用的GC算法及回收次数和时间</li><li>前提要学习好Java的内存模型</li></ul></li><li>线程<ul><li>可以输入字符串过滤关键线程</li><li>查看某一线程的名称、状态、阻塞和等待的次数、堆栈的信息</li><li>红色：线程数目的峰值；蓝色：当前活动的线程</li><li>检测死锁(D)，有时很有用</li></ul></li><li>类<ul><li>红线：总共加载的类(包括后来卸载的)</li><li>蓝线：当前的类加载</li></ul></li><li>VM摘要<ul><li>看看线程、类、内存、系统、和其它信息</li></ul></li><li>MBean</li></ul><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/index.html" target="_blank" rel="external">VisualVM</a></h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>版本：JDK6u7+</p><blockquote><p>不需要被监视的程序基于特殊Agent运行，对程序的实际性能影响很小，可以直接应用在生产环境中。</p><p>通过插件拓展的特性，可以做到：</p><ul><li>显示JVM进程和进程的配置、环境信息(jps、jinfo)</li><li>监视应用程序的CPU、GC、堆、方法区及线程的信息(stat、jstack)</li><li>dump及分析堆转储快照(jmap、jhat)</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照</li></ul></blockquote><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li><a href="https://visualvm.github.io/download.html" target="_blank" rel="external">安装</a></li><li>生成堆dmp文件<ul><li><code>Aplications</code>窗口右击节点，选择<code>Heap Dump</code></li><li><code>Monitor</code>，点击<code>Heap Dump</code></li></ul></li><li><code>Profiler</code>中可以对运行期间方法级的CPU和内存进行分析，但会影响程序运行性能，不建议在生产环境使用。<ul><li>CPU：统计每个方法的执行次数、执行耗时</li><li>Memory：统计每个方法关联的对象数及对象所占空间</li></ul></li></ul><blockquote><p>JDK1.5后，如果使用Client模式，在进行Profiler之前，最好在监视程序中加入<code>-Xshare:off</code>来关闭类共享优化。</p><p>Client模式下的虚拟机加入并自动开启了类共享，在多虚拟机进程中共享<code>rt.jar</code>中类数据以提高加载速度和节省内存的优化，但这可能会导致被监视的应用程序崩溃。</p></blockquote><ul><li><code>BTrace</code>动态日志跟踪：在不停止程序运行的前提下，通过热部署技术加入原本并不存在的调试代码，以实现对程序的动态调试<ul><li>打印调用堆栈、参数、返回值</li><li>性能监控、定位连接泄漏和内存泄漏、解决多线程竞争问题</li></ul></li><li><code>Threads</code><ul><li>线程长时间停顿的原因<ul><li>等待外部资源（数据库连接、网络资源、设备资源等）</li><li>死循环</li><li>锁等待（活锁和死锁）</li></ul></li></ul></li></ul><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul><li>插件中心<ul><li>菜单 &gt; Tools &gt; Plugins &gt; Available Plugins &gt; Install</li></ul></li><li>下载插件分发文件(.nbm)<ul><li>菜单 &gt; Tools &gt; Plugins &gt; Downloaded &gt; Add Plugins &gt; 选择.nbm文件 &gt; Install</li></ul></li></ul><h3 id="实例-填充内存"><a href="#实例-填充内存" class="headerlink" title="实例-填充内存"></a>实例-填充内存</h3><ul><li>写代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] placeHolder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillHeap</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">List&lt;OOMObject&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</div><div class="line">Thread.sleep(<span class="number">50</span>);</div><div class="line">list.add(<span class="keyword">new</span> OOMObject());</div><div class="line">&#125;</div><div class="line">System.gc();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">fillHeap(<span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>改JVM参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Xms100m -Xmx100m -XX:+UseSerialGC</div></pre></td></tr></table></figure><ul><li>运行后可看到，内存Eden区呈折线状，整个堆的曲线是平滑向上增长。</li></ul><h3 id="实例-线程死循环-amp-等待"><a href="#实例-线程死循环-amp-等待" class="headerlink" title="实例-线程死循环&amp;等待"></a>实例-线程死循环&amp;等待</h3><ul><li>写代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 线程死循环</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBusyThread</span><span class="params">()</span></span>&#123;</div><div class="line">Thread thread =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;,<span class="string">"testBusyThread"</span>);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 线程锁等待</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> lock</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createLockThread</span><span class="params">(<span class="keyword">final</span> Object lock)</span></span>&#123;</div><div class="line">Thread thread =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (lock) &#123;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">lock.wait();</div><div class="line">&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;,<span class="string">"testLockThread"</span>);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">BufferedReader bufferedReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</div><div class="line">bufferedReader.readLine();</div><div class="line">createBusyThread();</div><div class="line">bufferedReader.readLine();</div><div class="line">Object object=<span class="keyword">new</span> Object();</div><div class="line">createLockThread(object);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>运行后，查看VisualVM中的<code>Threads</code>中的<code>main</code>线程，会发现一直在<code>readBytes</code>等待<code>System.in</code>的键盘输入，线程状态为<code>Runnable</code>，线程会被分配运行时间，但<code>readBytes</code>检查到流没有更新时会立刻归还执行令牌，这种等待只消耗很小的CPU资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">"main"</span> - Thread t@<span class="number">1</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">at java.io.FileInputStream.readBytes(Native Method)</div><div class="line">at java.io.FileInputStream.read(FileInputStream.java:<span class="number">255</span>)</div><div class="line">at java.io.BufferedInputStream.read1(BufferedInputStream.java:<span class="number">284</span>)</div><div class="line">at java.io.BufferedInputStream.read(BufferedInputStream.java:<span class="number">345</span>)</div><div class="line">at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:<span class="number">284</span>)</div><div class="line">at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:<span class="number">326</span>)</div><div class="line">at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:<span class="number">178</span>)</div><div class="line">at java.io.InputStreamReader.read(InputStreamReader.java:<span class="number">184</span>)</div><div class="line">at java.io.BufferedReader.fill(BufferedReader.java:<span class="number">161</span>)</div><div class="line">at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">324</span>)</div><div class="line">at java.io.BufferedReader.readLine(BufferedReader.java:<span class="number">389</span>)</div><div class="line">at com.super2bai.jvm.Lock.main(Lock.java:<span class="number">45</span>)</div></pre></td></tr></table></figure><ul><li>随便在控制台输入点内容回车后，刷新VisualVM中的<code>Threads</code>，会看到<code>testBusyThread</code>线程，因为一直在执行空循环，所以停留在<code>Lock</code>的15行，也就是<code>while(true);</code>，这时候线程状态为<code>RUNNABLE</code>，而且没有归还线程执行令牌的动作，会在空循环上用尽全部执行时间直到线程切换，这种等待会消耗较多的CPU资源。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"testBusyThread"</span> - Thread t@<span class="number">17</span></div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">at com.super2bai.jvm.Lock$<span class="number">1</span>.run(Lock.java:<span class="number">15</span>)</div><div class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</div></pre></td></tr></table></figure><ul><li>继续在控制台输入内容后回车，刷新VisualVM中的<code>Threads</code>，会看到<code>testLockThread</code>线程，停留在<code>Lock</code>的33行，也就是<code>lock.wait();</code>，正在等待着lock对象的<code>notify()</code>或<code>notifyAll()</code>方法的出现，线程处于<code>WAITING</code>状态，也就是正常的活锁等待，在被唤醒前不会被分配执行时间，只有lock对象的<code>notify()</code>或<code>notifyALL()</code>方法被调用，便能激活以继续执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"testBusyThread"</span> - Thread t@<span class="number">9</span></div><div class="line">   java.lang.Thread.State: WAITING</div><div class="line">at java.lang.Object.wait(Native Method)</div><div class="line">- waiting on &lt;<span class="number">753</span>b0264&gt; (a java.lang.Object)</div><div class="line">at java.lang.Object.wait(Object.java:<span class="number">502</span>)</div><div class="line">at com.super2bai.jvm.Lock$<span class="number">2</span>.run(Lock.java:<span class="number">33</span>)</div><div class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</div></pre></td></tr></table></figure><h3 id="实例-线程死锁"><a href="#实例-线程死锁" class="headerlink" title="实例-线程死锁"></a>实例-线程死锁</h3><ul><li>写代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynAddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a, b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynAddRunnable</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.a = a;</div><div class="line"><span class="keyword">this</span>.b = b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 死锁的原因：&lt;br&gt;</span></div><div class="line"><span class="comment"> * Integer.valueOf()方法基于减少对象创建次数和节省内存的考虑&lt;br&gt;</span></div><div class="line"><span class="comment"> * [-128, 127]之间的数字会被缓存&lt;br&gt;</span></div><div class="line"><span class="comment"> * java.lang.Integer.IntegerCache中high和low的值&lt;br&gt;</span></div><div class="line"><span class="comment"> * 当传入的值在这个范围内，会直接返回缓存中的对象&lt;br&gt;</span></div><div class="line"><span class="comment"> * 也就是说，100次一共就只返回了两个不同的对象&lt;br&gt;</span></div><div class="line"><span class="comment"> * 加入在某个线程的两个synchronized块之间发生了一次线程切换&lt;br&gt;</span></div><div class="line"><span class="comment"> * 那就会出现线程A等待线程B持有的Integer.valueOf(1)&lt;br&gt;</span></div><div class="line"><span class="comment"> * 而线程B又等待线程A持有的Integer.valueOf(2)&lt;br&gt;</span></div><div class="line"><span class="comment"> * 就会发生死锁，互相等待，运行不下去了&lt;br&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">synchronized</span> (Integer.valueOf(a)) &#123;</div><div class="line"><span class="keyword">synchronized</span> (Integer.valueOf(b)) &#123;</div><div class="line">System.out.println(a + b);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// 不用for其实也可以，但死锁概率小。</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunnable(<span class="number">1</span>, <span class="number">2</span>)).start();</div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> SynAddRunnable(<span class="number">2</span>, <span class="number">1</span>)).start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>运行后，查看JConsole内的线程，点击下方<strong>检测死锁</strong>按钮，会出现新的面板<strong>死锁</strong>，点开任意一个线程，即可看到两个线程互相等待。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">名称: Thread-<span class="number">157</span></div><div class="line">状态: java.lang.Integer@<span class="number">248</span>beb75上的BLOCKED, 拥有者: Thread-<span class="number">158</span></div><div class="line">总阻止数: <span class="number">1</span>, 总等待数: <span class="number">0</span></div><div class="line"></div><div class="line">堆栈跟踪: </div><div class="line">com.super2bai.jvm.thread.SynAddRunnable.run(SynAddRunnable.java:<span class="number">28</span>)</div><div class="line">java.lang.Thread.run(Thread.java:<span class="number">748</span>)</div></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">名称: Thread-<span class="number">158</span></div><div class="line">状态: java.lang.Integer@<span class="number">47</span>cf143上的BLOCKED, 拥有者: Thread-<span class="number">157</span></div><div class="line">总阻止数: <span class="number">1</span>, 总等待数: <span class="number">0</span></div><div class="line"></div><div class="line">堆栈跟踪: </div><div class="line">com.super2bai.jvm.thread.SynAddRunnable.run(SynAddRunnable.java:<span class="number">28</span>)</div><div class="line">java.lang.Thread.run(Thread.java:<span class="number">748</span>)</div></pre></td></tr></table></figure><p>Thread-157等待Thread-158持有的Integer对象，而Thread-158也在等待Thread-157持有的Integer对象，这样两个线程就互相卡住，都不存在等到锁释放的希望了。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>VisualVM功能稍强于Jconsole，VisualVM的高级功能是通过安装插件来拓展</li><li>VisualVM可以在Applications窗口右击程序节点启用“Disable Heap Dump on OOME”，VisualVM将自动生成一个堆转储文件</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1ftky8lselyj20l10cxjsj.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/JMX" target="_blank" rel="external">JMX</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/" target="_blank" rel="external">IBM Java开发</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/Docker/start.html"/>
      <url>/Docker/start.html</url>
      
        <content type="html"><![CDATA[<p>没有道理不介绍一下现在流行的Docker</p><a id="more"></a><h3 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h3><blockquote><p>Docker是一个开发，分发和运行应用程序的开放平台。 Docker可以将应用程序与基础架构分离，以便快速交付软件。 使用Docker，可以像管理应用程序一样管理基础架构。 通过利用Docker实现快速发送，测试和部署代码，可以显着减少编写代码和在生产中运行代码之间的延迟。</p></blockquote><ul><li>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案</li><li>早期版本的Docker是基于已经成熟的Linux Container（LXC）技术实现的。自Docker 0.9版本起，Docker逐渐从LXC转移到新的<a href="https://github.com/docker/libcontainer" target="_blank" rel="external">libcontainer</a>上，并且积极推动开放容器规范runc，试图打造更通用的底层容器虚拟化库。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1ftbrd670cfj20rc0lejta.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1ftbrd5u96xj22dq3agayu.jpg" alt=""></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="docker-cli命令行"><a href="#docker-cli命令行" class="headerlink" title="docker cli命令行"></a>docker cli命令行</h4><blockquote><p>Command Line Interface</p><p>操作Docker的命令行</p></blockquote><ul><li>Docker CLI Command</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1ft7fskumxyj219c0z2qk7.jpg" alt=""></p><ul><li>Docker Container State</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1ft7fsb4y6xj20sb09ydh8.jpg" alt=""></p><p>另，如果只想安装client不想安装整套Docker，可以下载<a href="https://howtowhale.github.io/dvm/" target="_blank" rel="external">Docker Version Manager</a></p><h4 id="image镜像"><a href="#image镜像" class="headerlink" title="image镜像"></a>image镜像</h4><blockquote><ul><li>一个镜像是轻量的、独立的、一个包含所有需要运行它(软件、运行时、系统工具、系统库、设置)的可执行包的软件。</li><li>只读的模版</li><li>可以创建、更新现有镜像，也可以直接下载已有镜像使用</li><li>可以用来创建container</li><li>统一文件系统(union file system)技术将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，隐藏了多层的存在，在用户的角度看，只存在一个文件系统。</li></ul></blockquote><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1ft88pi8e4hj20hc057dg7.jpg" alt=""></p><h5 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h5><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1ft8kb1fb3aj20jk02774c.jpg" alt=""></p><ul><li>元数据：让Docker获取运行和构建时的信息、父层的层次信息。每一层都有元数据</li><li>指针：指向父层、没有则代表它处于最底层</li></ul><h4 id="container容器"><a href="#container容器" class="headerlink" title="container容器"></a>container容器</h4><blockquote><ul><li>镜像创建的运行实例</li><li>Docker利用容器运行应用</li><li>启动、开始、停止、删除</li><li>容器间相互隔离</li><li>与镜像的区别：最上面一层是可读写的</li><li>容器=镜像+读写层</li></ul></blockquote><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1ft88pl5mhej20i304uwex.jpg" alt=""></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1ft8k85ry2ij20ha05iaam.jpg" alt=""></p><h4 id="daemon守护进程"><a href="#daemon守护进程" class="headerlink" title="daemon守护进程"></a>daemon守护进程</h4><blockquote><ul><li>Docker的守护进程，也就是Server端</li><li>clinet通过命令行与daemon通信</li><li>修改方式：<ul><li>命令行（学习研究）</li><li>启动项（配置稳定、不常修改）</li><li>配置文件（定时修改）</li></ul></li></ul></blockquote><h4 id="registry注册服务器"><a href="#registry注册服务器" class="headerlink" title="registry注册服务器"></a>registry注册服务器</h4><blockquote><ul><li>镜像仓库</li><li>Registry有很多repository</li><li>可以被第三方托管</li></ul></blockquote><ul><li><a href="https://hub.docker.com/" target="_blank" rel="external">Docker Hub</a></li><li><a href="https://quay.io/" target="_blank" rel="external">Quay</a></li><li><a href="https://cloud.google.com/container-registry/" target="_blank" rel="external">Google Container Registry</a></li><li><a href="https://aws.amazon.com/ecr/" target="_blank" rel="external">AWS Container Registry</a></li></ul><h4 id="repository仓库"><a href="#repository仓库" class="headerlink" title="repository仓库"></a>repository仓库</h4><blockquote><ul><li>是一系列拥有相同名字不同tag的镜像集合</li></ul></blockquote><p>注册服务器上存有多个仓库，每个仓库又存放了多个镜像，每个镜像有不同的标签tag</p><h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><h4 id="cgroup资源限制"><a href="#cgroup资源限制" class="headerlink" title="cgroup资源限制"></a>cgroup资源限制</h4><blockquote><p>Control Groups是Linux内核提供的一种极致，可以根据特定的行为，把一系列系统任务及其子任务整合（或分离）到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架。</p></blockquote><ul><li>功能<ul><li>资源限制(Resource Limiting)：对进程组使用的资源总额进行限制（包括CPU、memory、IO、网络、文件等）</li><li>优先级分配(Prioritization)：通过分配的CPU时间片数量及硬盘IO带宽大小，实际上就相当于控制了进程运行的优先级</li><li>隔离(Isolation)：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统</li><li>资源统计(Accounting)：统计系统的资源使用量</li><li>进程控制(Control)：对进程组执行挂起、恢复和重启等操作</li></ul></li></ul><h4 id="namespace资源隔离"><a href="#namespace资源隔离" class="headerlink" title="namespace资源隔离"></a>namespace资源隔离</h4><blockquote><p>每个容器都有独立的命名空间，运行在其中的应用都像是在独立的操作系统环境中一样，命名空间机制保证了容器之间彼此互不影响。</p></blockquote><ul><li>进程命名空间</li></ul><blockquote><p>Linux通过命名空间管理进程号，对于同一进程（即同一个task_struct），在不同的命名空间中，看到的进程号不相同，每个进程命名空间有一套自己的进程号管理方法。进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。新fork出的进程在父命名空间和子命名空间将分别有一个进程号来对应。</p></blockquote><ul><li>网络命名空间</li></ul><blockquote><p>网络命名空间为进程提供了一个完全独立的网络协议栈的视图，包括网络设备接口、IPv4和IPv6协议栈、IP路由表、防火墙规则、sockets等，这样每个容器的网络就能隔离开来。Docker采用虚拟网络设备（Virtual Network Device）的方式，将不同命名空间的网络设备连接到一起。默认情况下，容器中的虚拟网卡将同本地主机上的docker0网桥连接在一起。</p></blockquote><ul><li>IPC命名空间</li></ul><blockquote><p>容器中进程交互还是采用了Linux常见的进程间交互方法（Interprocess Communication，IPC），包括信号量、消息队列和共享内存等。PID Namespace和IPC Namespace可以组合起来一起使用，同一个IPC命名空间内的进程可以彼此可见，允许进行交互；不同空间的进程则无法交互。</p></blockquote><ul><li>挂载命名空间</li></ul><blockquote><p>类似于chroot，将一个进程放到一个特定的目录执行。挂载命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间中的进程所看到的文件目录彼此被隔离。</p></blockquote><ul><li>UTS命名空间</li></ul><blockquote><p>UTS（UNIX Time-sharing System）命名空间允许每个容器拥有独立的主机名和域名，从而可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。默认情况下，Docker容器的主机名就是返回的容器ID</p></blockquote><ul><li>用户命名空间</li></ul><blockquote><p>每个容器可以有不同的用户和组id，也就是说可以在容器内使用特定的内部用户执行程序，而非本地系统上存在的用户。</p><p>大约在0.6版，privileged被引入docker。</p><p>使用该参数，container内的root拥有真正的root权限。</p><p>否则，container内的root只是外部的一个普通用户权限。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1ftd6t8cnd2j21kw0cd0vk.jpg" alt=""></p><p>privileged启动的容器，可以看到很多host上的设备，并且可以执行mount。</p><p>甚至允许在docker容器中启动docker容器。</p><p>通过使用隔离的用户命名空间可以提高安全性，避免容器内进程获取到额外的权限。</p></blockquote><p><strong>mount上去的文件，docker没有读写权限。</strong></p><p>举个例子：</p><p>mount了一个文件夹，但是在docker里面就是无法访问。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1ftl1wnwyg5j20zw06cwkt.jpg" alt=""></p><p>相关搜索关键字：<code>docker privileged=true</code></p><h4 id="Union-File-System联合文件系统"><a href="#Union-File-System联合文件系统" class="headerlink" title="Union File System联合文件系统"></a>Union File System联合文件系统</h4><blockquote><p>联合文件系统（UnionFS）是一种轻量级的高性能分层文件系统，它支持将文件系统中的修改信息作为一次提交，并层层叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，应用看到的是挂载的最终结果。</p><p>在Docker中，只读层及在顶部的读写层的组合被称为<a href="https://docs.docker.com/terms/layer/#union-file-system" target="_blank" rel="external">Union File System</a>（联合文件系统）。</p></blockquote><ul><li>Docker存储</li></ul><blockquote><p>Docker目前通过插件化方式支持多种文件系统后端。Debian/Ubuntu上成熟的AUFS（Another Union File System，或v2版本往后的Advanced Multilayered Unification File System），就是一种联合文件系统实现。AUFS支持为每一个成员目录（类似Git的分支）设定只读（readonly）、读写（readwrite）或写出（whiteout-able）权限，同时AUFS里有一个类似分层的概念，对只读权限的分支可以在逻辑上进行增量地修改（不影响只读部分的）。</p></blockquote><p>Docker镜像自身就是由多个文件层组成，每一层有唯一的编号(层ID)，可以通过<code>docker history</code>查看多个文件层组成。</p><p><strong>推荐将容器修改的数据通过volume方式挂载，而不是直接修改镜像内数据。</strong></p><ul><li>多种文件系统比较</li></ul><blockquote><p>Docker目前支持的联合文件系统种类包括AUFS、OverlayFS、btrfs、vfs、zfs和Device Mapper等。</p></blockquote><ul><li>AUFS：最早支持的文件系统，对Debian/Ubuntu支持好，虽然没有合并到Linux内核中，但成熟度很高；</li><li>OverlayFS：类似于AUFS，性能更好一些，已经合并到内核，未来会取代AUFS，但成熟度有待提高；</li><li>Device Mapper：Redhat公司和Docker团队一起开发用于支持RHEL的文件系统，内核支持，性能略慢，成熟度高；</li><li>btrfs：参考zfs等特性设计的文件系统，由Linux社区开发，试图未来取代Device Mapper，成熟度有待提高；</li><li>vfs：基于普通文件系统（ext、nfs等）的中间层抽象，性能差，比较占用空间，成熟度也一般。</li><li>zfs：最初设计为Solaris 10上的写时文件系统，拥有不少好的特性，但对Linux支持还不够成熟。</li></ul><p><strong>AFUS、Device Mapper应用广泛，支持成熟，生产环境考虑；OverlayFS可能具有更好的性能。</strong></p><h4 id="Linux网络虚拟化支持"><a href="#Linux网络虚拟化支持" class="headerlink" title="Linux网络虚拟化支持"></a>Linux网络虚拟化支持</h4><blockquote><p>Docker中的网络接口默认都是虚拟的接口。虚拟接口的最大优势就是转发效率极高。这是因为Linux通过在内核中进行数据复制来实现虚拟接口之间的数据转发，即发送接口的发送缓存中的数据包将被直接复制到接收接口的接收缓存中，而无需通过外部物理网络设备进行交换。对于本地系统和容器内系统来看，虚拟接口跟一个正常的以太网卡相比并无区别，只是它速度要快得多。</p></blockquote><p>Docker的本地网络实现其实就是利用了Linux上的网络命名空间和虚拟网络设备，特别是veth pair，在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做veth pair）。</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><ul><li><code>docker create &lt;image-id&gt;</code>为指定的镜像添加了一个可读写层，构成了一个新的没有运行的容器</li><li><code>docker run &lt;image-id&gt;</code>包含了<code>docker create</code>和<code>docker start</code>命令</li><li><code>docker images</code>列出所有顶层镜像<ul><li>顶层：创建容器时使用的镜像、直接pull下来的镜像。每一个顶层镜像下面都隐藏了多个镜像层</li></ul></li><li><code>docker images -a</code>列出所有的镜像(列出了所有的可读层)</li><li><code>docker history</code>列出某一个image-id下的所有层</li><li><code>docker rmi &lt;image-id&gt;</code>删除镜像，默认会删除unlinked的中间layer，为了安全，当有容器在引用这个images时是不可以删除的，通过<code>-f</code>参数，可以强制删除<ul><li><code>--no-prune</code>：不删除中间layer</li></ul></li><li><code>docker build</code>：根据Dockerfile文件中的<code>FROM</code>指令获取到镜像，然后重复的run、update、commit。在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。</li><li><code>docker save &lt;image-id&gt;</code>创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令为每一个层都保存了它们的元数据，通过<code>docker images -tree</code>命令能够看到历史镜像。</li><li><code>docker history &lt;image-id&gt;</code>递归地输出指定镜像的历史镜像</li></ul><h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><ul><li><code>docker start &lt;container-id&gt;</code>为容器文件系统创建了一个进程隔离空间，每个容器只有一个进程隔离空间。</li><li><code>docker ps</code>列出所有运行中的容器</li><li><code>docker ps -a</code> 列出所有容器</li><li><code>docker stop &lt;container-id&gt;</code>向运行中的容器发送一个SIGTERM的系统信号，然后等待容器中的应用程序终止执行，如果等待时间达到设定的超时时间(默认10秒)，会继续发送SIGKILL的系统信号强行KILL掉进程。<ul><li>设置超时时间：<code>docker stop --``time``=20 container_name</code></li></ul></li><li><code>docker kill</code>：直接发出SIGKILL的系统信号，强行终止容器中程序的运行。</li><li><code>docker pause &lt;container-id&gt;</code>利用cgroups的特性将运行中的进程空间暂停，不保证暂停所有进程</li><li><code>docker rm &lt;container-id&gt;</code>移除构成容器的可读写层，只对非运行态容器执行。</li><li><code>docker commit &lt;container-id&gt;</code>将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</li><li><code>docker exec &lt;running-container-id&gt;</code>会在运行中的容器执行一个新进程，进入到容器内。</li><li><code>docker export &lt;container-id&gt;</code>创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容</li></ul><h4 id="both"><a href="#both" class="headerlink" title="both"></a>both</h4><p><code>docker inspect &lt;container-id&gt; or &lt;image-id&gt;</code>提取出容器或者镜像最顶层的元数据</p><h3 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h3><h4 id="阿里云加速器"><a href="#阿里云加速器" class="headerlink" title="阿里云加速器"></a><a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="external">阿里云加速器</a></h4><blockquote><p>针对安装了Docker for Mac的用户</p><p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中将</p><p>加速器地址加到”registry-mirrors”的数组里，点击 Apply &amp; Restart按钮，等待Docker重启并应用配置的镜像加速器。</p></blockquote><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1ftbtkllnq0j215s0jq41t.jpg" alt=""></p><h4 id="Docker-中国官方镜像加速"><a href="#Docker-中国官方镜像加速" class="headerlink" title="Docker 中国官方镜像加速"></a><a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="external">Docker 中国官方镜像加速</a></h4><blockquote><p>配置Docker守护进程默认使用Docker官方镜像加速，可以默认通过官方镜像加速拉取，而无需在每次拉取时指定registry.docker-cn.com</p></blockquote><ul><li>在守护进程启动时传入<code>--registry-mirror</code>参数：</li></ul><p><code>docker --registry-mirror=https://registry.docker-cn.com daemon</code></p><ul><li>永久性保留更改，可以通过修改<code>/etc/docker/daemon.json</code>文件兵添加上registry-mirrors键值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  "registry-mirrors": ["https://registry.docker-cn.com"]</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>修改保存后，重启Docker以使配置生效。</li></ul><h4 id="新手建议"><a href="#新手建议" class="headerlink" title="新手建议"></a>新手建议</h4><p><a href="https://docs.docker.com/" target="_blank" rel="external">新手入门-官方Guide</a></p><p><a href="https://docs.docker.com/reference/" target="_blank" rel="external">查字典-官方Reference</a></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/bethal/p/5942369.html" target="_blank" rel="external">docker容器和镜像区别</a></p><p><a href="https://stackoverflow.com/questions/34004076/difference-between-docker-registry-and-repository" target="_blank" rel="external">Difference between Docker registry and repository</a></p><p><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-cgroups-resource-isolation" target="_blank" rel="external">Docker背后的内核知识</a></p><p><a href="https://www.cnblogs.com/wade-luffy/p/6589254.html" target="_blank" rel="external">Docker核心实现技术</a></p><p><a href="https://www.docker.com/docker-news-and-press/docker-brings-docker-public-registry-china-expand-developer-adoption-and-fuel" target="_blank" rel="external">说明文档-Docker和阿里云合作的公共加速器</a></p><p><a href="https://www.cnblogs.com/sammyliu/p/5878973.html" target="_blank" rel="external">理解Docker（3）：Docker 使用 Linux namespace 隔离容器的运行环境</a></p><p><a href="https://www.cnblogs.com/sammyliu/p/5878973.html" target="_blank" rel="external">Understanding how uid and gid work in Docker containers</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp签证-南美洲</title>
      <link href="/walkup/SA.html"/>
      <url>/walkup/SA.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>南美洲篇</strong>签证攻略。</p></blockquote><a id="more"></a><h4 id="智利"><a href="#智利" class="headerlink" title="智利"></a>智利</h4><p>智利是不是第一个成为南美洲的OECD成员国—<strong>是</strong></p><p>智利什么资源是世界上最丰富的—<strong>铜矿</strong></p><p>智利曾是哪个国家的殖民地—<strong>西班牙</strong></p><p>智利的官方语言是什么—<strong>西班牙语</strong></p><p>哪一年智利发生大地震—<strong>1960年</strong></p><h4 id="乌拉圭"><a href="#乌拉圭" class="headerlink" title="乌拉圭"></a>乌拉圭</h4><p>乌拉圭是高收入的国家么—<strong>是</strong></p><p>大部分居民信奉什么教—<strong>天主教</strong></p><p>大麻的销售和生产在乌拉圭是合法的么—<strong>是</strong></p><p>乌拉圭总统的任期是几年—<strong>5</strong></p><p>最热爱的运动是—<strong>足球</strong></p><h4 id="巴西"><a href="#巴西" class="headerlink" title="巴西"></a>巴西</h4><p>巴西的官方语言是什么—<strong>葡萄牙语</strong></p><p>巴西的主要宗教是什么—<strong>天主教</strong></p><p>巴西在哪一年举办世界杯—<strong>2014年</strong></p><p>巴西是不是南美洲国家联盟的成员国—<strong>是</strong></p><p>巴西一共分为多少个州—<strong>26</strong></p><h4 id="巴拉圭"><a href="#巴拉圭" class="headerlink" title="巴拉圭"></a>巴拉圭</h4><p>巴拉圭共和国是哪一年独立—<strong>1811</strong></p><p>巴拉圭原为哪个族的印第安人居住地—<strong>瓜拉尼族印度安人</strong></p><p>全国90%的人居住在巴拉圭河以东还是以西—<strong>住在河东</strong></p><p>巴拉圭的首都是哪个城市—<strong>亚松森</strong></p><p>哪个党是巴拉圭的传统政党—<strong>亲爱祖国党</strong></p><p>巴拉圭境内主要河流是—<strong>巴拉圭河河巴拉那河</strong></p><p>巴拉圭经济主要支柱是—<strong>农业</strong></p><h4 id="玻利维亚"><a href="#玻利维亚" class="headerlink" title="玻利维亚"></a>玻利维亚</h4><p>独立后，玻利维亚曾实行过哪种政治制度—<strong>寡头制</strong></p><p>玻利维亚境内有亚马逊森林吗—<strong>有</strong></p><p>哪次战争后玻利维亚横位了内陆国家—<strong>硝石战争</strong></p><p>玻利维亚原名为—<strong>玻利维亚共和国</strong></p><p>玻利维亚是一个政教分离的国家么—<strong>是</strong></p><p>玻利维亚的民族英雄玻利瓦尔来自哪个国家—<strong>委内瑞拉</strong></p><p>大部分土著人崇拜谁—<strong>地球母亲</strong></p><blockquote><p>截止到2018-09-09，玻利维亚-苏克雷城市官方还没有做好，只能暂停。</p><p>另：大洋洲也没有做好，目前没的可走了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文本文件从Windows拷贝到Mac乱码</title>
      <link href="/codec/w2m.html"/>
      <url>/codec/w2m.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Windows系统下创建的文本文档发送到Mac上打开乱码。</p><a id="more"></a><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ul><li>可以打开，汉字部分乱码</li><li>提示<strong>未能打开文稿“”。文本编码“Unicode(UTF-8)不适用”</strong></li></ul><h3 id="解决-Sublime-Text"><a href="#解决-Sublime-Text" class="headerlink" title="解决(Sublime Text)"></a>解决(Sublime Text)</h3><h4 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h4><ul><li>打开Sublime Text 3</li><li><code>Ctrl</code>+<code>~</code></li><li>输入<a href="https://packagecontrol.io/installation" target="_blank" rel="external">内容</a>，回车，等待安装完毕，重启</li><li>用Package Control 搜索ConvertUTF8，安装</li></ul><p>我的Package Control搜索不到结果，稍后找到解决办法再来更新这部分，目前需要解决的问题是乱码，尝试手动安装插件。</p><h4 id="手动安装Sublime插件"><a href="#手动安装Sublime插件" class="headerlink" title="手动安装Sublime插件"></a>手动安装Sublime插件</h4><p><strong>ConvertUFT8</strong></p><ul><li>下载<a href="https://github.com/seanliang/ConvertToUTF8/archive/master.zip" target="_blank" rel="external">ConvertUTF8</a></li><li>解压后，将文件夹改为<code>ConverToUTF8</code></li><li>将文件夹移动到Sublime Text的Packages文件夹下<ul><li><code>Sublime Text</code> &gt; <code>Preferences</code>  &gt; <code>Browse Packages</code></li></ul></li></ul><p><strong>Codecs33</strong></p><blockquote><p>由于 Sublime Text 3 内嵌的 Python 限制，ConvertToUFT8可能无法正常工作，需要安装Codecs33插件。</p></blockquote><ul><li>下载<ul><li><a href="https://github.com/seanliang/Codecs33/archive/linux-x32.zip" target="_blank" rel="external">Linux-x32</a></li><li><a href="https://github.com/seanliang/Codecs33/archive/linux-x64.zip" target="_blank" rel="external">Linux-x64</a></li><li><a href="https://github.com/seanliang/Codecs33/archive/osx.zip" target="_blank" rel="external">OSX</a></li></ul></li><li>解压后，将文件夹改为<code>Codecs33</code></li><li>将文件夹移动到Sublime Text的Packages文件夹下<ul><li><code>Sublime Text</code> &gt; <code>Preferences</code>  &gt; <code>Browse Packages</code></li></ul></li></ul><p>重启Sublime Text后，乱码均已正常显示。</p><p>Over。</p><h3 id="解决-iconv"><a href="#解决-iconv" class="headerlink" title="解决(iconv)"></a>解决(iconv)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p><strong>iconv</strong>是一个计算机程序以及一套应用程序编程接口的名称。它的作用是在多种国际编码格式之间进行文本内码的转换。</p></blockquote><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv -f GB18030 -t utf-8 &lt; infile &gt; outfile</div></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><code>-f</code>：<code>--from-code=NAME</code>，原始文本编码</p><p><code>-t</code>：<code>--to-code=NAME</code>，输出编码</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="文本文档编码"><a href="#文本文档编码" class="headerlink" title="文本文档编码"></a>文本文档编码</h4><ul><li>Windows，Mac端可通过<code>file 文件名称</code>，输出<code>ISO-8859 text, with CRLF line terminators</code>。</li><li>Mac，Mac端通过<code>file 文件名称</code>，输出<code>UTF-8 Unicode text, with no line terminators</code>。</li></ul><h4 id="系统编码"><a href="#系统编码" class="headerlink" title="系统编码"></a>系统编码</h4><ul><li>Windows，输入<code>chcp</code></li></ul><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1fsr8usl8z8j205r01b0sv.jpg" alt=""></p><table><thead><tr><th>定义</th><th></th><th>附加信息</th></tr></thead><tbody><tr><td>1252</td><td>英语、法语、西班牙语、意大利语、德语、葡萄牙语</td><td>ANSI Latin 1; 西欧 (Windows)</td></tr><tr><td>932</td><td>日语</td><td>ANSI/OEM Japanese; 日语 (Shift-JIS)</td></tr><tr><td>949</td><td>韩语</td><td>ANSI/OEM Korean (Unified Hangul Code)</td></tr><tr><td>936</td><td>简体中文GBK</td><td>简体中文 (GB2312); 简体中文 (GB2312-80)</td></tr><tr><td>950</td><td>繁体中文GBK</td><td>ANSI/OEM 繁体中文 (台湾; 香港 SAR, PRC);繁体中文(Big5)</td></tr></tbody></table><ul><li>Mac，输入<code>locale</code></li></ul><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fsr8v6us7ij20c009cwfb.jpg" alt=""></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/seanliang/ConvertToUTF8" target="_blank" rel="external">ConvertToUTF8</a></p><p><a href="https://packagecontrol.io/installation" target="_blank" rel="external">Package Control</a></p><p><a href="https://docs.microsoft.com/en-us/windows/desktop/Intl/code-page-identifiers" target="_blank" rel="external">Windows-Code Pages Identifiers</a></p><p><a href="https://zh.wikipedia.org/wiki/Iconv" target="_blank" rel="external">iconv</a></p>]]></content>
      
      
      <categories>
          
          <category> codec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIT&amp;HSDIS查看反编译代码</title>
      <link href="/JVM/decompile.html"/>
      <url>/JVM/decompile.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>Java代码通过编译器编译成字节码(class文件)，由jVM的各个类加载器加载后，根据JVM的启动配置可以进行解释执行和编译执行。</p><p>编译执行是由JIT(Just In Time) Compiler将字节码一次性编译成本地代码来提高执行速度。缺点是编译本身会消耗并且会占用堆外空间(codecache中)，但是一般Server应用内存足够且能够忍受启动时的略微缓慢。</p></blockquote><p>查看源代码对应的字节码：<code>javap</code></p><p>查看汇编代码请继续向下看。</p><a id="more"></a><hr><p>分析程序如何执行时，大量自行代码时通过<a href="https://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF" target="_blank" rel="external">JIT编译器</a>动态生成到CodeBuffer中的，通过软件条件工具(GDB、Windbg等)断点调试的方式在Java虚拟机中会遇到很大困难，HSDIS插件是Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，下面介绍如何在<strong>Mac</strong>平台下使用。</p><h3 id="安装HSDIS"><a href="#安装HSDIS" class="headerlink" title="安装HSDIS"></a>安装HSDIS</h3><p>查看是否安装HSDIS：</p><p><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version  | grep Java HotSpot(TM)</code></p><p>如果有，则输出</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1fsndqzlj18j21d406s40c.jpg" alt=""></p><p>没有，则<a href="https://pan.baidu.com/s/1i3HxFDF#list/path=%2F" target="_blank" rel="external">下载</a></p><p>前者是Mac 64位机器，后者是Linux 64位机器。</p><p>下载后将<code>hsdis-amd64.so</code>放到<code>jdk1.version.jdk/Contents/Home/jre/lib/amd64</code>。</p><h3 id="安装JITWatch"><a href="#安装JITWatch" class="headerlink" title="安装JITWatch"></a>安装JITWatch</h3><blockquote><p>分析展现JIT日志等的图形界面工具</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/AdoptOpenJDK/jitwatch</div><div class="line">cd jitwatch</div><div class="line">./gradlew run</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn clean install -DskipTests=true</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./launchUI.sh</div></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger_jdk8</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TEST_SIZE = <span class="number">100000000</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">10</span>;</div><div class="line"><span class="keyword">private</span> CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(THREAD_COUNT + <span class="number">1</span>);</div><div class="line"><span class="keyword">private</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> startTime;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">startTime = System.nanoTime();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"><span class="keyword">if</span> (ai.getAndIncrement() == TEST_SIZE) &#123;</div><div class="line">System.out.println(System.nanoTime() - startTime);</div><div class="line">cdl.countDown();</div><div class="line">System.exit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">AtomicInteger_jdk8 at = <span class="keyword">new</span> AtomicInteger_jdk8();</div><div class="line">at.init();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; THREAD_COUNT; n++)</div><div class="line"><span class="keyword">new</span> Thread(at.new MyTask()).start();</div><div class="line">System.out.println(<span class="string">"start"</span>);</div><div class="line">at.cdl.countDown();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="添加JVM参数"><a href="#添加JVM参数" class="headerlink" title="添加JVM参数"></a>添加JVM参数</h3><p>用于生成<code>hotspot.log</code>文件</p><h4 id="java文件"><a href="#java文件" class="headerlink" title=".java文件"></a><code>.java</code>文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=jit.log</div></pre></td></tr></table></figure><p>添加参数后直接运行，会产生<code>jit.log</code>文件</p><h4 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h4><p>有的项目会用maven，就用下面的方式添加参数，此处不用操作，仅仅作为说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export "MAVEN_OPTS=$MAVEN_OPTS -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading -XX:+LogCompilation -XX:+PrintAssembly"</div></pre></td></tr></table></figure><ul><li>父目录执行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mvn tomcat:run</div></pre></td></tr></table></figure><h3 id="我们要开始玩啦～"><a href="#我们要开始玩啦～" class="headerlink" title="我们要开始玩啦～"></a>我们要开始玩啦～</h3><ul><li>打开<code>JITWatch</code>界面，点击<code>Open Log</code>，选择<code>jit.log</code>，点击<code>Start</code>。</li><li>点击左侧 <code>Packages</code> 下的类，双击右侧具体的方法，可以打开<code>TriView</code>界面，在最右侧可以看到<code>Assembly</code>代码</li></ul><h4 id="重点来了"><a href="#重点来了" class="headerlink" title="重点来了"></a>重点来了</h4><p><strong>我的没有！！！</strong></p><p><code>Assembly not found. Was -XX:+PrintAssembly option used?</code></p><blockquote><p>经查阅，是因为<code>JITWatch</code>以前和<code>FCML反汇编程序</code>一起运行的<a href="https://stackoverflow.com/questions/43066522/jitwatch-assembly-code-generation" target="_blank" rel="external">bug</a>，目前已经<a href="https://github.com/AdoptOpenJDK/jitwatch/issues/256" target="_blank" rel="external">解决</a>，但是看完了我也没懂到底我要干嘛，继续查文档…看到了<a href="https://github.com/super2bai/hsdis" target="_blank" rel="external">刘正阳—hsdis</a>，按照文档说明操作了一把，泪奔……终于看到了</p></blockquote><h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4><ul><li>编译hsdis</li></ul><blockquote><p>make ARCH=AMD64</p></blockquote><ul><li>将dylib复制到JDK目录中</li></ul><p>如果JDK版本不同需要修改路径中版本号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp build/macosx-amd64/hsdis-amd64.dylib /Library/Java/JavaVirtualMachines/jdk1.8.0_131.jdk/Contents/Home/jre/lib/server/</div></pre></td></tr></table></figure><ul><li>再打开JITWatcher就可以看到了</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1fsnkneilumj21kw0vsqhk.jpg" alt=""></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://stackoverflow.com/questions/43066522/jitwatch-assembly-code-generation" target="_blank" rel="external">JITWatch assembly code generation</a></li><li><a href="http://www.importnew.com/28957.html" target="_blank" rel="external">使用 JITWatch 查看 JVM 的 JIT 编译代码</a></li><li><a href="https://github.com/liuzhengyang/hsdis" target="_blank" rel="external">liuzhengyang/hsdis</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具推荐</title>
      <link href="/tool/recommend.html"/>
      <url>/tool/recommend.html</url>
      
        <content type="html"><![CDATA[<p>一些我自己用起来很爽的工具。</p><a id="more"></a><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><ul><li>快速启动：<a href="https://www.alfredapp.com/" target="_blank" rel="external">Alfred</a></li><li>终端：<a href="http://ohmyz.sh/" target="_blank" rel="external">oh-my-zsh</a>+ <a href="https://www.iterm2.com/" target="_blank" rel="external">iTerm</a></li><li>MySQL：<a href="https://www.sequelpro.com/" target="_blank" rel="external">Sequel Pro</a></li><li>壁纸：<a href="http://paper.meiyuan.in/" target="_blank" rel="external">pap.er</a></li><li><p>键位映射：<a href="https://github.com/tekezo/Karabiner-Elements/releases" target="_blank" rel="external">Karabiner Elements</a></p></li><li><p>绘图：<a href="https://www.omnigroup.com/omnigraffle/" target="_blank" rel="external">OmniGraffle</a></p></li><li><p>OpenVPN：<a href="https://tunnelblick.net/" target="_blank" rel="external">Tunnelblick</a></p></li><li><p>窗口管理：<a href="https://github.com/fikovnik/ShiftIt/downloads" target="_blank" rel="external">ShiftIt</a></p></li><li><p>快速启动和切换APP：<a href="https://manico.im/" target="_blank" rel="external">Manico</a></p></li><li><p>防休眠，演讲不尴尬：<a href="http://lightheadsw.com/caffeine/" target="_blank" rel="external">Caffeine</a></p></li><li><p>截图识字：<a href="https://toolinbox.net/iText/" target="_blank" rel="external">iText</a></p></li></ul><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>快速启动：<a href="https://github.com/Wox-launcher/Wox" target="_blank" rel="external">Wox</a></li></ul><h3 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h3><ul><li>局域网传输文件：<ul><li><a href="http://www.msec.it/blog/?page_id=11" target="_blank" rel="external">Dokto</a></li><li>把需要传送的目录移动到新建的目录中，然后在当前目录输入<code>python3 -m http.server</code></li></ul></li><li>Markdown编辑器：<a href="https://typora.io/" target="_blank" rel="external">Typora</a></li><li><p>远程协作：<a href="https://www.teamviewer.us/" target="_blank" rel="external">TeamViewer</a></p></li><li><p>绘图：<a href="https://about.draw.io/" target="_blank" rel="external">draw.io</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac显示隐藏文件</title>
      <link href="/mac/showHide.html"/>
      <url>/mac/showHide.html</url>
      
        <content type="html"><![CDATA[<p>eclipse下的<code>.settings</code>或者其它默认隐藏的文件在正常模式下是看不到的，需要修改此类文件时，就需要将文件显示出来，方式如下：</p><a id="more"></a><p>Finder：<code>shift</code>+<code>command</code>+<code>.</code></p><p>Terminal：<code>ls -al</code></p>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK的命令行工具</title>
      <link href="/JVM/cmdTools.html"/>
      <url>/JVM/cmdTools.html</url>
      
        <content type="html"><![CDATA[<p>经常使用适当的虚拟机监控和分析工具可以加快分析数据、定位解决问题的速度</p><p>本文介绍JDK的bin目录内的部分工具作用</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进行</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机个方面的运行数据</td></tr><tr><td>jinfo</td><td>Configuration Info for Java，显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>Memory Map for Java，生成虚拟机的内存转储快照(heapdump文件)</td></tr><tr><td><del>jhat</del></td><td><del>JVM Heap Dump Brower，用户分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果</del></td></tr><tr><td>jstack</td><td>Stack Trace for Java，显示虚拟机的线程快照</td></tr></tbody></table><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a><a href="https://docs.oracle.com/javase/9/tools/jps.htm#GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E" target="_blank" rel="external">jps</a></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>列出正在运行的虚拟机进程</li><li>显示虚拟机执行主类(Main Class , main()函数所在的类)名称</li><li>进程的本地虚拟机唯一ID(Local Virtual Machine Identifier,LVMID)</li></ul><p>当启动多个虚拟机进程，无法根据进程名称定位时，那就需要JPS命令显示主类的功能才能区分。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>jps [options] [hostid]</code></p><p> jps可以通过RMI协议开启了RMI服务的远程虚拟机进程状态，<code>hostid</code>为RMI注册表中注册的主机名。</p><blockquote><p>RMI：</p><p><strong>概念</strong></p><p>Java远程方法调用，即Java Remote Method Invocation，是用于实现远程过程调用的应用编程接口。</p><p>它使客户急上运行的程序可以调用远程服务器上的对象，能够在网络环境中分布操作。宗旨是尽可能简化远程接口对象的使用。</p><p><strong>使用</strong></p><p>依赖于接口。在需要创建一个远程对象的时候，通过传递一个接口来隐藏底层的实现细节。客户端得到的远程对象句柄正好与本地的根代码链接，由后者负责透过网络通信。这样一来，只需关系如何通过自己的接口句柄发送消息。</p><p><strong>实现方式</strong></p><ul><li>使用JRMP(Java Remote Message Protocol,Java远程消息交换协议)</li><li>与CORBA兼容</li></ul><p><strong>包名</strong></p><p><code>java.rmi</code></p><p><strong>与RPC的区别</strong></p><ul><li>定义<ul><li>RMI：Java分布式框架</li><li>RPC：网络协议</li></ul></li><li>方法调用方式不同<ul><li>对RMI来说，如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用</li><li>RPC是通过网络服务协议向远程主机发送请求。</li></ul></li><li>适用语言不通<ul><li>RMI只用于Java</li><li>RPC是网络服务协议，与操作系统和语言无关</li></ul></li><li>传递信息的限制<ul><li>RMI的调用结果可以是对象类型或者基本数据类型</li><li>RPC不允许传递对象，结果统一由外部数据表示(External Data Representation,XDR)语言表示，这种语言抽象了字节序列和数据类型结构之间的差异</li></ul></li><li>发现不匹配的方法<ul><li>RMI在程序开发过程中因为对象或方法不匹配造成的错误可以在编译期发现</li><li>RPC在运行期发现</li></ul></li><li>协议<ul><li>RMI：TCP/IP</li><li>RPC：UDP</li></ul></li></ul></blockquote><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>-p</td><td>只输出LVMID，省略主类的名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类的全名，如果进程执行的是jar包，输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时JVM参数</td></tr></tbody></table><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a><a href="https://docs.oracle.com/javase/9/tools/jstat.htm#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5" target="_blank" rel="external">jstat</a></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><ul><li>监视虚拟机各种运行状态信息<ul><li>类装载</li><li>内存</li><li>垃圾回收</li><li>JIT编译</li><li>等运行时数据</li></ul></li></ul><p>运行时定位虚拟机性能问题的首选工具</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p><code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p><ul><li>-option</li></ul><table><thead><tr><th>option</th><th>displays</th></tr></thead><tbody><tr><td>-class</td><td>类加载情况</td></tr><tr><td>-compiler</td><td>HotSpot中即时编译器编译情况</td></tr><tr><td>-gc</td><td>JVM中堆的垃圾收集情况</td></tr><tr><td>-gccapacity</td><td>存储容量、垃圾收集情况</td></tr><tr><td>-gccause</td><td>垃圾收集的原因</td></tr><tr><td>-gcmetacapacity</td><td>metasapce的存储容量</td></tr><tr><td>-gcnew</td><td>新生代的垃圾收集情况</td></tr><tr><td>-gcnewcapacity</td><td>新生代的存储容量</td></tr><tr><td>-gcold</td><td>老年代及持久代发生GC的情况</td></tr><tr><td>-gcoldcapacity</td><td>老年代的存储容量</td></tr><tr><td>-gcutil</td><td>垃圾收集的情况</td></tr><tr><td>-printcompilation</td><td>HotSpot编译方法的统计</td></tr></tbody></table><ul><li>-t<ul><li>显示从虚拟机启动在当前时间的间隔</li><li>单位：秒</li></ul></li><li>-h<ul><li>每隔n行显示表头</li></ul></li><li>vmid<ul><li>本地：VMID和LVMID一致</li><li>远程：<code>[protocol:][//] lvmid[@hostname[:port]/servername]</code></li></ul></li><li>interval<ul><li>查询的间隔</li><li>不写则查询一次</li><li>例：<code>1s</code>，1秒显示一次；<code>500</code>，500毫秒查询一次</li></ul></li><li>count<ul><li>查询的次数</li><li>不写则查询一次</li><li>例：<code>20</code>，总共显示20次</li></ul></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>jstat -gc -h 5 -t 1748 1s 20</code></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1frrdmic6iuj21kw0syjx6.jpg" alt=""></p><h4 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h4><p>版本：JDK9</p><table><thead><tr><th>表头</th><th>描述</th></tr></thead><tbody><tr><td>S0C</td><td>新生代中Survivor space中S0当前容量的大小（KB）</td></tr><tr><td>S1C</td><td>新生代中Survivor space中S1当前容量的大小（KB）</td></tr><tr><td>S0U</td><td>新生代中Survivor space中S0容量使用的大小（KB）</td></tr><tr><td>S1U</td><td>新生代中Survivor space中S1容量使用的大小（KB）</td></tr><tr><td>EC</td><td>Eden space当前容量的大小（KB）</td></tr><tr><td>EU</td><td>Eden space容量使用的大小（KB）</td></tr><tr><td>OC</td><td>Old space当前容量的大小（KB）</td></tr><tr><td>OU</td><td>Old space使用容量的大小（KB）</td></tr><tr><td>MC</td><td>metaspace当前容量的大小（KB）</td></tr><tr><td>MU</td><td>metaspace 使用容量的大小（KB）</td></tr><tr><td>CCSC</td><td>压缩类空间当前容量大小(KB)</td></tr><tr><td>CCSU</td><td>压缩类空间使用容量大小（KB）</td></tr><tr><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数</td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间(秒)</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数</td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间(秒)</td></tr><tr><td>GCT</td><td>从jvm启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td></tr></tbody></table><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a><a href="https://docs.oracle.com/javase/9/tools/jinfo.htm#JSWOR744" target="_blank" rel="external">jinfo</a></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><ul><li>实时查看和调整虚拟机的各项参数</li></ul><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p>查看：</p><ul><li>概览：<code>jinfo [option] pid</code></li><li>指定参数名称：<code>jinfo -flag name pid</code></li><li>查看JVM flag：<code>jinfo -flags pid</code></li><li>查看Java系统属性：<code>jinfo -sysprops pid</code></li></ul><p>修改：</p><ul><li><code>jinfo -flag [+/-]name pid</code></li><li><code>jinfo -flag name=value</code></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><code>java -XX:+PrintFlagsFinal -version|grep manageable</code></p><p>查看JVM中哪些flag可以被jinfo动态修改</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a><a href="https://docs.oracle.com/javase/9/tools/jmap.htm#JSWOR746" target="_blank" rel="external">jmap</a></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><ul><li>生成堆转储快照(heapdump)，就是打印内存内的所有“对象”的情况</li><li>查询finalize执行队列</li><li>Java堆和永久代的详细信息<ul><li>空间使用率</li><li>当前用的是哪种收集器</li><li>等等</li></ul></li></ul><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><p><code>jmap [options] pid</code></p><ul><li>option</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-clstats</td><td>打印堆中的classload信息。包含每个classload的名字、活跃性、地址、父classloader和加载的class数量</td></tr><tr><td>-finalizerinfo</td><td>打印在F-Queue中等待Finalizer线程执行finalize方法的对象信息</td></tr><tr><td>-histo[:live]</td><td>打印堆中每个class的实例数目、内存占用、类全名信息。VM的内部类名字开头会加上前缀“*”。如果live子参数加上后，只统计活的对象数量</td></tr><tr><td>-dump:<dump-options></dump-options></td><td>生成Java堆转储快照</td></tr></tbody></table><ul><li>dump-options</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>live</td><td>写了只统计存活的对象，没写则统计所有</td></tr><tr><td>format=b</td><td>二进制格式</td></tr><tr><td>file=filename</td><td>转储到指定文件</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p><code>jmap -dump:live,format=b,file=heap.hprof pid</code></p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>JDK9中被<a href="https://www.infoq.com/news/2015/12/OpenJDK-9-removal-of-HPROF-jhat" target="_blank" rel="external">移除</a>，使用jvisualvm、Eclipse Memory Analyzer、IBM HeapAnalyzer等工具来分析dump文件。</p><p>另：IBM HeapAnalyzer用于分析IBM J9虚拟机生成的映像文件，各个虚拟机产生的文件格式不一致，所以分析工具也不能通用。</p><p><a href="https://blogs.oracle.com/nbprofiler/visualvm-139-released" target="_blank" rel="external">visualvm介绍</a></p><p><a href="https://visualvm.github.io/download.html" target="_blank" rel="external">下载visualvm</a></p><p><a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="external">下载Eclipse Memory Analyzer</a></p><p><a href="https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091" target="_blank" rel="external">下载IBM HeapAnalyzer</a></p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a><a href="https://docs.oracle.com/javase/9/tools/jstack.htm#JSWOR748" target="_blank" rel="external">jstack</a></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><ul><li>用于生成虚拟机当前时刻的线程快照<ul><li>一般称为threaddump或者javacore文件</li></ul></li></ul><blockquote><p>线程快照：当前虚拟机内每一条线程正在执行的方法堆栈的集合。</p><p>目的：定位线程出现长时间停顿的原因，如死锁、死循环、请求外部资源导致的长时间等待之类原因。</p></blockquote><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><p><code>jstack [option] pid</code></p><ul><li>option</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-l</td><td>除堆栈外，显示关于锁的附加信息。 例如属于java.util.concurrent的ownable synchronizers列表.</td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p><code>jstack -l pid</code></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>其它工具请参阅文档，<a href="https://docs.oracle.com/javase/9/tools/tools-and-command-reference.htm#JSWOR596" target="_blank" rel="external">Java Platform, Standard Edition Tools Reference</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo站点地图</title>
      <link href="/GHPages/sitemap.html"/>
      <url>/GHPages/sitemap.html</url>
      
        <content type="html"><![CDATA[<p>目的：搜索引擎收录网站</p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p><strong>站点地图</strong>：描述了一个网站的架构。</p><p>它可以是一个任意形式的文档，也可以是列出网站中所有页面的一个网页。</p><p>通常采用分级形式。</p><p>有助于访问者以及搜索引擎的机器人找到网站中的页面</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎</div><div class="line">npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎</div></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><ul><li>在站点配置文件<code>_config.yml</code>中<strong>添加</strong>以下代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 自动生成sitemap</span></div><div class="line">sitemap:</div><div class="line">    path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">    path: baidusitemap.xml</div></pre></td></tr></table></figure><ul><li>在站点配置文件<code>_config.yml</code>中<strong>修改</strong>以下代码</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> URL</span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span></div><div class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 比如网站地址是https://a.com，那么下面就写url: https://a.com</span></span></div><div class="line">url: http://yoursite</div></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g -d</div></pre></td></tr></table></figure><p>会在<code>/public</code>下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code></p><h3 id="收录"><a href="#收录" class="headerlink" title="收录"></a>收录</h3><h4 id="google"><a href="#google" class="headerlink" title="google"></a>google</h4><p><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Search Console</a></p><ul><li>添加网站地址</li><li>提交<code>sitemap.xml</code></li></ul><h4 id="baidu"><a href="#baidu" class="headerlink" title="baidu"></a>baidu</h4><p><a href="https://ziyuan.baidu.com/https/index" target="_blank" rel="external">百度资源</a></p><ul><li>添加网站地址</li><li>提交<ul><li>站点信息-&gt;网页抓取-&gt;详情</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> GHPages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GHPages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配与回收策略</title>
      <link href="/JVM/memStrategy.html"/>
      <url>/JVM/memStrategy.html</url>
      
        <content type="html"><![CDATA[<ul><li>自动内存管理<ul><li>分配内存</li><li>回收内存</li></ul></li></ul><a id="more"></a><p>对象的内存分配在大方向上看就是在堆上分配(也可能经过JIT编译后被拆散为标量类型，间接地在栈上分配)，细节取决于当前使用的是哪种垃圾收集器组合，以及虚拟机中与内存相关参数设置。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><h4 id="书中案例"><a href="#书中案例" class="headerlink" title="书中案例"></a>书中案例</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一起Minor GC。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.management.GarbageCollectorMXBean;</div><div class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * JVM参数：&lt;br&gt;</span></div><div class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20m -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></div><div class="line"><span class="comment"> * &lt;br&gt;</span></div><div class="line"><span class="comment"> * 参数解释：&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xms、Xmx:分配用来设置进程堆内存的最小和最大。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 此处限制堆大小为20M，不可扩展&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xmn:用来设置堆内新生代的大小。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 通过这个值我们也可以得到老生代的大小：-Xmx减去-Xmn&lt;br&gt;</span></div><div class="line"><span class="comment"> * -其中10M分配给新生代，剩下10M给老年代&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:SurvivorRatio=8&lt;br&gt;</span></div><div class="line"><span class="comment"> * 新生代中Eden区与一个Survivor区的空间比例8:1&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocation</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) &#123;</div><div class="line">System.out.println(gc.getObjectName());</div><div class="line">&#125;</div><div class="line">testAllocation();</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation1"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation2"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation3"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation4"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>新生代可用空间为9216K<code>=</code>Eden区8192K<code>+</code>一个Survivor区1024K</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">java.lang:type=GarbageCollector,name=Copy</div><div class="line">java.lang:type=GarbageCollector,name=MarkSweepCompact</div><div class="line">allocation1</div><div class="line">allocation2</div><div class="line">allocation3</div><div class="line">[GC (Allocation Failure) [DefNew: 6979K-&gt;289K(9216K), 0.0053855 secs] 6979K-&gt;6433K(19456K), 0.0054286 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </div><div class="line">allocation4</div><div class="line">Heap</div><div class="line"> def new generation   total 9216K, used 4625K </div><div class="line">  eden space 8192K,  52% used </div><div class="line">  from space 1024K,  28% used</div><div class="line">  to   space 1024K,   0% used</div><div class="line"> tenured generation   total 10240K, used 6144K </div><div class="line">   the space 10240K,  60% used </div><div class="line"> Metaspace       used 2761K, capacity 4486K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 304K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>可以看出，allocation1、allocation2和allocation3分配成功，分配allocation4时会发生一次Minor GC，新生代6979K变为278K，而总内存占用量则几乎没有减少。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间(Survivor空间只有1MB大小)，所以只好通过分配担保机制提前转移到老年代去。</p><p>GC结束后，4M的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden区占用4MB(allocation4)，Survivor空间，老年代占用6MB(allocation1、allocation2和allocation3)。</p><hr><h4 id="实测案例一"><a href="#实测案例一" class="headerlink" title="实测案例一"></a>实测案例一</h4><p>上面是<a href="https://www.amazon.cn/dp/B00D2ID4PK/ref=sr_1_1?ie=UTF8&amp;qid=1526543202&amp;sr=8-1&amp;keywords=%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM" target="_blank" rel="external">《深入理解JVM虚拟机》</a>中的内容，但在实际运行中(JDK1.8，虚拟机参数：<code>-verbose:gc -Xms20M -Xmx20m -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</code>)时，GC日志却发生了变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">java.lang:type=GarbageCollector,name=PS Scavenge</div><div class="line">java.lang:type=GarbageCollector,name=PS MarkSweep</div><div class="line">allocation1</div><div class="line">allocation2</div><div class="line">allocation3</div><div class="line">allocation4</div><div class="line">Heap</div><div class="line"> PSYoungGen      total 9216K, used 7144K </div><div class="line">  eden space 8192K, 87% used </div><div class="line">  from space 1024K, 0% used </div><div class="line">  to   space 1024K, 0% used </div><div class="line"> ParOldGen       total 10240K, used 4096K </div><div class="line">  object space 10240K, 40% used </div><div class="line"> Metaspace       used 2761K, capacity 4486K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 304K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>由日志可见，4个对象均分配成功（allocation1、allocation2和allocation3分配在Eden中，allocation4直接进入到了老年代），没有发生GC。</p><blockquote><p>这是因为在分配了allocation1、allocation2和allocation3后，Eden区实际占用内存是大于6M的(JVM运行时也会占用一定堆空间)，剩余空间不足，无法将allocation4分配到Eden区，这时hotspot会根据分配失败策略尝试在old区分配，只要request的size&gt;=eden_size / 2即满足在old区进行allocation的条件，4M正好等于8M(Eden区10M,8:1)的一半，所以会尝试在old区分配；恰好old区有10M的free空间，所以allocation4直接分配到了old区，没有执行GC。</p></blockquote><hr><h4 id="实测案例二"><a href="#实测案例二" class="headerlink" title="实测案例二"></a>实测案例二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.management.GarbageCollectorMXBean;</div><div class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20m -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></div><div class="line"><span class="comment"> * 参数解释：&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xms、Xmx:分配用来设置进程堆内存的最小和最大。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 此处限制堆大小为20M，不可扩展&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xmn:用来设置堆内新生代的大小。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 通过这个值我们也可以得到老生代的大小：-Xmx减去-Xmn&lt;br&gt;</span></div><div class="line"><span class="comment"> * -其中10M分配给新生代，剩下10M给老年代&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:SurvivorRatio=8&lt;br&gt;</span></div><div class="line"><span class="comment"> * 新生代中Eden区与一个Survivor区的空间比例8:1&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocation</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) &#123;</div><div class="line">System.out.println(gc.getObjectName());</div><div class="line">&#125;</div><div class="line">testAllocation();</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation1"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation2"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation3"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation4"</span>);</div><div class="line"><span class="keyword">byte</span>[] allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span> * _1M];</div><div class="line">System.out.println(<span class="string">"allocation5"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">java.lang:type=GarbageCollector,name=PS Scavenge</div><div class="line">java.lang:type=GarbageCollector,name=PS MarkSweep</div><div class="line">allocation1</div><div class="line">allocation2</div><div class="line">allocation3</div><div class="line">allocation4</div><div class="line">[GC (Allocation Failure) [PSYoungGen: 8003K-&gt;416K(9216K)] 8003K-&gt;7592K(19456K), 0.0095503 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] </div><div class="line">[Full GC (Ergonomics) [PSYoungGen: 416K-&gt;0K(9216K)] [ParOldGen: 7176K-&gt;7456K(10240K)] 7592K-&gt;7456K(19456K), [Metaspace: 2755K-&gt;2755K(1056768K)], 0.0049244 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </div><div class="line">allocation5</div><div class="line">Heap</div><div class="line"> PSYoungGen      total 9216K, used 3313K </div><div class="line">  eden space 8192K, 40% used </div><div class="line">  from space 1024K, 0% used </div><div class="line">  to   space 1024K, 0% used </div><div class="line"> ParOldGen       total 10240K, used 7456K </div><div class="line">  object space 10240K, 72% used </div><div class="line"> Metaspace       used 2762K, capacity 4486K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 304K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>由日志可见，发生了两次GC，一次Minor GC，一次Full GC。</p><blockquote><p>分配了allocation1、allocation2、allocation3和allocation4后，Eden区占用已经超过了7M，尝试分配allocation5(3M)时，不满足在old区分配的条件(3M&lt;4M(8/2))，只能让Eden区发生Minor GC已满足分配allocation5的需求，于是就触发了GC Cause为“Allocation Failure”的Minor GC，所以Eden区那些7M多的对象就被promote到了old区(因为survivor区太小了，所以只剩余416K的东西在Survivor区)；然后紧接着</p><p>parallel scavenge会检查old gen的剩余容量是否满足历次晋升的条件，如果不满足就会进行一次Full GC。</p></blockquote><h4 id="默认收集器"><a href="#默认收集器" class="headerlink" title="默认收集器"></a>默认收集器</h4><p>Default garbage collectors:</p><ul><li>Java 7 - Parallel GC</li><li>Java 8 - Parallel GC</li><li>Java 9 - G1 GC</li><li>Java10- G1 GC</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://stackoverflow.com/questions/2101518/difference-between-xxuseparallelgc-and-xxuseparnewgc" target="_blank" rel="external">Difference between -XX:UseParallelGC and -XX:+UseParNewGC</a></p><p><a href="https://www.zhihu.com/question/264901512" target="_blank" rel="external">Parallel Scavenge垃圾收集器认定对象是大对象的条件是什么？</a></p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><ul><li>大对象<ul><li>需要大量连续内存空间的Java对象<ul><li>很长的字符串以及数组</li></ul></li></ul></li></ul><p>写程序时需避免“短命大对象”，经常出现大对象很容易导致内存还有不少空间时就提前触发GC以获取足够的连续空间来分配。</p><h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4><p><code>-XX:PretenureSizeThreshold</code></p><ul><li>作用：新对象申请的内存空间大于这个设置值直接分配在老年代。</li><li>单位：Byte</li><li>目的：避免在Eden区及两个Survivor区之间发生大量的内存复制</li><li>有效收集器：Serial / ParNew</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.gc;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.management.GarbageCollectorMXBean;</div><div class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20m -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></div><div class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC</span></div><div class="line"><span class="comment"> * 参数解释：&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xms、Xmx:分配用来设置进程堆内存的最小和最大。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 此处限制堆大小为20M，不可扩展&lt;br&gt;</span></div><div class="line"><span class="comment"> * -Xmn:用来设置堆内新生代的大小。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 通过这个值我们也可以得到老生代的大小：-Xmx减去-Xmn&lt;br&gt;</span></div><div class="line"><span class="comment"> * -其中10M分配给新生代，剩下10M给老年代&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:SurvivorRatio=8&lt;br&gt;</span></div><div class="line"><span class="comment"> * 新生代中Eden区与一个Survivor区的空间比例8:1&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:PretenureSizeThreshold=3145728&lt;br&gt;</span></div><div class="line"><span class="comment"> * 超过3M的大对象直接分配到old区&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:+UseSerialGC&lt;br&gt;</span></div><div class="line"><span class="comment"> * JDK1.8默认PS GC，需修改为ServialGC，否则无法测试&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocation</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (GarbageCollectorMXBean gc : ManagementFactory.getGarbageCollectorMXBeans()) &#123;</div><div class="line">System.out.println(gc.getObjectName());</div><div class="line">&#125;</div><div class="line">testPretenureSizeThreshold();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">java.lang:type=GarbageCollector,name=Copy</div><div class="line">java.lang:type=GarbageCollector,name=MarkSweepCompact</div><div class="line">Heap</div><div class="line"> def new generation   total 9216K, used 999K </div><div class="line">  eden space 8192K,  12% used </div><div class="line">  from space 1024K,   0% used </div><div class="line">  to   space 1024K,   0% used </div><div class="line"> tenured generation   total 10240K, used 4096K </div><div class="line">   the space 10240K,  40% used </div><div class="line"> Metaspace       used 2761K, capacity 4486K, committed 4864K, reserved 1056768K</div><div class="line">  class space    used 304K, capacity 386K, committed 512K, reserved 1048576K</div></pre></td></tr></table></figure><p>Eden区几乎没有被使用，而老年代的10M空间被使用了40%，也就是4M的allocation对象直接就分配在老年代中。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>基于分代收集思想，那么GC时就必须能识别不同年龄代的对象，所以虚拟机给每个对象定义了一个对象年龄计数器。</p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。</p><p>对象在Survivor区中每经历过一次Minor GC，年龄就加1，当年龄到达设置值后，就会被晋升到老年代中。</p><h4 id="JVM参数-1"><a href="#JVM参数-1" class="headerlink" title="JVM参数"></a>JVM参数</h4><p><code>-XX:MaxTenuringThreshold</code>：对象晋升到年代的年龄阈(<code>yù</code>)值，默认15。</p><p>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率。<strong>该参数只有在串行GC时才有效.</strong></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Major GC 和 Full GC 是一个概念吗？</p><blockquote><p>基本上可以认为是的。</p><p>Major GC 主要描述的是在老年代的内存回收，触发老年代垃圾回收的其中一个原因是新生代在垃圾后将到达一定年龄的对象复制到老年代，实际上可以看出Major GC产生的之前多伴随着 Minor GC 的产生。</p><p>我们不应该去关心到底应该是叫 Major GC 还是 Full GC，这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义，大家应该关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。</p></blockquote><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://stackoverflow.com/questions/2101518/difference-between-xxuseparallelgc-and-xxuseparnewgc" target="_blank" rel="external">Difference between -XX:UseParallelGC and -XX:+UseParNewGC</a></p><p><a href="https://www.zhihu.com/question/264901512" target="_blank" rel="external">Parallel Scavenge垃圾收集器认定对象是大对象的条件是什么？</a></p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="external">JDK6 Download</a></p><p><a href="http://www.importnew.com/15820.html" target="_blank" rel="external">Minor GC、Major GC和Full GC之间的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot的算法实现</title>
      <link href="/JVM/GCAlgoImpl.html"/>
      <url>/JVM/GCAlgoImpl.html</url>
      
        <content type="html"><![CDATA[<p>HotSpot虚拟机实现垃圾收集算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><a id="more"></a><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><ul><li>可作为GC Roots的节点<ul><li>全局性的引用<ul><li>常量或类静态属性</li></ul></li><li>执行上下文<ul><li>栈帧中的本地变量表</li></ul></li></ul></li></ul><p>可达性分析必须在一个能确保一致性的快照中进行，这导致GC进行时必须停顿所有Java执行线程(Sun称为“Stop-The-World”)。CMS收集器中，枚举根节点时也是必须要停顿的。</p><blockquote><p>一致性：整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可能出现分析过程中对象引用关系还在不断变化的情况，该点不满足就无法保证分析结果准确性</p></blockquote><p>由于目前的主流Java虚拟机使用的都是精准式GC，在HotSpot的实现中，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内对应偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p><blockquote><p>准确式GC：就是让JVM知道内存中某位置数据的类型什么。比如当前内存位置中的数据究竟是一个整型变量还是一个引用类型。这样JVM可以很快确定所有引用类型的位置，从而更有针对性的进行GC roots枚举。</p></blockquote><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote><p>HotSpot没有为每条指令都生成OopMap，只有在“特定的位置”记录了这些信息，这些位置称为<strong>安全点(Safepoint)</strong>。</p></blockquote><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。</p><h4 id="选择标准"><a href="#选择标准" class="headerlink" title="选择标准"></a>选择标准</h4><blockquote><p>是否具有让程序长时间执行的特征为标准</p></blockquote><p>安全点的选定既不能太少，让GC等待时间太长，也不能太多，过分增大运行时的负荷。</p><p>每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长而过长时间运行。</p><blockquote><ul><li>长时间执行的特征就是指令序列复用<ul><li>方法调用</li><li>循环跳转</li><li>异常跳转</li></ul></li></ul><p>具有这些功能的指令才会产生Safepoint</p></blockquote><ul><li>如何在GC发生时让所有线程(不包括执行JNI调用的线程)都运行到最近的安全点上再停顿下来？<ul><li>抢先式中断Preemptive Suspension</li><li>主动式中断Voluntary Suspension</li></ul></li></ul><h4 id="抢先式中断"><a href="#抢先式中断" class="headerlink" title="抢先式中断"></a>抢先式中断</h4><blockquote><p>不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程不在安全点上，就恢复线程，直到运行至安全点再中断。</p></blockquote><p>几乎没有虚拟机实现采用抢先式中断</p><h4 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h4><blockquote><p>当GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮训这个标志，发现中断标志为真时就主动中断挂起。</p></blockquote><p>轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0x01b6d62d: test   %eax,0x160100      ;   &#123;poll&#125;</div></pre></td></tr></table></figure><p><code>test</code>：HotSpot生成的轮询指令</p><p>当需要线程暂停时，虚拟机把<code>0x160100</code>的内存页设置为不可读，线程执行到<code>test</code>指令时就会产生一个自陷异常信号，在预先注册的处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>对于程序不执行时，线程须发响应JVM的中断请求，运行至安全的地方中断挂起，JVM也不太可能等待线程重新运行，此时就需要安全区域来解决。</p><blockquote><p>程序不执行：</p><p>没有分配CPU时间，如：线程处于Sleep或Blocked状态</p></blockquote><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><blockquote><p>Safe Region，在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>被扩展后的Safepoint</p></blockquote><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>在线程执行到Safe Region中的代码时</p><ul><li>标志自己已经进入了Safe Region<ul><li>在这段时间里JVM要发起GC时，就不用管标志自己为Safe Region状态的线程了</li></ul></li></ul><p>在线程要离开Safe Region时</p><ul><li>检查系统是否已经完成了根节点枚举(或时整个GC过程)<ul><li>是：线程继续执行</li><li>否：必须等待至收到可以安全离开Safe Region的信号</li></ul></li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/column/details/talk-about-jvm.html" target="_blank" rel="external">聊聊JVM</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集算法</title>
      <link href="/JVM/gcAlgo.html"/>
      <url>/JVM/gcAlgo.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>介绍几种算法的思想及其发展过程</p></blockquote><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>算法主要做的事情包括<ul><li>标记所有存活的对象</li><li>清除死亡和无用的对象</li></ul></li></ul><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ul><li>GC会定义一些特别的对象为GC Roots<ul><li>本地变量和当前正在运行的方法的参数</li><li>运行的线程</li><li>已加载类的静态字段</li><li>JNI引用</li></ul></li></ul><h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><p>接下来，GC会遍历内存中的所有对象，从GC Roots开始，沿着引用到达其它对象，所有GC访问过的对象都会被标记为存活，其它对象为不可达的对象</p><ul><li>标记阶段<ul><li>标记阶段是Stop-The-World</li><li>暂停时间取决于存活对象的数量，不取决于堆中所有对象的数量，也不取决于堆大小</li></ul></li></ul><p>标记阶段结束后，GC执行下一步并移除所有不可达对象。</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1frb8v15jixj20g405smy1.jpg" alt=""></p><h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>移除不可达对象在不同的GC算法中是不一样的，但概括来看，可分为三类：清除、压缩和复制。</p><hr><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>Mark-Sweep，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p></blockquote><p><code>free-list</code>记录所有可用空间和大小，释放所有被不可达对象占用的内存</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1frb9kjgprwj20g90cjglp.jpg" alt=""></p><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>效率<ul><li>标记和清除两个过程的效率都不高</li></ul></li><li>空间<ul><li>标记清除后会产生大量部连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li></ul></li></ul><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote><p>Copying，解决效率问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行回收，内存分配时也无需考虑内存碎片等问题，只需要移动堆顶指针，按顺序分配内存即可。</p></blockquote><h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1frb9kjf96nj20gd0ddt8u.jpg" alt=""></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>实现简单</li><li>运行高效</li></ul><h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4><ul><li>将内存缩小为原来的一半</li><li>在对象存活率较高时就要进行较多的复制操作，效率将会变低</li><li>需要额外的空间进行分配担保，以对应被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>现在的商业虚拟机都采用复制算法来回收新生代，在HotSpot中，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor大小比是8:1，一般情况下，每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的空间会被“浪费”掉。当Survivor空间不够用时，需要依赖其它内存(老年代)进行分配担保(Handle Promotion)。</p><blockquote><p>“分配担保”：如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p></blockquote><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><blockquote><p>Mark-Compact，标记后，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p></blockquote><h4 id="执行过程-2"><a href="#执行过程-2" class="headerlink" title="执行过程"></a>执行过程</h4><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1frb9kjf1r1j20gg0crglp.jpg" alt=""></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><blockquote><p>根据对象存活周期的不同将内存划分为几块。</p><p>一般是把Java堆分为新生代和老年代，根据不同年代特点采用不同算法。</p><p>新生代：死的多，活的少：复制</p><p>老年代：死的少，活的多：标记-整理、标记-清除</p></blockquote><hr><h3 id="和R大学习"><a href="#和R大学习" class="headerlink" title="和R大学习"></a>和R大学习</h3><p><strong>以下为问题<a href="http://hllvm.group.iteye.com/group/topic/38223" target="_blank" rel="external">并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？</a>中R大的回答，搬运过来。</strong></p><p>分代式GC里，年老代常用<code>mark-sweep</code>或者是<code>mark-sweep/mark-compact</code>的混合方式，一般情况下用<code>mark-sweep</code>，统计估算碎片量达到一定程度时用<code>mark-compac</code>t。这是因为传统上大家认为年老代的对象可能会长时间存活且存活率高，或者是比较大，这样拷贝起来不划算，还不如采用就地收集的方式。<a href="http://www.memorymanagement.org/glossary/m.html#mark-sweep" target="_blank" rel="external">Mark-sweep</a>、<a href="http://www.memorymanagement.org/glossary/m.html#mark-compact" target="_blank" rel="external">mark-compact</a>、<a href="http://www.memorymanagement.org/glossary/c.html#copying.garbage.collection" target="_blank" rel="external">copying</a>这三种基本算法里，只有<code>mark-sweep</code>是不移动对象（也就是不用拷贝）的，所以选用<code>mark-sweep</code>。 </p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th></th><th>mark-sweep</th><th>mark-compact</th><th>copying</th></tr></thead><tbody><tr><td>速度</td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td>空间开销</td><td>少（但会堆积碎片</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍大小（不堆积碎片）</td></tr><tr><td>移动对象?</td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h4 id="时间开销"><a href="#时间开销" class="headerlink" title="时间开销"></a>时间开销</h4><ul><li>mark-sweep<ul><li>mark阶段与活对象的数量成正比</li><li>sweep阶段与整堆大小成正比 </li></ul></li><li>mark-compact<ul><li>mark阶段与活对象的数量成正比</li><li>compact阶段与活对象的大小成正比 </li></ul></li><li>copying<ul><li>与活对象大小成正比 </li></ul></li></ul><p>如果把mark、sweep、compact、copying这几种动作的耗时放在一起看，大致有这样的关系：<br>compaction &gt;= copying &gt; marking &gt; sweeping<br>还有 marking + sweeping &gt; copying </p><blockquote><p>虽然compactiont与copying都涉及移动对象，但取决于具体算法，compact可能要先计算一次对象的目标地址，然后修正指针，然后再移动对象；copying则可以把这几件事情合为一体来做，所以可以快一些。 </p><p>另外还需要留意GC带来的开销不能只看collector的耗时，还得看allocator一侧的。如果能保证内存没碎片，分配就可以用pointer bumping方式，只有挪一个指针就完成了分配，非常快；而如果内存有碎片就得用freelist之类的方式管理，分配速度通常会慢一些。</p></blockquote><p>在分代式假设中，年轻代中的对象在minor GC时的存活率应该很低，这样用copying算法就是最合算的，因为其时间开销与活对象的大小成正比，如果没多少活对象，它就非常快；而且young gen本身应该比较小，就算需要2倍空间也只会浪费不太多的空间。 </p><p>而年老代被GC时对象存活率可能会很高，而且假定可用剩余空间不太多，这样copying算法就不太合适，于是更可能选用另两种算法，特别是不用移动对象的mark-sweep算法。 </p><p>不过HotSpot VM中除了CMS之外的其它收集器都是会移动对象的，也就是要么是copying、要么是mark-compact的变种。 </p><p>================================================================ </p><h4 id="关于名字"><a href="#关于名字" class="headerlink" title="关于名字"></a>关于名字</h4><p>HotSpot VM的serial GC（UseSerialGC）、parallel GC（UseParallelGC）中，只有full GC会收集年老代（实际上收集整个GC堆，包括年老代在内）。它用的算法是<a href="http://www.oracle.com/technetwork/java/whitepaper-135217.html" target="_blank" rel="external">mark-compact</a>（”Mark-Compact Old Object Collector”那一节），具体来说是典型的单线程（串行）的<a href="http://www.memorymanagement.org/glossary/m.html#mark-compact" target="_blank" rel="external">LISP 2算法</a>。虽然在HotSpot VM的源码里，这个full GC的实现类叫做<a href="http://hg.openjdk.java.net/jdk6/jdk6/hotspot/file/tip/src/share/vm/gc_implementation/shared/markSweep.hpp" target="_blank" rel="external">MarkSweep</a>，而许多资料上都把它称为<a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">mark-sweep-compact</a>，但实际上它是典型的mark-compact而不是mark-sweep，请留意不要弄混了。出现这种情况是历史原因，十几二十年前GC的术语还没固定到几个公认的用法时mark-sweep-compact和mark-compact说的是一回事。 </p><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>我不太清楚当初HotSpot VM为何选择先以mark-compact算法来实现full GC，而不像后来微软的<a href="http://msdn.microsoft.com/en-us/library/8bs2ecf4.aspx" target="_blank" rel="external">CLR</a>那样先选择使用mark-sweep为基本算法来实现<a href="http://msdn.microsoft.com/en-us/library/ee787088.aspx" target="_blank" rel="external">Gen 2 GC</a>。但其背后的真相未必很复杂：<br>HotSpot VM的前身是<a href="http://strongtalk.org/" target="_blank" rel="external">Strongtalk VM</a>，它的full GC也是mark-compact算法的，虽说具体算法跟HotSpot VM的不同，是一种threaded compaction算法。这种算法比较省空间，但限制也挺多，实现起来比较绕弯，所以后来出现的HotSpot才改用了更简单直观的LISP 2算法吧，而这个决定又进一步在V8上得到体现。<br>而Strongtalk VM的前身是<a href="http://selflanguage.org/" target="_blank" rel="external">Self VM</a>，同样使用mark-compact算法来实现full GC。可以看到mark-compact是这一系列VM一脉相承的，一直延续到更加新的<a href="https://code.google.com/p/v8/" target="_blank" rel="external">Google V8</a>也是如此。或许当初规划HotSpot VM时也没想那么多就先继承下了其前身的特点。 </p><p>如果硬要猜为什么，那一个合理的推断是：如果不能整理碎片，长时间运行的程序终究会遭遇内存碎片化，导致内存空间的浪费和内存分配速度下降的问题；要解决这个问题就得要能整理内存。如果决定要根治碎片化问题，那么可以直接选用mark-compact，或者是主要用mark-sweep外加用mark-compact来备份。显然直接选用mark-compact实现起来更简单些。所以就选它了。<br>（而CLR就选择了不根治碎片化问题。所有可能出问题的地方都最终会出问题，于是现在就有很多.NET程序受碎片化的困扰） </p><p>后来HotSpot VM有了<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/vm/par-compaction-6.html" target="_blank" rel="external">parallel old GC</a>（UseParallelOldGC），这个用的是多线程并行版的mark-compact算法。这个算法具体应该叫什么名字我说不上来，因为并没有专门的论文去描述它，而大家有许多不同的办法去并行化LISP 2之类的经典mark-compact算法，各自取舍的细节都不同。无论如何，这里要关注的只是它用的也是mark-compact而不是mark-sweep算法。 </p><p>================================================================ </p><h4 id="CMS算法分析"><a href="#CMS算法分析" class="headerlink" title="CMS算法分析"></a>CMS算法分析</h4><p><strong>那CMS为啥选用mark-sweep为基本算法将其并发化，而不跟HotSpot VM的其它GC一样用会移动对象的算法呢？</strong></p><p>一个不算原因的原因是：当时设计和实现CMS是在Sun的另外一款JVM，<a href="http://www.cs.rit.edu/~swm/gc/smli_tr-98-67.pdf%E2%80%8E" target="_blank" rel="external">Exact VM（EVM）</a>上做的。后来EVM项目跟HotSpot VM竞争落败，CMS才从EVM移植到HotSpot VM来。因此它没有HotSpot VM的初始血缘。 &lt;- 真的算不上原因（逃 </p><p>真正的原因请参考CMS的原始论文：<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8915&amp;rank=1&amp;q=A%20Generational%20Mostly-concurrent&amp;osm=&amp;ossid=" target="_blank" rel="external">A Generational Mostly-concurrent Garbage Collector</a>（可恶，Oracle Labs的链接挂了。用CiteSeerX的链接吧） </p><p>把GC之外的代码（主要是应用程序的逻辑）叫做mutator，把GC的代码叫做collector。两者之间需要保持同步，这样才可以保证两者所观察到的对象图是一致的。 </p><p>如果有一个串行、不并发、不分代、不增量式的collector，那么它在工作的时候总是能观察到整个对象图。因而它跟mutator之间的同步方式非常简单：mutator一侧不用做任何特殊的事情，只要在需要GC时同步调用collector即可，就跟普通函数调用一样。 </p><p>如果有一个分代式的，或者增量式的collector，那它在工作的时候就只会观察到整个对象图的一部分；它观察不到的部分就有可能与mutator产生不一致，于是需要mutator配合：它与mutator之间需要额外的同步。Mutator在改变对象图中的引用关系时必须执行一些额外代码，让collector记录下这些变化。有两种做法，一种是<a href="http://www.ravenbrook.com/project/mps/master/manual/html/glossary/w.html#term-write-barrier" target="_blank" rel="external">write barrier</a>，一种是<a href="http://www.ravenbrook.com/project/mps/master/manual/html/glossary/r.html#term-read-barrier" target="_blank" rel="external">read barrier</a>。<br>Write barrier就是当改写一个引用时： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.x = b</div></pre></td></tr></table></figure><p>插入一块额外的代码，变成： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">write_barrier(a, &amp;(a-&gt;x), b);  </div><div class="line">a-&gt;x = b;</div></pre></td></tr></table></figure><p>Read barrier就是当读取一个引用时： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b = a.x</div></pre></td></tr></table></figure><p>插入一块额外的代码，变成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read_barrier(&amp;(a-&gt;x));  </div><div class="line">b = a-&gt;x;</div></pre></td></tr></table></figure><p>通常一个程序里对引用的读远比对引用的写要更频繁，所以通常认为read barrier的开销远大于write barrier，所以很少有GC使用read barrier。<br>如果只用write barrier，那么“移动对象”这个动作就必须要完全暂停mutator，让collector把对象都移动好，然后把指针都修正好，接下来才可以恢复mutator的执行。也就是说collector“移动对象”这个动作无法与mutator并发进行。 </p><p>如果用到了read barrier（虽少见但不是不存在，例如<a href="http://www.azulsystems.com/technology/c4-garbage-collector" target="_blank" rel="external">Azul C4 Collector</a>），那移动对象就可以单个单个的进行，而且不需要立即修正所有的指针，所以可以看作整个过程collector都与mutator是并发的。 </p><p>CMS没有使用read barrier，只用了write barrier。这样，如果它要选用mark-compact为基本算法的话，就只有mark阶段可以并发执行（其中root scanning阶段仍然需要暂停mutator，这是initial marking；后面的concurrent marking才可以跟mutator并发执行），然后整个compact阶段都要暂停mutator。回想最初提到的：compact阶段的时间开销与活对象的大小成正比，这对年老代来说就不划算了。<br>于是选用mark-sweep为基本算法就是很合理的选择：mark与sweep阶段都可以与mutator并发执行。Sweep阶段由于不移动对象所以不用修正指针，所以不用暂停mutator。 </p><p>（题外话：但现实中我们仍然可以看到以mark-compact为基础算法的增量式/并发式年老代GC。例如Google V8里的年老代GC就可以把marking阶段拆分为非并发的initial marking和增量式的<a href="https://code.google.com/p/v8/source/browse/trunk/src/incremental-marking.h" target="_blank" rel="external">incremental marking</a>；但真正比较耗时的compact阶段仍然需要完全暂停mutator。它要降低暂停时间就只能想办法在年老代内进一步选择其中一部分来做compaction，而不是整个年老代一口气做compaction。这在V8里也已经有实现，叫做incremental compaction。再继续朝这方向发展的话最终会变成region-based collector，那就跟G1类似了。） </p><p>那碎片堆积起来了怎么办呢？HotSpot VM里CMS只负责并发收集年老代（而不是整个GC堆）。如果并发收集所回收到的空间赶不上分配的需求，就会回退到使用serial GC的mark-compact算法做full GC。也就是mark-sweep为主，mark-compact为备份的经典配置。但这种配置方式也埋下了隐患：使用CMS时必须非常小心的调优，尽量推迟由碎片化引致的full GC的发生。一旦发生full GC，暂停时间可能又会很长，这样原本为低延迟而选择CMS的优势就没了。 </p><p>所以新的Garbage-First（G1）GC就回到了以copying为基础的算法上，把整个GC堆划分为许多小区域（region），通过每次GC只选择收集很少量region来控制移动对象带来的暂停时间。这样既能实现低延迟也不会受碎片化的影响。<br>（注意：G1虽然有concurrent global marking，但那是可选的，真正带来暂停时间的工作仍然是基于copying算法而不是mark-compact的）</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://plumbr.io/handbook/garbage-collection-algorithms" target="_blank" rel="external">垃圾收集算法</a></p><p><a href="https://my.oschina.net/feinik/blog/895192" target="_blank" rel="external">图片来源</a></p><p><a href="http://hllvm.group.iteye.com/group/topic/38223" target="_blank" rel="external">关于收集算法—R大的回答</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于对象引用</title>
      <link href="/JVM/reference.html"/>
      <url>/JVM/reference.html</url>
      
        <content type="html"><![CDATA[<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><a id="more"></a><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>实现简单</li><li>判定效率高</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>很难解决对象之间相互循环引用的问题</li></ul><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>商用程序语言(Java、C#、Lisp)的主流实现实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><blockquote><p>通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为”引用链”，当一个对象到GC Roots没有任何引用链相连(用图论的话来说，就是GC Roots到这个对象不可达)时，则证明此对象是不可用的，暂处于”缓刑”阶段。</p></blockquote><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><h4 id="JDK1-2以前"><a href="#JDK1-2以前" class="headerlink" title="JDK1.2以前"></a>JDK1.2以前</h4><ul><li>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。</li><li>只有被引用或者没有被引用两种状态</li></ul><blockquote><p>希望：</p><p>当内存空间还足够时，则保留在内存之中；</p><p>如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。</p></blockquote><h4 id="JDK1-2以后"><a href="#JDK1-2以后" class="headerlink" title="JDK1.2以后"></a>JDK1.2以后</h4><ul><li>强引用(Strong Reference)<ul><li><code>Object obj=new Object()</code></li></ul></li><li>软引用(Soft Reference)<ul><li>还有用但并非必须的对象</li><li>在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常</li><li>加速JVM对垃圾内存的回收速度、维护系统的运行安全、防止内存溢出(OOM)等问题的产生</li></ul></li><li>弱引用(Weak Reference)<ul><li>只能生存到下一次垃圾收集发生之前</li><li>当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li></ul></li><li>虚引用(Phantom Reference)<ul><li>也称“幽灵引用”、“幻影引用”</li><li>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用了来取得一个对象实例。</li><li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</li></ul></li></ul><h3 id="宣告对象死亡"><a href="#宣告对象死亡" class="headerlink" title="宣告对象死亡"></a>宣告对象死亡</h3><h4 id="是否执行finalize"><a href="#是否执行finalize" class="headerlink" title="是否执行finalize()"></a>是否执行<code>finalize()</code></h4><p>第一次，GC Roots无任何引用链相连，会被第一次标记并且进行一次有没有必要执行<code>finalize()</code>方法的筛选，<code>finalize()</code>方法是对象逃脱死亡的最后一次机会。</p><ul><li>没有必要执行<code>finalize()</code>方法<ul><li>没有覆盖<code>finalize()</code>方法</li><li><code>finalize()</code>方法已经被虚拟机调用过</li></ul></li><li>有必要执行<code>finalize()</code>方法<ul><li>对象被放置在<code>F-Queue</code>队列中，并在稍后由一个虚拟机自动创建的、低优先级的<code>Finalizer</code>线程去执行<ul><li>虚拟机触发，并不承诺会等待运行结束<ul><li>如果一个对象在<code>finalize()</code>方法中执行缓慢或死循环，将很可能导致<code>F-Queue</code>队列中其它对象永久处于等待，甚至导致整个内存回收系统崩溃</li></ul></li></ul></li></ul></li></ul><h4 id="是否关联到引用链"><a href="#是否关联到引用链" class="headerlink" title="是否关联到引用链"></a>是否关联到引用链</h4><p>GC将对<code>F-Queue</code>队列中的对象进行小规模的标记</p><ul><li>如果对象重新与引用链上的任何一个对象建立关联(this赋值给某个类变量或者对象的成员变量)<ul><li>将被移除出“即将回收”集合。</li></ul></li><li>对象没有逃脱<ul><li>被回收</li></ul></li></ul><h3 id="不建议使用finalize"><a href="#不建议使用finalize" class="headerlink" title="不建议使用finalize()"></a>不建议使用<code>finalize()</code></h3><ul><li>运行代价高昂</li><li>不确定性大</li><li>无法保证各个对象的调用顺序</li><li><code>finalize()</code>能做的所有工作，用<code>try-finally</code>或者其它方式都可以做的更好、更及时</li><li>推荐忘掉<code>finalize()</code>的存在</li></ul><h4 id="对象拯救示例"><a href="#对象拯救示例" class="headerlink" title="对象拯救示例"></a>对象拯救示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * output: &lt;br/&gt;</span></div><div class="line"><span class="comment"> * finalize method executed&lt;br/&gt;</span></div><div class="line"><span class="comment"> * alive &lt;br/&gt;</span></div><div class="line"><span class="comment"> * dead</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">super</span>.finalize();</div><div class="line">System.out.println(<span class="string">"finalize method executed"</span>);</div><div class="line">FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"><span class="comment">// 第一次拯救</span></div><div class="line">SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">System.gc();</div><div class="line"></div><div class="line"><span class="comment">// finalize优先级低，暂停当前线程等待</span></div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">System.out.println(<span class="string">"alive"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">System.out.println(<span class="string">"dead"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 将SAVE_HOOK赋值为null后，调用gc,执行finalize()&lt;br/&gt;</span></div><div class="line"><span class="comment"> * finalize()方法中SAVE_HOOK被赋值&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 所以判断时SAVE_HOOK不为null</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">// 第二次拯救</span></div><div class="line">SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">System.gc();</div><div class="line"></div><div class="line"><span class="comment">// finalize优先级低，暂停当前线程等待</span></div><div class="line">Thread.sleep(<span class="number">500</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">System.out.println(<span class="string">"alive"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">System.out.println(<span class="string">"dead"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 将SAVE_HOOK赋值为null后，调用gc&lt;br/&gt;</span></div><div class="line"><span class="comment"> * SAVE_HOOK的finalize已经被执行过了&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 所以这次不执行finalize()&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 所以判断时SAVE_HOOK为null&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 任何一个对象的finalize()方法都只会被系统自动调用一次&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 如果对象面临下一次回收，它的finalize()方法不会被再次执行</span></div><div class="line"><span class="comment"> */</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><h4 id="回收内容"><a href="#回收内容" class="headerlink" title="回收内容"></a>回收内容</h4><p>永久代的垃圾回收主要回收两部分内容</p><ul><li>废弃常量<ul><li>没有任何String对象引用常量池中的常量</li><li>没有其他地方引用了这个字面量</li></ul></li><li>无用的类<ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类</li></ul></li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>是否对类进行回收：<code>-Xnoclassgc</code></li><li>查看类加载和卸载信息<ul><li><code>-verbose:class</code><ul><li>Product版的虚拟机中使用</li></ul></li><li><code>-XX:+TraceClassLoading</code><ul><li>Product版的虚拟机中使用</li></ul></li><li><code>-XX:+TraceClassUnLoading</code><ul><li>FastDebug版的虚拟机中使用</li></ul></li></ul></li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>学习知识不要上来就抓细节，很多人都说这本书太老了，如今代码已经日新月异。但是不理解思想，光看变化，很容易晕头转向。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC日志</title>
      <link href="/JVM/GCLog.html"/>
      <url>/JVM/GCLog.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>每一种收集器的日志形式都是由它们自身的实现所决定的，格式不一致。</p><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">33.125：[GC[DefNew：3324K-＞152K（3712K），0.0025925secs]3324K-＞152K（11904K），0.0031680 secs]</div></pre></td></tr></table></figure><p>GC发生的时间(虚拟机启动以来经过的秒数)：<code>[</code>停顿类型<code>[</code>发生区域<code>：</code>GC前该内存区域已使用容量<code>-&gt;</code> GC后该内存区域已使用容量(内存区域总容量)<code>,该区域GC所占用的时间(秒)</code> <code>]</code>GC前Java堆已使用容量<code>-&gt;</code>GC后Java堆已使用容量(Java堆总容量)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">100.667：FullGC[Tenured：0K-＞210K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs</div></pre></td></tr></table></figure><ul><li>类型：<ul><li>FullGC：Stop-The-World</li><li>FullGC(System)：调用<code>System.gc()</code></li></ul></li><li>GC发生的区域(收集器决定名字)<ul><li>DefNew<ul><li>Serial中新生代名为”Default New Generation”</li><li>ParNew中则为”ParNew”，意为”Parallel New Generation”</li><li>Parallel Scavenge中则为“PSYoungGen”</li></ul></li><li>Tenured</li><li>Perm</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]</div></pre></td></tr></table></figure><p>ParNew出现Full GC：一般是因为出现了分配担保失败之类的问题，所以才导致STW。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>有的收集器会给出更具体的时间数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Times : user=0.01 sys=0.00, real=0.02 secs]</div></pre></td></tr></table></figure><p><code>user</code>：用户态消耗的CPU时间</p><p><code>sys</code>：内核态消耗的CPU时间</p><p><code>real</code>：操作从开始到结束所经过的墙钟时间(Wall Clock Time)</p><blockquote><p>CPU时间与墙钟时间的区别：</p><ul><li>CPU时间不包括耗时<ul><li>系统有多CPU或多核时，多线程操作会叠加这些CPU时间</li></ul></li></ul><ul><li>墙钟时间包括各种非运算的等待耗时<ul><li>等待磁盘I/O</li><li>等待线程阻塞</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器</title>
      <link href="/JVM/GC.html"/>
      <url>/JVM/GC.html</url>
      
        <content type="html"><![CDATA[<p><strong>版本：JDK1.7 U14</strong></p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>哪些内存需要回收</li><li>什么时候回收</li><li>如何回收</li></ul><h3 id="为什么要懂"><a href="#为什么要懂" class="headerlink" title="为什么要懂"></a>为什么要懂</h3><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集称为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节。</p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fqxaynyb86j20f70ae400.jpg" alt=""></p><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>最基本、发展历史最悠久的收集器</li><li>JDK1.3.1之前，虚拟机新生代收集的唯一选择</li><li>单线程(Stop The World)<ul><li>只会使用一个CPU或一条收集线程去完成垃圾收集工作</li><li>进行垃圾收集时，必须暂停其它所有的工作线程，直至结束<ul><li>虚拟机后台自动发起、完成，用户不可见</li></ul></li></ul></li><li>收集算法<ul><li>新生代采取复制算法</li><li>老年代采取标记-整理算法</li></ul></li><li>虚拟机运行在Client模式下的默认新生代收集器</li><li>优点<ul><li>简单高效<ul><li>对于限定单个CPU的环境，没有线程交互的开销</li></ul></li></ul></li></ul><h4 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fqy1c6aamzj20oc0bjgmd.jpg" alt=""></p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li>Serial GC的多线程版本</li><li>与Serial GC一致<ul><li>控制参数</li><li>收集算法</li><li>Stop The World</li><li>对象分配规则</li><li>回收策略</li></ul></li><li>虚拟机运行在Server模式下默认新生代收集器<ul><li>除Serial收集器外，只有它能与CMS收集器配合工作</li></ul></li></ul><h4 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqy1c0cxccj20oc0bj75b.jpg" alt=""></p><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Paralled Scavenge配合工作。所以在JDK1.5中使用CMS时，新生代只能选择Paralled Scavenge或者Serial。<strong>Parallel Scavenge没有使用原本HotSpot其它GC通用的那个GC框架，所以不能跟使用了那个框架的CMS搭配使用。就这么简单，不是什么算法/技术上的不兼容，纯粹是人为造成的。Parallel Scavenge和ParNew抽象来说是同一思路的GC，而后者可以跟CMS搭配使用。这样就够了。</strong></p><h4 id="与Serial对比"><a href="#与Serial对比" class="headerlink" title="与Serial对比"></a>与Serial对比</h4><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百的保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC使系统资源的有效利用还是很有好处的。</p><blockquote><p>超线程技术是一个很好的提升核心利用率的东西，将闲置处理资源充分调用起来，增强核心并行运算性能，在操作系统中一颗物理CPU能当作多颗CPU来使用。</p><p>好处：</p><ul><li>有效提升CPU利用率</li><li>改善计算机的性能</li><li>提高系统可靠性</li></ul><p>随着核心数目增多超线程的作用就越弱。</p><p>需要CPU、主板、操作系统、应用软件支持。</p></blockquote><p>默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境下，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。</p><blockquote><p>并发：两件以上的事件在同一时间间隔发生。同一实体</p><p>并行：两件以上的事件在同一时刻发生。不同实体</p><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1fqx1ilmc0kj20go0cj0t7.jpg" alt=""></p></blockquote><h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li>新生代收集器</li><li>复制算法</li><li>并行的多线程收集器</li><li>“吞吐量优先”收集器<ul><li>目标是达到一个可控制的吞吐量(Throughput)</li></ul></li></ul><h4 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqy1c2a1hkj20oc0bjdgo.jpg" alt=""></p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>CPU用于运行用户代码的时间与CPU总消耗的时间的比值</li><li>吞吐量<code>=</code>运行用户代码时间<code>/(</code>运行用户代码时间<code>+</code>垃圾收集时间<code>)</code></li><li>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</li><li>高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>控制最大垃圾收集停顿时间：<code>-XX:MaxGCPauseMillis</code><ul><li>大于0的毫秒数</li><li>收集器将尽可能的保证内存回收花费的时间不超过设定值。</li><li>GC停顿时间缩短是牺牲吞吐量和新生代空间来换取的。</li></ul></li></ul><ul><li>设置吞吐量大小：<code>-XX:GCTimeRatio</code><ul><li>大于0且小于100的整数，默认99<ul><li>允许最大1%(<code>1/(1+99)</code>)的垃圾收集时间</li></ul></li><li>垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。</li><li>值为19，那允许最大GC时间就占总时间的5%(<code>1/(1+19)</code>)</li></ul></li><li>GC自适应的调节策略(GC Ergonomics)：<code>-XX:UseAdaptiveSizePolicy</code><ul><li>开关参数</li><li>不需要手工指定下列细节参数<ul><li>新生代的大小：<code>-Xmn</code></li><li>Eden与Survivor区的比例：<code>-XX:SurvivorRatio</code></li><li>晋升老年代对象的年龄：<code>-XX:PretenureSizeThreshold</code></li></ul></li></ul></li></ul><h4 id="与ParNew的区别"><a href="#与ParNew的区别" class="headerlink" title="与ParNew的区别"></a>与ParNew的区别</h4><p>Parallel Scavenge的自适应调节策略。</p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>如果对收集器运作原理不太了解，手工优化困难，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成。只需要设置基本的内存数据，如：设置最大堆：<code>-Xmx</code>，然后使用<code>MaxGCpauseMillis参数</code>或<code>GCTimeRatio</code>参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。</p><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul><li>Serial的老年代版本</li><li>单线程收集器</li><li>“标记-整理”算法</li><li>主要意义是Client模式下的虚拟机使用</li><li>Server模式下的用途<ul><li>JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用</li><li>作为CMS收集器的后备预案</li></ul></li></ul><blockquote><p>需要说明一下，Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接使用了Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现非常接近，所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解，这里笔者也采用这种方式。</p></blockquote><h4 id="运行示意图-3"><a href="#运行示意图-3" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fqy1c6aamzj20oc0bjgmd.jpg" alt=""></p><h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul><li>Parallel Scavenge老年代版本</li><li>多线程</li><li>“标记-整理”算法</li><li>JDK1.6中提供</li><li>在注重吞吐量以及CPU资源敏感的场合，优先考虑Parallel Scavenge加Parallel Old收集器</li></ul><blockquote><p>JDK1.6之前，新生代的Parallel Scavenge一直处于比较尴尬的位置。</p><p>如果新生代选择了Parallel Scavenge，老年代只能选择Serial Old(PS MarkSweep)。由于Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量还不一定有ParNew加CMS组合好。</p></blockquote><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>全称为：Concurrent Mark Sweep</p><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul><li>获取最短回收停顿时间为目标</li><li>“标记-清除”算法</li></ul><h4 id="运作过程"><a href="#运作过程" class="headerlink" title="运作过程"></a>运作过程</h4><ul><li>初始标记(CMS initial mark)<ul><li>Stop The World</li><li>标记GC Roots能直接关联到的对象</li><li>速度很快</li></ul></li><li>并发标记(CMS concurrent mark)<ul><li>Stop The World</li><li>进行GC Roots Tracing的过程</li></ul></li><li>重新标记(CMS remark)<ul><li>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li>停顿时间一般会比初始标记阶段稍长一些，远比并发标记的时间短</li></ul></li><li>并发清除(CMS concurrent sweep)</li><li>重置线程</li></ul><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><h4 id="运行示意图-4"><a href="#运行示意图-4" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqy1c4jvwoj20pw0bjt9j.jpg" alt=""></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>并发收集</li><li>低停顿<ul><li>Sun公司的官方文档中也称为并发低停顿收集器(Concurrent Low Pause Collector)</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>对CPU资源非常敏感</li></ul><p>在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程(或者说CPU资源)而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数：<code>(CPU数量+3)/4</code>，也就是当CPU在4个以上时，并发回收时垃圾收集线程占用不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时，CMS对用户程序的影响就可能变得很大。如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%。</p><p><del><strong>i-CMS</strong>：虚拟机提供了一种称为“增量式并发收集器”(Incremental Concurrent Mark Sweep/i-CMS)的CMS收集器变种，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。但效果很一般，已经被声明为“deprecated”，即不再提倡用户使用</del></p><ul><li>无法处理浮动垃圾(Floating Garbage)</li></ul><blockquote><p><strong>浮动垃圾</strong>：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行时自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。</p></blockquote><p>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p><p><code>-XX:CMSInitiatingOccupancyFraction</code>设置的太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。</p><blockquote><p>由于垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间，因此CMS收集器不能等到老年代几乎完全被填满了再进行收集。</p><p>在JDK1.5的默认设置下，CMS手机器当老年代使用了68%的空间后就会被激活。可以通过<code>-XX:CMSInitiatingOccupancyFraction</code>来提高触发百分比，以便降低回收次数从而获取更好的性能。</p><p>在JDK1.6中，CMS手机的启动阀值已经提升至92%。</p><p>要是CMS运行期间预留的内存无法满足程序的需要，就会出现“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾手机，这样停顿时间就很长了。</p></blockquote><ul><li>产生大量空间碎片</li></ul><blockquote><p>CMS是一款基于“标记-清除”算法实现的收集器，意味着收集结束时会有大量空间碎片产生，空间碎片过多时，将会给打对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p></blockquote><p>CMS收集器提供开关参数<code>-XX:UseCMSCompactAtFullCollection</code>，用于在CMS收集器要进行Full GC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</p><p>虚拟机设计者还提供了另外一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，设置执行多少次不压缩的Full GC后，跟着来一次带压缩的(默认值为0，表示每次进入Full GC时都进行碎片整理)</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>Garbage-First，当今收集器技术发展的最前沿成果之一，面向服务端应用的垃圾收集器，目标是干掉CMS收集器。</li><li>“标记-整理”</li><li>将整个Java堆划分为多个大小相等的独立区域(Region)，新生代和老年代不再是物理隔离，它们都是一部分Region(不需要连续)的集合</li></ul><h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ul><li>并行与并发</li></ul><p>G1能充分利用多CPU、多核环境下的硬件优势，缩短Stop-The-World时间，通过并发的方式让Java程序继续执行。</p><ul><li>分代收集</li></ul><p>独立管理整个GC堆，采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获得更好的收集效果。</p><ul><li>空间整合</li></ul><p>从整体来看是基于“标记-整理”算法实现，从局部(两个Region之间)看是基于“复制”算法实现的。</p><p>意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。有利于程序长时间运行。</p><ul><li>可预测的停顿</li></ul><p>建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><blockquote><p>因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region(G1名字由来)。</p><p>这种使用Region划分内存空间以及有优先级的区域回收方式，保证了在有限的时间内可以获取尽可能高的收集效率。</p></blockquote><h4 id="问题及解答"><a href="#问题及解答" class="headerlink" title="问题及解答"></a>问题及解答</h4><p>把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？</p><blockquote><p>G1中每个Region多有一个与之对应的Remembered Set，虚拟机发现程序在堆Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中(在分代概念里就是检查是否老年代中的对象引用了新生代中的对象)。</p><p>是：通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p></blockquote><h4 id="运作过程-1"><a href="#运作过程-1" class="headerlink" title="运作过程"></a>运作过程</h4><ul><li>初始标记(Initial Marking)</li></ul><p>标记GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，需要停顿线程，耗时很短</p><ul><li>并发标记(Concurrent Marking)</li></ul><p>从GC Root开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，可与用户程序并发执行</p><ul><li>最终标记(Final Marking)</li></ul><p>修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，需要线程停顿，但是可并行执行。</p><ul><li>筛选回收(Live Data Counting and Evacuation)</li></ul><p>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可与用户程序并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</p><h4 id="运行示意图-5"><a href="#运行示意图-5" class="headerlink" title="运行示意图"></a>运行示意图</h4><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqy1byiglfj20pb0cj75m.jpg" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th>垃圾回收器</th><th>Generation</th><th>JDK</th><th>算法</th><th>特点</th></tr></thead><tbody><tr><td>Serial</td><td>Young</td><td>1.3</td><td>复制</td><td>简单高效，用户线程停顿时间长</td></tr><tr><td>ParNew</td><td>Young</td><td>1.4</td><td>复制</td><td>多线程版Serial，适合多CPU</td></tr><tr><td>Parallel Scavenge</td><td>Young</td><td>1.4</td><td>复制</td><td>吞吐量优先，自适应调节策略</td></tr><tr><td>Serial Old</td><td>Tenured</td><td>1.5</td><td>标记-整理</td><td>老年代版Serial</td></tr><tr><td>Parallel Old</td><td>Tenured</td><td>1.6</td><td>标记-整理</td><td>搭配Parallel Scavenge，吞吐量优先</td></tr><tr><td>CMS</td><td>Tenured</td><td>1.5</td><td>标记-清除</td><td>短时间停顿，响应速度极快</td></tr><tr><td>G1</td><td>ALL</td><td>1.7</td><td>标记-整理</td><td>并行和并发， 可预测停顿</td></tr></tbody></table><h4 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h4><ul><li>Serial：串行化收集器、DefNew(默认新生代收集器)</li><li>ParNew：并行新生代收集器(Parallel New)</li><li>Parallel Scavenge：PSYoungGen、PSScavenge、并行清除收集器</li><li>Serial Old：串行化老年代收集器</li><li>Parallel Old：PSMarkSweep、PSCompact、并行老年代收集器</li><li>CMS：Concurrent Mark Sweep、并发标记扫描、Concurrent Low Pause Collector、并发低停顿收集器</li><li>G1：Garbage First、垃圾优先收集器</li></ul><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="external">Our Collectors</a></p><p><a href="https://www.zhihu.com/question/43492129" target="_blank" rel="external">Parallel Scavenge收集器为何无法与CMS同时使用？</a></p><p><a href="http://hllvm.group.iteye.com/group/topic/37095#post-242695" target="_blank" rel="external">ParNew和PSYoungGen和DefNew是一个东西么—R大的回答</a></p><p><a href="https://github.com/kailbin/blog/issues/7" target="_blank" rel="external">Java GC总结</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jmeter入门</title>
      <link href="/jmeter/start.html"/>
      <url>/jmeter/start.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>接口测试</li><li>压力测试</li><li>监控</li></ul><a id="more"></a><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="external">Apache JMeter 4.0</a></p><p><a href="https://jmeter-plugins.org/wiki/PerfMon/" target="_blank" rel="external">PerfMon (Servers Performance Monitoring)</a></p><p><a href="https://jmeter-plugins.org/downloads/old/" target="_blank" rel="external">JMeterPlugins-Standard-1.4.0.zip 和JMeterPlugins-Extras-1.4.0.zip</a></p><p><a href="https://github.com/undera/perfmon-agent/blob/master/README.md" target="_blank" rel="external">PerfMon Server Agent</a></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li>解压JMeterPlugins-Standard-1.4.0.zip，将其中<code>\lib\ext\JMeterPlugins-Standard.jar</code>包复制到jmeter安装目录下的<code>\lib\ext</code>下</li><li>解压JMeterPlugins-Extras-1.4.0.zip，将其中<code>\lib\ext\JMeterPlugins-Extras.jar</code>包复制到jmeter安装目录下的<code>\lib\ext</code>下</li><li>解压jpgc-perfmon-2.1,<ul><li>将其中\lib下的<code>jmeter-plugins-cmn-jmeter-0.4.jar</code>和<code>perfmon-2.2.2.jar</code> 包复制到jmeter安装目录下的<code>\lib</code>下</li><li>将其中\lib\ext下的<code>jmeter-plugins-manager-0.20.jar</code>和<code>jmeter-plugins-perfmon-2.1.jar</code>包复制到jmeter安装目录下的<code>\lib\ext</code>下</li></ul></li><li>重启jmeter</li><li>启动ServerAgent<ul><li>Windows:<code>startAgent.bat</code></li><li>Linux:<code>startAgent.sh</code></li></ul></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h4><p>jmeter文件夹下的/bin目录</p><ul><li>Windows:<code>jmeter.bat</code></li><li>Linux:<code>jmeter.sh</code></li></ul><h4 id="添加线程组"><a href="#添加线程组" class="headerlink" title="添加线程组"></a>添加线程组</h4><ul><li><code>Test Plan</code>右键 -&gt; <code>Add</code> -&gt; <code>Threads(User)</code> -&gt; <code>Thread Group</code><ul><li>设置线程数和循环次数</li></ul></li></ul><h4 id="添加Http请求默认值"><a href="#添加Http请求默认值" class="headerlink" title="添加Http请求默认值"></a>添加Http请求默认值</h4><ul><li><code>Thread Group</code>右键 -&gt; <code>Add</code> -&gt; <code>Config Element</code> -&gt; <code>Http Request Defauls</code><ul><li>设置<code>Protocol</code>、<code>Server Name or IP</code>、<code>Port Number</code>、<code>Path</code>等</li></ul></li></ul><h4 id="添加Http请求"><a href="#添加Http请求" class="headerlink" title="添加Http请求"></a>添加Http请求</h4><ul><li><code>Thread Group</code>右键 -&gt; <code>Add</code> -&gt; <code>Sampler</code>  -&gt; <code>Http Request</code><ul><li>设置<code>Method</code>、<code>Path</code>、<code>Parameters</code>或<code>Body Data</code></li></ul></li></ul><h4 id="添加报告"><a href="#添加报告" class="headerlink" title="添加报告"></a>添加报告</h4><ul><li><code>HTTP Request</code>右键 -&gt; <code>Add</code> -&gt; <code>Listener</code><ul><li><code>View Results Tree</code></li><li><code>Summary Report</code></li><li><code>Aggregate Report</code></li></ul></li></ul><h4 id="添加IO、Memory、CPU监控"><a href="#添加IO、Memory、CPU监控" class="headerlink" title="添加IO、Memory、CPU监控"></a>添加IO、Memory、CPU监控</h4><p><code>Thread Group</code>右键 -&gt; <code>Add</code>  -&gt; <code>Listener</code> -&gt; <code>jp@gc - PerfMon Metrics Collector</code></p><p>其中，<code>Host/IP</code>，填写服务器的IP，如果是本地，则填写<code>127.0.0.1</code>，<code>Port</code>填写<code>4444</code>,<code>Metric to collect</code>可以选择<code>CPU</code>、<code>Memory</code>、<code>Disks I/O</code>、<code>Network I/O</code>。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ul><li><code>ServerAgent</code>目录下<ul><li>Windows：<code>startAgent.bat</code></li><li>Linux：<code>startAgent.sh</code></li></ul></li><li><code>jmeter</code> -&gt; <code>Run</code> -&gt; <code>Start</code></li></ul><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul><li><code>View Results Tree</code></li><li><code>Summary Report</code></li><li><code>Aggregate Report</code></li><li><code>jp@gc - PerfMon Metrics Collector</code></li></ul><p>查看</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fqsdgjyv3qj216o0o0jv3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> jmeter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jmeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础</title>
      <link href="/Python/basis.html"/>
      <url>/Python/basis.html</url>
      
        <content type="html"><![CDATA[<p><strong>本文适合有编码经验的用户阅读</strong></p><a id="more"></a><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul><li>精准<ul><li>除法用<code>//</code>，称为地板除，两个整数的除法仍是整数。</li><li><code>10//3</code>输出为<code>3</code></li></ul></li><li>也可用十六进制表示</li><li>没有大小限制</li></ul><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><ul><li>存在四舍五入的误差</li><li>很大或很小的浮点数必须用科学计数法表示</li><li>除法<code>/</code>结果是浮点数，即使两个整数恰好整除，结果也是浮点数</li><li>无大小限制，但是超过一定范围就直接表示为<code>inf</code>(无限大)</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>可以用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来，例：<code>&#39;a&#39;</code>或<code>&quot;a&quot;</code></li><li>包含<code>&#39;&#39;</code>，就使用<code>&quot;&quot;</code>括起来，例：<code>&quot;I&#39;m OK&quot;</code></li><li>既包含<code>&#39;&#39;</code>又包含<code>&quot;&quot;</code>，则用转义字符<code>\</code>，例：<code>&#39;I\&#39;m \&quot;OK\&quot;!&#39;</code></li><li>需要输出转义字符本身，则用<code>r</code>，例：<code>print(r&#39;\\\t\\&#39;)</code>，输出<code>\\\t\\</code></li><li>多次换行，命令行模式则用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>，例<code>print(&#39;&#39;&#39;line1</code>，回车，会提示继续输入，直到输入<code>&#39;&#39;&#39;)</code>，才会打印所有输入的内容；文件模式，直接换行写输入内容即可，同样，多次换行也可以使用<code>r</code>来输出转义字符</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqi4nkz6ebj20vo0p4gnt.jpg" alt=""></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fqi4nnfn1zj21kw0ps41p.jpg" alt=""></p><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><ul><li>值有两种：<code>True</code>和<code>False</code>。大小写敏感</li><li>运算有：<code>and</code>、<code>or</code>和<code>not</code></li></ul><h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><ul><li>值为<code>None</code></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li>弱类型</li></ul><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><ul><li>全大写</li><li>Python没有任何机制保证常量值不会被改变。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python入门</title>
      <link href="/Python/start.html"/>
      <url>/Python/start.html</url>
      
        <content type="html"><![CDATA[<h3 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h3><blockquote><p><a href="https://wiki.python.org/moin/Python2orPython3" target="_blank" rel="external">Python2.x是遗产，Python3.x是当前和未来的语言</a></p></blockquote><a id="more"></a><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><ul><li>2008年—3.0</li></ul><ul><li>2010年中—2.7release版</li><li>2012—3.3</li><li>2014—3.4</li><li>2015—3.5</li><li>2016—3.6</li></ul><blockquote><p>这意味着所有最近的标准库改进都只能在Python 3.x中默认使用</p></blockquote><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://www.python.org/downloads/" target="_blank" rel="external">官网下载</a></p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="external">廖雪峰的官方网站</a></p><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><p><a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code</a></p><p><a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python" target="_blank" rel="external">Python extension for Visual Studio Code</a></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>缩紧使用4个空格</li><li>大小写敏感</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp攻略-北美洲</title>
      <link href="/walkup/NA.html"/>
      <url>/walkup/NA.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>北美洲篇</strong>签证攻略。</p></blockquote><a id="more"></a><h4 id="哥斯达黎加"><a href="#哥斯达黎加" class="headerlink" title="哥斯达黎加"></a>哥斯达黎加</h4><p>哥斯达黎加是哥伦布第几次航行时发现—<strong>第四次</strong></p><p>圣何塞是中美洲最高的首都吗—<strong>是</strong></p><p>哥斯达黎加境内有军队吗—<strong>没有</strong></p><p>哥斯达黎加是永久中立国吗—<strong>是</strong></p><p>哥斯达黎加喜欢用什么称呼他人—<strong>学衔</strong></p><h4 id="尼加拉瓜"><a href="#尼加拉瓜" class="headerlink" title="尼加拉瓜"></a>尼加拉瓜</h4><p>尼加拉瓜境内有长城吗—<strong>有</strong></p><p>尼加拉瓜最早的土著民以什么为主—<strong>印第安人</strong></p><p>马那瓜的玉米节在什么时候举行—<strong>9月26日</strong></p><p>尼加拉瓜在什么时间宣布独立—<strong>1821年</strong></p><p>尼加拉瓜湖是中美洲最大的湖泊吗—<strong>是</strong></p><h4 id="危地马拉"><a href="#危地马拉" class="headerlink" title="危地马拉"></a>危地马拉</h4><p>危地马拉城是危地马拉最大的城市吗—<strong>是</strong></p><p>捕捉格查尔鸟违反危地马拉法律吗—<strong>违反</strong></p><p>危地马拉是玛雅文化中心之一吗—<strong>是</strong></p><p>危地马拉境内主要以什么地形为主—<strong>山地</strong></p><p>阿蒂特兰湖盛产什么鱼—<strong>黑鲈鱼</strong></p><h4 id="牙买加"><a href="#牙买加" class="headerlink" title="牙买加"></a>牙买加</h4><p>牙买加是英联邦国家吗—<strong>是</strong></p><p>NBA传奇巨星尤因是牙买加人吗—<strong>是</strong></p><p>牙买加在印第安语中意为什么—<strong>林水之乡</strong></p><p>哥伦布最初登陆牙买加的地点被称为—<strong>发现湾</strong></p><p>牙买加是蓝山咖啡的产地吗—<strong>是</strong></p><h4 id="古巴"><a href="#古巴" class="headerlink" title="古巴"></a>古巴</h4><p>古巴在泰诺语中意为什么—<strong>肥沃之地</strong></p><p>古巴导弹危机也被称为什么—<strong>加勒比海导弹危机</strong></p><p>古巴岛是大安的列斯群岛中最大的岛屿吗—<strong>是</strong></p><p>古巴境内最长的河流名为什么—<strong>考托河</strong></p><p>古巴是美洲唯一的社会主义国家吗—<strong>是</strong></p><h4 id="墨西哥"><a href="#墨西哥" class="headerlink" title="墨西哥"></a>墨西哥</h4><p>墨西哥是世界第一大西班牙语国家吗—<strong>是</strong></p><p>墨西哥的国酒是什么—<strong>龙舌兰酒</strong></p><p>已知最古老的美洲文明是什么—<strong>奥尔梅克文明</strong></p><p>墨西哥保持着食虫的传统吗—<strong>有</strong></p><p>玉米是墨西哥古印第安人培育的吗—<strong>是</strong></p><h4 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h4><p>美国的最高山峰是哪座山—<strong>迪纳利山</strong></p><p>哪个形象是美国的国家象征—<strong>山姆大叔</strong></p><p>美国是美洲第一大面积国家吗—<strong>不是</strong></p><p>总统山在哪个国家公园—<strong>拉什莫尔山国家纪念公园</strong></p><p>白宫曾经被焚毁过吗—<strong>有</strong></p><h4 id="加拿大"><a href="#加拿大" class="headerlink" title="加拿大"></a>加拿大</h4><p>加拿大的政治体制是—<strong>君主立宪制</strong></p><p>加拿大国旗两边的红色代表了—<strong>大西洋和太平洋</strong></p><p>加拿大的首都是—<strong>渥太华</strong></p><p>下面哪一项是加拿大的国花—<strong>枫叶</strong></p><p>加拿大的国球是哪一个—<strong>旱冰球</strong></p>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac切换JDK版本</title>
      <link href="/JDK/jdkVersion.html"/>
      <url>/JDK/jdkVersion.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在看<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机（第2版）</a>第二章的内容时，内存溢出在不同JDK版本下会有不同的表现，想测试不同<code>JDK</code>版本下，内存溢出的效果。</p><a id="more"></a><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>在IDE中写对应内存溢出的代码，添加JVM参数，运行成功。</p><p>使用不同JDK版本时，如果每次都需要修改IDE环境较为繁琐，所以想通过命令行的方式来指定JDK版本。</p><p><strong>然而</strong></p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fq0mrro9adj20t802o0tj.jpg" alt="[Could not find or load main class](https://huati.weibo.com/k/Could+not+find+or+load+main+class?from=501) "></p><h3 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h3><ul><li>文件本身错误<ul><li>在IDE内运行成功，排除</li></ul></li><li>命令行使用方式错误<ul><li>检查命令行有无拼写错误或参数错误，排除</li><li>Windows命令行环境下运行成功，排除</li></ul></li><li>环境变量错误</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><strong>安装包(注意都是下载mac下的dmg安装包)：</strong></p><p><a href="http://support.apple.com/kb/DL1572" target="_blank" rel="external">JDK 1.6</a></p><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">JDK 1.7&amp;1.8&amp;1.9（早期版本在页面下方）</a></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>关于Mac系统的环境变量文件入门介绍，可参考<a href="https://super2bai.github.io/2018/04/04/varFile/">Linux环境变量文件</a>。</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><ul><li><code>vi ~/.bash_profile</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>配置版本</div><div class="line">export JAVA_6_HOME=`/usr/libexec/java_home -v 1.6`  </div><div class="line">export JAVA_7_HOME=`/usr/libexec/java_home -v 1.7`  </div><div class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8` </div><div class="line"><span class="meta">#</span>配置JAVA_HOME</div><div class="line">export JAVA_HOME=`/usr/libexec/java_home`</div><div class="line"><span class="meta">#</span>配置PATH</div><div class="line">export PATH="$JAVA_HOME:$PATH"</div><div class="line"><span class="meta">#</span>alias命令动态切换JDK版本</div><div class="line">alias jdk6="export JAVA_HOME=$JAVA_6_HOME"</div><div class="line">alias jdk7="export JAVA_HOME=$JAVA_7_HOME"</div><div class="line">alias jdk8="export JAVA_HOME=$JAVA_8_HOME"</div></pre></td></tr></table></figure><ul><li><code>source ~/.bash_profile</code></li><li>通过命令行输入<code>jdk6</code>、<code>jdk7</code>、<code>jdk8</code>、<code>jdk9</code>可以快速切换版本</li></ul><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fq4q31yyrdj20se0kek7x.jpg" alt="Mac切换JDK版本"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="不建议"><a href="#不建议" class="headerlink" title="不建议"></a>不建议</h4><blockquote><ul><li>根据<a href="https://developer.apple.com/library/content/qa/qa1170/_index.html" target="_blank" rel="external">苹果的官方说明</a>，Mac OS X 10.5 及以后的版本应该使用 /usr/libexec/java_home 命令来确定 JAVA_HOME。</li><li>版本发生变化需要修改配置</li><li>无法适应不同的Java实现(Apple、Oracle、OpenJDk)</li></ul></blockquote><h4 id="关于JDK路径"><a href="#关于JDK路径" class="headerlink" title="关于JDK路径"></a>关于JDK路径</h4><ul><li>终端输入执行：<code>which java</code>，显示<code>/usr/bin/java</code></li><li>执行<code>cd /usr/bin/</code>，再执行<code>ls -l |grep java</code>，可看到java此命令是link到<code>/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</code></li><li>执行：<code>cd /System/Library/Frameworks/JavaVM.framework/Versions/</code>进入后，再执行<code>ls -l</code>，可看到<code>Current -&gt; A</code>，也就是Current目录link到A目录。而A目录在安装第一个JDK时就存在，用来JDK多版本管理使用的。</li></ul><blockquote><p><code>/System/Library/Frameworks/JavaVM.framework/Versions/</code> 下有多个不同（低）版本的目录，但它们链接的都是 CurrentJDK 目录。总之，这些Java都是苹果提供的Java，Oracle 或 OpenJDK 提供的 Java 不在此目录中。</p></blockquote><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>取消了<code>/etc/profile</code>和<code>~/.bash_profile</code>两个文件中，对<code>JAVA_HOME</code>添加到<code>PATH</code>的语句后，输入<code>java -version</code>依旧出现版本信息。经查验，是因为在<code>/usr/bin</code>中存在<code>java</code>。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fq2s4n7x7rj20d8020mye.jpg" alt=""></p><blockquote><p>所有用户皆可用的系统程序放在/bin</p><p>超级用户才能使用的系统程序放在/sbin</p><p>所有用户都可用的应用程序放在/usr/bin</p><p>超级用户才能使用的应用程序放在/usr/sbin</p><p>所有用户都可用的与本地机器无关的程序存放在/usr/local/bin</p></blockquote><p>更多文件系统说明，可在<code>terminal</code>中输入<code>man hier</code>查看文件系统层次说明。</p><hr><ul><li>编辑文件时，如需要整行移动<ul><li>通过<code>dd</code>当前行，在合适的地方<code>p</code>。</li><li><code>:5 move 2</code></li><li>map快捷键</li><li><a href="https://github.com/tpope/vim-unimpaired" target="_blank" rel="external">安装插件vim-unimpaired</a><ul><li>装好后按[e或者]e这两个快捷键移动当前行到上面或者下面</li></ul></li></ul></li></ul><h3 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h3><p><a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html" target="_blank" rel="external">PATH and CLASSPATH</a></p><p><a href="https://www.zhihu.com/question/21265424" target="_blank" rel="external">Linux文件系统中/bin、/sbin、/usr/bin、/usr/sbin、/usr/local/bin、/usr/local/sbin文件夹的区别是什么？</a></p><p><a href="https://blog.csdn.net/davidhsing/article/details/8297105" target="_blank" rel="external">Mac 上 java 究竟在哪里，本文彻底让你搞清楚！</a></p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境变量文件</title>
      <link href="/Linux/varFile.html"/>
      <url>/Linux/varFile.html</url>
      
        <content type="html"><![CDATA[<h3 id="全局有效-所有用户"><a href="#全局有效-所有用户" class="headerlink" title="全局有效(所有用户)"></a>全局有效(所有用户)</h3><a id="more"></a><ul><li><p><code>/etc/profile</code>: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 <code>/etc/profile.d</code> 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。</p></li><li><p><code>/etc/bashrc</code>: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。</p></li><li><p>此外，修改 <code>/etc/environment</code> 这个文件也能实现环境变量的设置。</p><blockquote><p>/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境</p></blockquote></li></ul><h3 id="单个用户生效"><a href="#单个用户生效" class="headerlink" title="单个用户生效"></a>单个用户生效</h3><ul><li><code>~/.bash_profile</code> 或 <code>~/.profile</code>: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。</li></ul><blockquote><p>另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 <code>~/.bash_profile</code>，<code>~/.bash_login</code> 或 <code>~/.profile</code> 其中的一种或几种。</p><p>如果存在几种的话，那么执行的顺序便是：<code>~/.bash_profile</code>、<code>~/.bash_login</code>、<code>~/.profile</code>。比如 系统一般是 ~/.profile 文件。</p></blockquote><ul><li><code>~/.bashrc</code>: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM元数据区溢出</title>
      <link href="/JVM/metaspace.html"/>
      <url>/JVM/metaspace.html</url>
      
        <content type="html"><![CDATA[<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>String.intern()</code>是一个<code>Native</code>方法。</p><a id="more"></a><blockquote><p>如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p></blockquote><h4 id="不同版本下常量池位置"><a href="#不同版本下常量池位置" class="headerlink" title="不同版本下常量池位置"></a>不同版本下常量池位置</h4><p><code>JDK1.6</code>方法区</p><p><code>JDK1.7</code>堆内存，<a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html" target="_blank" rel="external">官方文档</a></p><blockquote><p><strong>Area:</strong> HotSpot<br><strong>Synopsis:</strong> In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.<br><strong>RFE:</strong> <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6962931" target="_blank" rel="external">6962931</a></p></blockquote><p><code>JDK1.8</code>元空间，和堆相独立，本地内存,<a href="https://blogs.oracle.com/poonam/about-g1-garbage-collector%2c-permanent-generation-and-metaspace" target="_blank" rel="external">About G1 Garbage Collector, Permanent Generation and Metaspace</a></p><h4 id="改变的原因"><a href="#改变的原因" class="headerlink" title="改变的原因"></a>改变的原因</h4><ul><li><code>PermGen</code>需要的大小很难预测，它导致配置不足或触发<code>java.lang.OutOfMemoryError：Permgen</code>大小错误或过度配置导致资源浪费。</li><li>GC性能改进，使得无需GC暂停和特定元数据迭代器的并发类数据分配成为可能</li><li>支持进一步优化，诸如G1并发类卸载</li></ul><p>所以如果对<code>PermGen</code>熟悉，那么所需要知道就是，不管在Java8以前的版本中<code>PermGen</code>有什么(类的名称和字段，类方法的字节码，常量池，JIT优化等等)，现在都分配在<code>Metaspace</code>中。</p><blockquote><p>元空间大小要求取决于加载的类的数量以及这些类声明的大小，所以很容易看到导致<code>java.lang.OutOfMemoryError:Metaspace</code>异常的主要原因，要么是类太多，要么是太大的类被加载到<code>Metaspace</code>。</p></blockquote><h4 id="元数据区泄漏实例"><a href="#元数据区泄漏实例" class="headerlink" title="元数据区泄漏实例"></a>元数据区泄漏实例</h4><h5 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h5><ul><li>接口类<code>ClassA</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.metaspace;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassA</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String input)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>实现类<code>ClassAImpl</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.metaspace;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAImpl</span> <span class="keyword">implements</span> <span class="title">ClassA</span></span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String input)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>Handler类<code>ClassAInvocationHandler</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.metaspace;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAInvocationHandler</span>  <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</div><div class="line"><span class="keyword">private</span> Object classAImpl;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassAInvocationHandler</span><span class="params">(Object impl)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.classAImpl=impl;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="keyword">return</span> method.invoke(classAImpl, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>入口类<code>ClassMetadataLeakSimulator</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.metaspace;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.net.URLClassLoader;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassMetadataLeakSimulator</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ClassA&gt; classLeakingMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">String fictiousClassloaderJAR = <span class="string">"file:"</span> + (i++) + <span class="string">".jar"</span>;</div><div class="line">URL[] fictiousClassloaderURL=<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(fictiousClassloaderJAR)&#125;;</div><div class="line">URLClassLoader newClassLoader=<span class="keyword">new</span> URLClassLoader(fictiousClassloaderURL);</div><div class="line">ClassA t=(ClassA)Proxy.newProxyInstance(newClassLoader, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ClassA.class&#125;, <span class="keyword">new</span> ClassAInvocationHandler(<span class="keyword">new</span> ClassAImpl()));</div><div class="line">classLeakingMap.put(fictiousClassloaderJAR, t);</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">t.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JVM参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-verbose:gc -XX:MaxMetaspaceSize=<span class="number">20</span>M -XX:MetaspaceSize=<span class="number">10</span>M</div></pre></td></tr></table></figure><ul><li>运行结果：<code>java.lang.OutOfMemoryError: Metaspace</code></li></ul><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fptht4b1dsj21kc0zeh0d.jpg" alt="JVM-1.8-metaspace溢出"></p><h5 id="CGLib"><a href="#CGLib" class="headerlink" title="CGLib"></a>CGLib</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm.metaspace.cglib;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</div><div class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaspaceOOM</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</div><div class="line">enhancer.setSuperclass(OOMObject.class);</div><div class="line">enhancer.setUseCache(<span class="keyword">false</span>);</div><div class="line">enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"><span class="keyword">return</span> proxy.invoke(obj, args);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">enhancer.create();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>JVM参数</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-verbose:class -XX:MetaspaceSize=3M -XX:MaxMetaspaceSize=3M -XX:+TraceClassLoading -XX:+TraceClassUnloading</div></pre></td></tr></table></figure><ul><li>运行结果</li></ul><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fptug8ir9jj21ka10ywt8.jpg" alt="CGLib"></p><h4 id="有意思的实例"><a href="#有意思的实例" class="headerlink" title="有意思的实例"></a>有意思的实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="comment">// true</span></div><div class="line">String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</div><div class="line">System.out.println(<span class="string">"str1.intern()==str1 : "</span> + (str1.intern() == str1));</div><div class="line"></div><div class="line"><span class="comment">// false</span></div><div class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</div><div class="line">System.out.println(<span class="string">"str2.intern()==str2 : "</span> + (str2.intern() == str2));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><ul><li><code>JDK1.7</code>和<code>JDK1.8</code>中运行，会得到一个<code>true</code>和<code>一个false</code>。</li><li>因为<code>JDK1.7+</code>的<code>intern()</code>实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此<code>intern()</code>返回的引用和由<code>StringBuilder</code>创建的那个字符串实例是同一个。</li><li><code>str2</code>比较返回<code>false</code>是因为<code>java</code>这个字符串在执行<code>StringBuilder.toString()</code>之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</li></ul></blockquote><p><strong>关于第三点，有个疑问。如果是第一次出现，则结果为true。不是第一次出现，结果为false。 拼接了ja和va，比较结果一直都是false。那么问题来了，既然不是首次出现，那java这词是什么时候进入到的常量池。为什么要进入。</strong></p><p>具体可参考此篇文章，写的比较不错。</p><p><a href="https://www.jianshu.com/p/b98851899f37" target="_blank" rel="external">关于String.intern()的一个疑惑</a></p><p>此处不再赘述。</p><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>不介绍版本就讨论JVM都是耍流氓的行为。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">《深入理解JVM》</a></p><p><a href="http://java-performance.info/string-intern-in-java-6-7-8/" target="_blank" rel="external">String.intern in Java 6, 7 and 8 – string pooling</a></p><p><a href="https://www.jianshu.com/p/b98851899f37" target="_blank" rel="external">关于String.intern()的一个疑惑</a></p><p><a href="https://www.zhihu.com/question/51102308/answer/124441115" target="_blank" rel="external">如何理解《深入理解java虚拟机》第二版中对String.intern()方法的讲解中所举的例子？</a></p><p><a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/" target="_blank" rel="external">Java中几种常量池的区分</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html" target="_blank" rel="external">Understand the OutOfMemoryError Exception</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机栈和本地方法栈溢出</title>
      <link href="/JVM/stack.html"/>
      <url>/JVM/stack.html</url>
      
        <content type="html"><![CDATA[<p>在Java虚拟机规范中描述了两种异常：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<code>StackOverflowError</code>异常</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常</li></ul><a id="more"></a><h4 id="单线程版"><a href="#单线程版" class="headerlink" title="单线程版"></a>单线程版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * VM Args:-Xss128k &lt;br/&gt;</span></div><div class="line"><span class="comment"> * The stack size specified is too small, Specify at least 160k&lt;br/&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * VM Args:-Xss160k&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 运行结果：</span></div><div class="line"><span class="comment"> * stackLength=771</span></div><div class="line"><span class="comment"> * Exception in thread "main" java.lang.StackOverflowError&lt;br/&gt;</span></div><div class="line"><span class="comment"> * at com.super2bai.jvm.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:19)</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</div><div class="line">stackLength++;</div><div class="line">stackLeak();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">JavaVMStackSOF vmStackSOF = <span class="keyword">new</span> JavaVMStackSOF();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">vmStackSOF.stackLeak();</div><div class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">System.out.println(<span class="string">"stackLength="</span> + vmStackSOF.stackLength);</div><div class="line"><span class="keyword">throw</span> e;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配时，虚拟机抛出的都是<code>StackOverflowError</code>异常。</p></blockquote><h4 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * -Xss2M</span></div><div class="line"><span class="comment"> * 运行代码后，系统无响应，暂无解决办法</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * 期望运行结果：</span></div><div class="line"><span class="comment"> * Exception in thread "Main" java.lang.OutOfMemoryError:unable to create new native thread</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">dontStop();</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">thread.start();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</div><div class="line">oom.stackLeakByThread();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>通过不断地建立线程的方式倒是可以产生内存溢出异常，<del>此处未实验成功，系统一直无响应，望大佬指教</del>，但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p><p>其实原因不难理解，操作系统分配给每个进程的内存是有限的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。</p><p>剩余的内存 = 2GB(系统限制) - Xmx(最大堆容量) - MaxPermSize(最大方法区容量)。</p><p>程序计数器消耗内存很小，可以忽略掉。</p><p>如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈使用。</p><p>每个线程分配到的栈容量越大，可以建立的线程数自然就越少，建立线程时就越容易把剩下的内存耗尽。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM堆溢出</title>
      <link href="/JVM/heap.html"/>
      <url>/JVM/heap.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>本文目的</strong></p><ul><li>通过代码验证Java虚拟机规范中描述的堆中存储的内容</li><li>遇到内存溢出错误时<ul><li>能根据异常的信息快速判断出是堆的溢出</li><li>出现此类问题后如何处理</li></ul></li></ul><a id="more"></a><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai &lt;br/&gt;</span></div><div class="line"><span class="comment"> *         VM Args:&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails</span></div><div class="line"><span class="comment"> *         -XX:SurvivorRatio=8&lt;br/&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> *         -verbose:gc&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         在虚拟机发生内存回收时在输出设备显示信息&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -Xms20M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         堆的最小可用内存为20M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -Xmx20M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         堆的最大可用内存为20M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -Xmn10M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         表示新生代分配10M&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -XX:+PrintGCDetails&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         打印GC日志到控制台&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -XX:SurvivorRatio=8&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         表示新生代的eden区:from区：to区:8:1:1&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         -XX:+HeapDumpOnOutOfMemoryError&lt;br/&gt;</span></div><div class="line"><span class="comment"> *         让虚拟机在出现内存溢出时Dump出当前的内存转储快找以便事后分析&lt;br/&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> *         PS：堆的最大可用内存和最小可用内存设置成相同的值，即可避免堆自动扩展&lt;br/&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Java堆用来存放对象实例&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 只要不断创建对象&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象&lt;br/&gt;</span></div><div class="line"><span class="comment"> * 那么对象数量到达最大堆的容量限制之后就会产生内存溢出异常&lt;br/&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line">list.add(<span class="keyword">new</span> OOMObject());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="设置虚拟机参数"><a href="#设置虚拟机参数" class="headerlink" title="设置虚拟机参数"></a>设置虚拟机参数</h4><p>右键单击类文件 -&gt; <code>Run As</code> -&gt; <code>Run Configurations...</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=<span class="number">8</span> -XX:+HeapDumpOnOutOfMemoryError</div></pre></td></tr></table></figure><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fpjp9y90fkj21di0zk47c.jpg" alt="VM Args"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2aly1fpkf3xo2ltj21kw0k0k02.jpg" alt="堆内存溢出"></p><p>运行后，如果未指定dump文件路径，会在当前项目的根路径下生成名为<code>java_pid*.hprof</code>的文件，如果没有此文件，<code>F5</code>刷新当前项目。</p><blockquote><p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。</p><p>当出现Java堆内存溢出时，异常堆栈信息<code>java.lang.OutOfMemoryError</code>会跟着进一步提示<code>Java heap space</code>。</p></blockquote><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>一般的手段时通过内存映像分析工具(如·Eclipse Memory Analyzer·)对Dump出来的堆转储快进行分析，重点是<strong>确认内存中的对象是否是必要的</strong>，也就是要先<strong>分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)</strong>。</p><h4 id="Eclipse-Memory-Analyzer"><a href="#Eclipse-Memory-Analyzer" class="headerlink" title="Eclipse Memory Analyzer"></a>Eclipse Memory Analyzer</h4><p><a href="http://wiki.eclipse.org/MemoryAnalyzer" target="_blank" rel="external">MemoryAnalyzer官网</a></p><p><a href="http://www.vogella.com/tutorials/EclipseMemoryAnalyzer/article.html" target="_blank" rel="external">安装使用教程</a></p><p><a href="https://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer/" target="_blank" rel="external">MAT使用技巧</a></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://dzone.com/articles/memory-leak-andjava-code" target="_blank" rel="external">Memory Leaks and Java Code</a></p><p><a href="https://developers.redhat.com/blog/2014/08/14/find-fix-memory-leaks-java-application/" target="_blank" rel="external">How to find and fix memory leaks in your Java application</a></p><p><del>日后有时间将会翻译并发布上面两篇文章</del></p><p><a href="http://hllvm.group.iteye.com/group/topic/37095" target="_blank" rel="external">重点看RednaxelaFx的回答，R大讲的不错</a></p><p><a href="https://stackoverflow.com/questions/4943518/what-is-the-difference-between-an-outofmemoryerror-amd-a-memory-leak" target="_blank" rel="external">What is the difference between an OutOfMemoryError and a memory leak</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM对象的访问定位</title>
      <link href="/JVM/position.html"/>
      <url>/JVM/position.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>核心内容：如何找对象</p><p>方式：句柄、直接指针</p><a id="more"></a><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>Java程序通过<strong>栈上的<code>reference</code>数据</strong>来操作堆上的具体对象。</p><p><code>reference</code>类型在Java虚拟机规范中只规定了<strong>一个指向对象的引用</strong>，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以<strong>对象访问方式也是取决于虚拟机实现</strong>而定的。</p><h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fpjmzwd02kj20gw0bbmxs.jpg" alt="句柄方式"></p><blockquote><p>优点：reference中存储的是稳定的句柄地址。</p><p>在对象被移动(垃圾收集时移动对象时非常普遍的行为)时，只会改变句柄中的实例数据指针，而reference本身不需要修改。</p></blockquote><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fpjn61pzxnj20gw0bbmxp.jpg" alt="直接指针"></p><blockquote><p>优点：速度更快，它节省了一次指针定位的时间开销。</p><p>由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>HotSpot使用直接指针来访问对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM中对象的内存布局</title>
      <link href="/JVM/layout.html"/>
      <url>/JVM/layout.html</url>
      
        <content type="html"><![CDATA[<ul><li>在HotSpot中，对象在内存中存储的布局<ul><li>对象头Header<ul><li>对象自身的运行时数据</li><li>类型指针</li></ul></li><li>实例数据Instance Data</li><li>对齐填充Padding</li></ul></li></ul><a id="more"></a><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fpjm5sxmppj20ll0uagn7.jpg" alt="Markdown"></p><h3 id="对象头Header"><a href="#对象头Header" class="headerlink" title="对象头Header"></a>对象头Header</h3><h4 id="对象自身的运行时数据-Mark-Word"><a href="#对象自身的运行时数据-Mark-Word" class="headerlink" title="对象自身的运行时数据(Mark Word)"></a>对象自身的运行时数据(Mark Word)</h4><ul><li>包含内容<ul><li>哈希码(HashCode)</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li><li>…</li></ul></li><li>长度<ul><li>32位虚拟机<ul><li>32bit</li></ul></li><li>64位虚拟机<ul><li>64bit(未开启指针压缩)</li><li>32bit(开启指针压缩)</li></ul></li></ul></li><li>非固定的数据结构<ul><li>原因<ul><li>对象头信息是与对象自身定义的数据无关的额外存储成本</li><li>考虑虚拟机的空间效率</li></ul></li><li>目的<ul><li>为了在极小的空间存储尽量多的信息</li></ul></li><li>根据对象的状态复用自己的存储空间</li></ul></li></ul><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><ul><li>在32位HotSpot虚拟机中，如果对象处于未被锁定的状态下<ul><li>25bit-&gt;对象哈希码</li><li>4bit-&gt;对象分代年龄</li><li>2bit-&gt;锁标志位</li><li>1bit-&gt;固定位0</li></ul></li><li>其它状态下(轻量级锁定、重量级锁定、GC标记、可偏向)下对象存储内容</li></ul><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀(重量级锁定)</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><blockquote><p>对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><ul><li>注意<ul><li>查找对象的元数据信息不一定要经过对象本身。</li><li>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据<ul><li>虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法从数组的元数据中确定数组的大小</li></ul></li></ul></li></ul></blockquote><h3 id="实例数据Instance-Data"><a href="#实例数据Instance-Data" class="headerlink" title="实例数据Instance Data"></a>实例数据Instance Data</h3><blockquote><p>对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p>无论是从父类继承下来的，还是在子类中定义的，都需要记录。</p><ul><li>影响存储顺序的原因<ul><li>虚拟机分配策略参数(FieldsAllocationStyle)</li><li>字段在Java远吗中定义的顺序</li></ul></li></ul></blockquote><h4 id="HotSpot虚拟机默认的分配策略"><a href="#HotSpot虚拟机默认的分配策略" class="headerlink" title="HotSpot虚拟机默认的分配策略"></a>HotSpot虚拟机默认的分配策略</h4><blockquote><p>相同宽度的字段总是被分配到一起</p></blockquote><ul><li><code>longs</code>/<code>doubles</code></li><li><code>ints</code>/<code>floats</code></li><li><code>shorts</code>/<code>chars</code></li><li><code>bytes</code>/<code>boolean</code></li><li><code>references</code></li><li><code>oops(Ordinary Object Pointers)</code></li></ul><p>在此前提下，在父类中定义的变量会出现在子类之前。</p><p>如果CompactFields参数值为<code>true</code>(默认为<code>true</code>)，那么子类中较窄的变量也可能会插入到父类变量的空隙之中。<del>代码参考下面的测试实例中CompactFields()</del></p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p><strong>不是必然存在，无特别含义，仅仅是占位符</strong></p><blockquote><p>由于HotSpot VM的自动内存管理系统要求对象起始地址(对象的大小)必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1或2倍)，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p></blockquote><h3 id="对象占用内存大小"><a href="#对象占用内存大小" class="headerlink" title="对象占用内存大小"></a>对象占用内存大小</h3><p><strong>普通对象占用内存情况</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">32位系统</th><th style="text-align:center">64位系统(+UseCompressedOops)</th><th style="text-align:center">64位系统(-UseCompressedOops)</th></tr></thead><tbody><tr><td style="text-align:center">Mark Word</td><td style="text-align:center">4 bytes</td><td style="text-align:center">8 bytes</td><td style="text-align:center">8 bytes</td></tr><tr><td style="text-align:center">Class Pointer</td><td style="text-align:center">4 bytes</td><td style="text-align:center">4 bytes</td><td style="text-align:center">8 bytes</td></tr><tr><td style="text-align:center">对象头</td><td style="text-align:center">8 bytes</td><td style="text-align:center">12 bytes</td><td style="text-align:center">16 bytes</td></tr></tbody></table><p><strong>数组对象占用内存情况</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">32位系统</th><th style="text-align:center">64位系统(+UseCompressedOops)</th><th style="text-align:center">64位系统(-UseCompressedOops)</th></tr></thead><tbody><tr><td style="text-align:center">Mark Word</td><td style="text-align:center">4 bytes</td><td style="text-align:center">8 bytes</td><td style="text-align:center">8 bytes</td></tr><tr><td style="text-align:center">Class Pointer</td><td style="text-align:center">4 bytes</td><td style="text-align:center">4 bytes</td><td style="text-align:center">8 bytes</td></tr><tr><td style="text-align:center">Length</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td></tr><tr><td style="text-align:center">对象头</td><td style="text-align:center">12 bytes</td><td style="text-align:center">16 bytes</td><td style="text-align:center">20 bytes</td></tr></tbody></table><p><strong>实例数据</strong></p><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">32位系统</th><th style="text-align:center">64位系统 (+UseCompressedOops)</th><th style="text-align:center">64位系统 (-UseCompressedOops)</th></tr></thead><tbody><tr><td style="text-align:center">double</td><td style="text-align:center">8bytes</td><td style="text-align:center">8bytes</td><td style="text-align:center">8bytes</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8bytes</td><td style="text-align:center">8bytes</td><td style="text-align:center">8bytes</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td><td style="text-align:center">4bytes</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2bytes</td><td style="text-align:center">2bytes</td><td style="text-align:center">2bytes</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2bytes</td><td style="text-align:center">2bytes</td><td style="text-align:center">2bytes</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">1bytes</td><td style="text-align:center">1bytes</td><td style="text-align:center">1bytes</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1bytes</td><td style="text-align:center">1bytes</td><td style="text-align:center">1bytes</td></tr><tr><td style="text-align:center">oops(ordinary object pointers)</td><td style="text-align:center">4 bytes</td><td style="text-align:center">4 bytes</td><td style="text-align:center">8 bytes</td></tr></tbody></table><h3 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.super2bai.jvm;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.util.Collection;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.omg.PortableServer.ServantActivator;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.javamex.classmexer.MemoryUtil;</div><div class="line"><span class="keyword">import</span> com.javamex.classmexer.MemoryUtil.VisibilityFilter;</div><div class="line"></div><div class="line"><span class="keyword">import</span> sun.misc.Unsafe;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * ① 将下载的 classmexer.jar 加入当前项目的classpath中&lt;br&gt;</span></div><div class="line"><span class="comment"> * ② 启动Main是添加启动项：&lt;br&gt;</span></div><div class="line"><span class="comment"> * -javaagent:/Users/2bai/Downloads/classmexer.jar&lt;br&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ③ JVM 参数： &lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:+UseCompressedOops (默认启用）&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:+CompactFields (默认启用）&lt;br&gt;</span></div><div class="line"><span class="comment"> * -XX:FieldsAllocationStyle=1 （默认为1）&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * JDK版本：1.8</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheObjectMemory</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe UNSAFE;</div><div class="line"><span class="comment">// 获得Unsafe</span></div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</div><div class="line">theUnsafe.setAccessible(<span class="keyword">true</span>);</div><div class="line">UNSAFE = (Unsafe) theUnsafe.get(Unsafe.class);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line"><span class="comment">// 测试对象内存布局</span></div><div class="line">testObjectLayout();</div><div class="line"><span class="comment">// 测试对象内存占用</span></div><div class="line">testMemoryUsage();</div><div class="line"><span class="comment">// 测试对齐填充位置</span></div><div class="line">testPaddingLocation();</div><div class="line"><span class="comment">// 测试空隙插入</span></div><div class="line">testCompactFields();</div><div class="line"><span class="comment">// 测试基本类型分配后再分配引用类型</span></div><div class="line">testReferenceAllocate();</div><div class="line"><span class="comment">// 测试对象总大小，包含引用对象占用的内存</span></div><div class="line">testDeepMemoryUsage();</div><div class="line"><span class="comment">// 测试数组对象占用内存大小</span></div><div class="line">testObjectArrayMemoryUsage();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试类</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectA</span> </span>&#123;</div><div class="line">String str; <span class="comment">// 4</span></div><div class="line"><span class="keyword">int</span> i1; <span class="comment">// 4</span></div><div class="line"><span class="keyword">byte</span> b1; <span class="comment">// 1</span></div><div class="line"><span class="keyword">byte</span> b2; <span class="comment">// 1</span></div><div class="line"><span class="keyword">int</span> i2; <span class="comment">// 4</span></div><div class="line">Object obj; <span class="comment">// 4</span></div><div class="line"><span class="keyword">byte</span> b3; <span class="comment">// 1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试对象内存布局</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testObjectLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试对象内存布局****"</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Oop指针是4还是未压缩的8也可以通过unsafe.arrayIndexScale(Object[].class)来获得&lt;br&gt;</span></div><div class="line"><span class="comment"> * 这个方法返回一个引用所占用的长度&lt;br&gt;</span></div><div class="line"><span class="comment"> * 因为在JDK 8中"UseCompressedOops"选项是默认启用的，因此class pointer只占用了4个字节。&lt;br&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> objectRefSize = UNSAFE.arrayIndexScale(ObjectA[].class);</div><div class="line">System.out.println(<span class="string">"ObjectA, Oop指针, length="</span> + objectRefSize);</div><div class="line"></div><div class="line"><span class="comment">// 通过反射获得一个类的Field</span></div><div class="line">Field[] fields = ObjectA.class.getDeclaredFields();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line"><span class="comment">// 通过Unsafe的objectFieldOffset()获得每个Field的offSet</span></div><div class="line"><span class="comment">// 可以看到确实是按照从长到短，引用排最后的方式在内存中排列的。</span></div><div class="line"><span class="comment">// 对Field按照offset排序，取得最小的offset，然后加上这个field的长度，再加上Padding对齐</span></div><div class="line">System.out.println(<span class="string">"ObjectA, "</span> + f.getType() + <span class="string">" "</span> + f.getName() + <span class="string">" offset: "</span> + UNSAFE.objectFieldOffset(f));</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 上面三步就可以获得一个对象的Shallow size。 可以进一步通过递归去计算所引用对象的大小，从而可以计算出一个对象所占用的实际大小。</span></div><div class="line"><span class="comment"> * 对象头(8)+Oops(4)+i1(4)+i2(4)+b1(1)+b2(1)+b3(1)+padding(1)+str(4)+obj(4)=32</span></div><div class="line"><span class="comment"> * 32正好为8的倍数，所以不需要额外填充</span></div><div class="line"><span class="comment"> */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试对象内存占用</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMemoryUsage</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试对象内存占用****"</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * returns the number of bytes occupied by an object&lt;br&gt;</span></div><div class="line"><span class="comment"> * not included any objects it refers to</span></div><div class="line"><span class="comment"> */</span></div><div class="line">ObjectA a = <span class="keyword">new</span> ObjectA();</div><div class="line">System.out.println(<span class="string">"ObjectA.class, memoryUsage : "</span> + MemoryUtil.memoryUsageOf(a));</div><div class="line"><span class="keyword">long</span> noBytes1 = MemoryUtil.deepMemoryUsageOf(a, VisibilityFilter.ALL);</div><div class="line">System.out.println(<span class="string">"ObjectA.class, VisibilityFilter=All, deepMemoryUsageOf="</span> + noBytes1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectB</span> </span>&#123;</div><div class="line"><span class="keyword">long</span> a;</div><div class="line"><span class="keyword">long</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试对齐填充位置&lt;br&gt;</span></div><div class="line"><span class="comment"> * 对象头(8)+Oops(4)+padding(4)+a(8)+b(8)&lt;br&gt;</span></div><div class="line"><span class="comment"> * padding为什么不是在最后呢？&lt;br&gt;</span></div><div class="line"><span class="comment"> * 是这样的，在64位系统中，CPU一次读操作可读取64bit（8 bytes）的数据。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 如果，你在对象头分配后就进行属性 long a字段的分配，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 也就是说从偏移量为12的地方分配8个字节，这将导致读取属性long a时需要执行两次读数据操作。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 因为第一次读取 到的数据中前4字节是对象头的内存，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 后4字节是属性long a的高4位（Java 是大端模式），&lt;br&gt;</span></div><div class="line"><span class="comment"> * 低4位的数据则需要通过第二次读取 操作获得。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPaddingLocation</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试对齐填充位置****"</span>);</div><div class="line">ObjectB b = <span class="keyword">new</span> ObjectB();</div><div class="line"><span class="comment">// memoryUsage : 32</span></div><div class="line">System.out.println(<span class="string">"ObjectB, memoryUsage : "</span> + MemoryUtil.memoryUsageOf(b));</div><div class="line"><span class="comment">// a field offset : 16</span></div><div class="line">System.out.println(<span class="string">"ObjectB, long a offset : "</span> + UNSAFE.objectFieldOffset(ObjectB.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line"><span class="comment">// b field offset : 24</span></div><div class="line">System.out.println(<span class="string">"ObjectB, long b offset : "</span> + UNSAFE.objectFieldOffset(ObjectB.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectC</span> </span>&#123;</div><div class="line"><span class="keyword">long</span> a;</div><div class="line"><span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试空隙插入&lt;br&gt;</span></div><div class="line"><span class="comment"> * 对象头(8)+Oops(4)+b(4)+a(8)&lt;br&gt;</span></div><div class="line"><span class="comment"> * 在前面的理论中，我们说过基本变量类型在内存中的存放顺序是从大到小的&lt;br&gt;</span></div><div class="line"><span class="comment"> * （顺序：longs/doubles、ints、shorts/chars、bytes/booleans）。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 所以，按理来说，属性int b应该被分配到了属性long a的后面。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 但是，从属性位置偏移量的结果来看，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 我们却发现属性int b被分配到了属性long a的前面，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 这是为什么？&lt;br&gt;</span></div><div class="line"><span class="comment"> * 是这样的，因为JVM启用了'CompactFields'选项，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 该选项运行分配的非静态（non-static）字段被插入到前面字段的空隙中，以提供内存的利用率。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 从前面的实例中，我们已经知道，对象头占用了12个字节，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 并且再次之后分配的long类型字段不会紧跟在对象头后面分配，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 而是再新一个8字节偏移量位置处开始分配，因此对象头和属性long a直接存在了4字节的空隙，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 而这个4字节空隙的大小符合（即，大小足以用于）属性int b的内存分配。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 所以，属性int b就被插入到了对象头与属性long a之间了。&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompactFields</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试空隙插入****"</span>);</div><div class="line">ObjectC obj = <span class="keyword">new</span> ObjectC();</div><div class="line"><span class="comment">// memoryUsage : 24</span></div><div class="line">System.out.println(<span class="string">"ObjectC, memoryUsage : "</span> + MemoryUtil.memoryUsageOf(obj));</div><div class="line"><span class="comment">// a field offset : 16</span></div><div class="line">System.out.println(<span class="string">"ObjectC, long a offset : "</span> + UNSAFE.objectFieldOffset(ObjectC.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line"><span class="comment">// b field offset : 12</span></div><div class="line">System.out.println(<span class="string">"ObjectC, int b offset : "</span> + UNSAFE.objectFieldOffset(ObjectC.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectD</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> a;</div><div class="line"><span class="keyword">long</span> b;</div><div class="line">String str;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试基本类型分配后再分配引用类型&lt;br&gt;</span></div><div class="line"><span class="comment"> * 对象头(8)+Oops(4)+a(4)+b(8)+str(4)+padding(4)=32&lt;br&gt;</span></div><div class="line"><span class="comment"> * 从属性 int a、long b，以及对象引用 str 的偏移量可以发现，对象引用是在基本变量分配完后才进行的分配的。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 这是通过JVM选项'FieldsAllocationStyle=1'决定的，FieldsAllocationStyle的值为1，&lt;br&gt;</span></div><div class="line"><span class="comment"> * 说明：先放入基本变量类型&lt;br&gt;</span></div><div class="line"><span class="comment"> * (顺序：longs/doubles、ints、shorts/chars、bytes/booleans），&lt;br&gt;</span></div><div class="line"><span class="comment"> * 然后放入oops（普通对象引用指针）&lt;br&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> NoSuchFieldException</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReferenceAllocate</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试基本类型分配后再分配引用类型****"</span>);</div><div class="line">ObjectD obj = <span class="keyword">new</span> ObjectD();</div><div class="line"><span class="comment">// memoryUsage : 24</span></div><div class="line">System.out.println(<span class="string">"ObjectD, memoryUsage : "</span> + MemoryUtil.memoryUsageOf(obj));</div><div class="line"></div><div class="line"><span class="comment">// a field offset : 12</span></div><div class="line">System.out.println(<span class="string">"ObjectD, int a offset : "</span> + UNSAFE.objectFieldOffset(ObjectD.class.getDeclaredField(<span class="string">"a"</span>)));</div><div class="line"></div><div class="line"><span class="comment">// str field offset : 16</span></div><div class="line">System.out.println(<span class="string">"ObjectD, long b offset : "</span> + UNSAFE.objectFieldOffset(ObjectD.class.getDeclaredField(<span class="string">"b"</span>)));</div><div class="line"></div><div class="line"><span class="comment">// str field offset : 24</span></div><div class="line">System.out.println(<span class="string">"ObjectD, String str offset : "</span> + UNSAFE.objectFieldOffset(ObjectD.class.getDeclaredField(<span class="string">"str"</span>)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TheInnerObject</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> innerA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * memoryUsageOf方法仅计算了对象本身的大小，并未包含引用对象的内存大小&lt;br&gt;</span></div><div class="line"><span class="comment"> * （注意，memoryUsageOf方法计算的是引用指针的对象，而非引用对象占用的内存大小）。&lt;br&gt;</span></div><div class="line"><span class="comment"> * deepMemoryUsageOf方法则会将引用对象占用的内存大小也计算进来。&lt;br&gt;</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 注意，deepMemoryUsageOf(Object obj)默认只会包含non-public的引用对象的大小。&lt;br&gt;</span></div><div class="line"><span class="comment"> * 如果你想将public引用对象的大小也计算在内，可通过deepMemoryUsageOf重载方法&lt;br&gt;</span></div><div class="line"><span class="comment"> * deepMemoryUsageOf(Object obj, VisibilityFilter referenceFilter)，&lt;br&gt;</span></div><div class="line"><span class="comment"> * VisibilityFilter参数传入 'VisibilityFilter.ALL'来实现。&lt;br&gt;</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> */</span></div><div class="line">TheInnerObject innerObject = <span class="keyword">new</span> TheInnerObject();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDeepMemoryUsage</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试对象总大小，包含引用对象占用的内存****"</span>);</div><div class="line">TheObjectMemory obj = <span class="keyword">new</span> TheObjectMemory();</div><div class="line"></div><div class="line"><span class="comment">// TheObjectMemory memoryUsage : 16</span></div><div class="line">System.out.println(<span class="string">"TheObjectMemory memoryUsage : "</span> + MemoryUtil.memoryUsageOf(obj));</div><div class="line"></div><div class="line"><span class="comment">// TheInnerObject memoryUsage : 16</span></div><div class="line">TheInnerObject innerObj = <span class="keyword">new</span> TheInnerObject();</div><div class="line">System.out.println(<span class="string">"TheInnerObject memoryUsage : "</span> + MemoryUtil.memoryUsageOf(innerObj));</div><div class="line"></div><div class="line"><span class="comment">// TheObjectMemory deepMemoryUsageOf : 32</span></div><div class="line">System.out.println(<span class="string">"TheObjectMemory deepMemoryUsageOf : "</span> + MemoryUtil.deepMemoryUsageOf(obj));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> a;</div><div class="line">String str = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 测试数组对象占用内存大小</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * PS:运行此方法需注释掉 225行的内容：TheInnerObject innerObject = new TheInnerObject();</span></div><div class="line"><span class="comment"> * 否则内存大小会包含上面实例所占用的内存(16) 对象头(8)+Oops(4)+innerA(4)=16</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 数组对象自身占用的内存大小 = 对象头 + 数组长度 * 元素引用指针/基本数据类型大小 + 对齐填充</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ● 对象头：mark word(8 bytes) + class pointer(4 bytes) + length(4 bytes) = 16</span></div><div class="line"><span class="comment"> * bytes 因为在JDK 8 中"UseCompressedOops"选项是默认启用的，因此class pointer只占用了4个字节。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ● 实例数据：数组长度(1) * 对象引用指针(4 bytes) = 4 bytes</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ● 对齐填充：4 bytes</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 对象占用内存大小：对象头(16) + 实例数据(4) + 对齐填充(4) = 24</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * deepMemoryUsageOf = array memoryUsage + array_length（数组长度） *</span></div><div class="line"><span class="comment"> * item_deepMemoryUsage (元素占用 的全部内存)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 注意，这里的数组是一个对象数组，因此memoryUsage中计算的是对象引用指针的大小。如果是一个基本数据类型的数组，如，</span></div><div class="line"><span class="comment"> * int[]，则，memoryUsage计算的就是基本数据类型的大小了。也就是说，如果是基本数据类型的数组的话，memoryUsage</span></div><div class="line"><span class="comment"> * 的值是等于deepMemoryUsageOf的值的。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testObjectArrayMemoryUsage</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"****测试数组对象占用内存大小***"</span>);</div><div class="line">TheObjectMemory[] objArray = <span class="keyword">new</span> TheObjectMemory[<span class="number">1</span>];</div><div class="line">TheObjectMemory obj = <span class="keyword">new</span> TheObjectMemory();</div><div class="line">objArray[<span class="number">0</span>] = obj;</div><div class="line"></div><div class="line"><span class="comment">// memoryUsage : 24</span></div><div class="line">System.out.println(<span class="string">"objArray memoryUsage : "</span> + MemoryUtil.memoryUsageOf(objArray));</div><div class="line"></div><div class="line"><span class="comment">// deepMemoryUsageOf : 104</span></div><div class="line">System.out.println(<span class="string">"objArray deepMemoryUsageOf : "</span> + MemoryUtil.deepMemoryUsageOf(objArray));</div><div class="line"></div><div class="line"><span class="comment">// obj memoryUsage : 24</span></div><div class="line">System.out.println(<span class="string">"obj memoryUsage : "</span> + MemoryUtil.memoryUsageOf(obj));</div><div class="line"><span class="comment">// obj deepMemoryUsageOf : 80</span></div><div class="line">System.out.println(<span class="string">"obj deepMemoryUsageOf : "</span> + MemoryUtil.deepMemoryUsageOf(obj));</div><div class="line"></div><div class="line"><span class="comment">// first item offset（数组第一个元素的内存地址偏移量） : 16</span></div><div class="line">System.out.println(<span class="string">"first item offset : "</span> + UNSAFE.arrayBaseOffset(objArray.getClass()));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/12a3c97dc2b7" target="_blank" rel="external">JVM中 对象的内存布局 以及 实例分析</a></p><p><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">《深入理解Java虚拟机》</a></p><p><a href="https://www.javamex.com/classmexer/" target="_blank" rel="external">Classmexer agent</a></p><p><a href="https://github.com/shipilev/java-object-layout" target="_blank" rel="external">R大(RednaxelaFX)同事写的显示Java对象布局的工具</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp攻略-非洲</title>
      <link href="/walkup/Africa.html"/>
      <url>/walkup/Africa.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>非洲篇</strong>签证攻略。</p></blockquote><a id="more"></a><h4 id="阿尔及利亚"><a href="#阿尔及利亚" class="headerlink" title="阿尔及利亚"></a>阿尔及利亚</h4><p>阿尔及利亚的舞蹈按什么划分—<strong>地区</strong><br>阿尔及利亚是葡萄酒主要生产国吗—<strong>不是</strong><br>阿尔及利亚什么时候开始伊斯兰化—<strong>8世纪</strong><br>阿尔及利亚国名来自于—<strong>首都名</strong><br>柏柏人曾经建立起王国吗—<strong>有</strong></p><h4 id="突尼斯"><a href="#突尼斯" class="headerlink" title="突尼斯"></a>突尼斯</h4><p>突尼斯人姓名一般有几部分组成—<strong>四部分</strong><br>茉莉花革命在什么时候爆发—<strong>2011年</strong><br>突尼斯得国旗历史可追溯到什么时期—<strong>奥斯曼帝国</strong><br>突尼斯南部主要以什么地形为主—<strong>沙漠</strong><br>突尼斯拥有世界上最大的油橄榄吗—<strong>有</strong></p><h4 id="利比亚"><a href="#利比亚" class="headerlink" title="利比亚"></a>利比亚</h4><p>卡扎菲政权在哪场战争被推翻—<strong>利比亚内战</strong><br>利比亚蹭属于迦太基吗—<strong>属于</strong><br>利比亚茶内含有什么—<strong>薄荷叶</strong><br>利比亚国旗中红色代表什么地区—<strong>费赞地区</strong><br>井泉是利比亚的主要水源吗—<strong>是</strong></p><h4 id="埃及"><a href="#埃及" class="headerlink" title="埃及"></a>埃及</h4><p>拿破仑曾经占领过埃及吗—<strong>有</strong><br>如今的阿拉伯人是古埃及人吗—<strong>不是</strong><br>埃及的”国菜”是什么—<strong>蚕豆</strong><br>非洲最大的人工湖名叫—<strong>纳赛尔水库</strong><br>大金字塔归属于哪位国王—<strong>胡夫</strong></p><h4 id="埃塞尔比亚"><a href="#埃塞尔比亚" class="headerlink" title="埃塞尔比亚"></a>埃塞尔比亚</h4><p>绿黄红三色也被称为—<strong>泛非洲色彩</strong></p><p>埃塞尔比亚境内以什么地形为主—<strong>高原</strong></p><p>青尼罗河发源于埃塞尔比亚吗—<strong>是</strong></p><p>东非大裂谷有跨越埃塞尔比亚吗—<strong>有</strong></p><p>埃塞尔比亚有受到殖民主义影响吗—<strong>没有</strong></p><h4 id="刚果共和国"><a href="#刚果共和国" class="headerlink" title="刚果共和国"></a>刚果共和国</h4><p>布拉柴维尔被称作什么—<strong>花园城</strong></p><p>刚果人经常使用什么酱料—<strong>蚁酱</strong></p><p>北方原始森林有俾格米人生活吗—<strong>有</strong></p><p>大洋铁路是非洲第一条铁路吗—<strong>是</strong></p><p>布拉柴维尔曾是哪个国家的“象征首都”—<strong>自由法国</strong></p><h4 id="肯尼亚"><a href="#肯尼亚" class="headerlink" title="肯尼亚"></a>肯尼亚</h4><p>肯尼亚的“国花”是什么—<strong>肯山兰</strong></p><p>肯尼亚的国家代码是—<strong>肯</strong></p><p>肯尼亚是人类发源地之一吗—<strong>是</strong></p><p>肯尼亚地跨赤道吗—<strong>有</strong></p><p>肯尼亚咖啡豆更适合做哪种咖啡—<strong>冰咖啡</strong></p><h4 id="坦桑尼亚"><a href="#坦桑尼亚" class="headerlink" title="坦桑尼亚"></a>坦桑尼亚</h4><p>坦桑尼亚国旗由几种颜色构成—<strong>4种</strong></p><p>坦桑尼亚的首都是—<strong>多多马</strong></p><p>乞力马扎罗山是世界最高独体山吗—<strong>是</strong></p><p>坦桑尼亚是英联邦国家吗—<strong>是</strong></p><p>坦桑尼亚的马赛人用设么方式迎宾—<strong>踩高跷</strong></p><h4 id="津巴布韦"><a href="#津巴布韦" class="headerlink" title="津巴布韦"></a>津巴布韦</h4><p>津巴布韦有怎样的称号—<strong>鳄鱼之乡</strong></p><p>绍纳人曾在津巴布韦建立过文明吗—<strong>有</strong></p><p>津巴布韦原本称作什么—<strong>南罗得西亚</strong></p><p>津巴布韦是内陆国家吗—<strong>是</strong></p><p>津巴布韦部族依然保留图腾吗—<strong>保留</strong></p><h4 id="纳米比亚"><a href="#纳米比亚" class="headerlink" title="纳米比亚"></a>纳米比亚</h4><p>鲸鱼港曾是哪个国家的飞地—<strong>南非</strong></p><p>奥万博族是纳米比亚最大的民族吗—<strong>是</strong></p><p>纳米比亚曾经被称为什么—<strong>西南非洲</strong></p><p>纳米比亚的国徽有几种动物—<strong>2种</strong></p><p>纳米比亚的第一大城市是什么—<strong>温得和克</strong></p><h4 id="南非"><a href="#南非" class="headerlink" title="南非"></a>南非</h4><p>什么肉是南非的特色风味—<strong>鸵鸟肉</strong></p><p>好望角位于南非的哪个方位—<strong>西南端</strong></p><p>南非的国石是什么—<strong>钻石</strong></p><p>南非有几个首都—<strong>3个</strong></p><p>地下水是南非供水的主要资源吗—<strong>是</strong></p><h4 id="马达加斯加"><a href="#马达加斯加" class="headerlink" title="马达加斯加"></a>马达加斯加</h4><p>马达加斯加是世界第几大岛屿—<strong>第四</strong></p><p>马达加斯加的别称是什么—<strong>牛的王国</strong></p><p>马达加斯加有行割礼的传统吗—<strong>有</strong></p><p>香草是马达加斯加主要出口物吗—<strong>是</strong></p><p>马达加斯加什么时候出现国家组织—<strong>14世纪</strong></p>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM中对象的创建</title>
      <link href="/JVM/create.html"/>
      <url>/JVM/create.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>阅读内容前提为</p><ul><li>虚拟机：HotSpot</li><li>内存区域：Java堆</li><li>内容： 对象分配、布局和访问的全过程</li><li>JDK版本：1.7</li></ul></blockquote><a id="more"></a><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><blockquote><p>创建对象(例如克隆、反序列化)通常仅仅是一个<code>new</code>关键字而已。对应在JVM中，对象(普通Java对象，不包含数组和Class对象等)的创建是怎样的？</p></blockquote><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><ul><li>参数是否能在<strong>常量池中定位到</strong>一个类的符号引用</li><li>这个符号引用代表的类<strong>是否已经被加载、解析和初始化过</strong><ul><li>无：执行相应的类加载过程</li></ul></li></ul><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><ul><li>对象所需内存的大小在类加载后便可完全确定</li><li>为新生对象分配空间：从Java堆中划分出确定大小的内存</li></ul><h5 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h5><ul><li>指针碰撞Bump the Pointer</li></ul><blockquote><p><strong>Java堆中内存是绝对规整的</strong>，用过的内存在一边，空间内存在另外一边，中间用指针作为分界点的指示器，分配内存就是仅仅把指针向空闲内存挪动一段与对象大小相等的距离。</p></blockquote><ul><li>空闲列表Free List</li></ul><blockquote><p><strong>Java堆中内存是不规整的</strong>，已使用的内存和空闲内存相互交错，虚拟机需维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p><p>分配方式的选择：垃圾收集器是否带有压缩整理功能（决定Java堆是否规整）</p><ul><li>Serial、ParNew等带Compact过程的收集器<ul><li>指针碰撞</li></ul></li><li>基于Mark-Sweep算法的CMS收集器<ul><li>空闲列表</li></ul></li></ul></blockquote><h5 id="并发情况下对象创建非线程安全的问题"><a href="#并发情况下对象创建非线程安全的问题" class="headerlink" title="并发情况下对象创建非线程安全的问题"></a>并发情况下对象创建非线程安全的问题</h5><blockquote><p>对象创建行为非常频繁，并发情况下可能出现：正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。</p></blockquote><ul><li>对分配内存的动作进行同步处理<ul><li>虚拟机采用<strong>CAS+失败重试</strong>方法保证更新操作的原子性</li></ul></li><li>把内存分配的动作按照线程划分在不同的空间之中进行<ul><li>每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Loca Allocation Buffer,TLAB)</li><li>哪个线程需要分配内存就在对应的TLAB中进行</li><li>只有在TLAB用完并重新分配新的TLAB时，才需要同步锁定</li><li>虚拟机是否使用TLAB<ul><li><code>-XX:+/-UseTLAB</code>参数设置</li></ul></li></ul></li></ul><h4 id="内存空间初始化为零值-不包括对象头"><a href="#内存空间初始化为零值-不包括对象头" class="headerlink" title="内存空间初始化为零值(不包括对象头)"></a>内存空间初始化为零值(不包括对象头)</h4><ul><li>如果使用TLAB，可以提前至TLAB分配时进行此操作</li><li>保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，访问到的字段的数据类型都是零值</li></ul><h4 id="对对象的对象头Object-Header进行设置"><a href="#对对象的对象头Object-Header进行设置" class="headerlink" title="对对象的对象头Object Header进行设置"></a>对对象的对象头Object Header进行设置</h4><ul><li>设置方式由<strong>虚拟机当前的运行状态</strong>决定<ul><li>是否启用偏向所等</li></ul></li></ul><ul><li>对象头包含内容<ul><li>这个对象时哪个类的实例</li><li>如何才能找到类的元数据信息、哈希码、GC分代年龄等</li></ul></li></ul><h4 id="可选：执行方法"><a href="#可选：执行方法" class="headerlink" title="可选：执行方法"></a>可选：执行<init>方法</init></h4><blockquote><p>至此，</p><ul><li>从虚拟机的角度看<ul><li>新对象已经产生了</li></ul></li><li>从Java程序的角度看<ul><li>对象创建才刚刚开始<ul><li><init>方法还没有执行</init></li><li>所有的字段都还为零</li></ul></li></ul></li></ul></blockquote><p>由字节码中是否跟随invokespecial指令所决定是否执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fpii0m9fgxj20g50ov75j.jpg" alt="Markdown"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp攻略-南极洲</title>
      <link href="/walkup/Antarctica.html"/>
      <url>/walkup/Antarctica.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>南极洲篇</strong>签证攻略。</p></blockquote><a id="more"></a><h4 id="南极洲"><a href="#南极洲" class="headerlink" title="南极洲"></a>南极洲</h4><p>第一个到达南极点的是哪国人—挪威人</p><p>南极有北极熊吗 — 没有</p><p>南极大陆是世界上唯一没有狗的地区吗 — 是</p><p>南极的总面积位居世界大洲第几位 — 第五位</p><p>南极是地球上最后一个被发现的大陆吗 — 是</p><blockquote><p>嗯，是的，南极洲就这么一个。。。over</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp攻略-欧洲</title>
      <link href="/walkup/Europe.html"/>
      <url>/walkup/Europe.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>欧洲篇</strong>签证攻略。</p></blockquote><a id="more"></a><h4 id="希腊"><a href="#希腊" class="headerlink" title="希腊"></a>希腊</h4><p>传说普罗米修斯属于哪个神族后裔—泰坦神族后裔</p><p>希腊诸神中宙斯是怎么当上诸神之王的—抓阄抓的</p><p>希腊除了古文明，还有哪件事是欧洲文明的始祖—葡萄酒酿制</p><p>传说中火神用粘土制造了第一个女人手里拿的是什么—潘多拉魔盒</p><p>古希腊文化中著名的数学家、物理学家是哪一位—阿基米德</p><h4 id="阿尔巴尼亚"><a href="#阿尔巴尼亚" class="headerlink" title="阿尔巴尼亚"></a>阿尔巴尼亚</h4><p>阿尔巴尼亚是信仰什么宗教的国家—伊斯兰教</p><p>在阿尔巴尼亚表示肯定、赞同用什么肢体语言—摇头</p><p>阿尔巴尼亚是发达国家还是不发达国家—不发达</p><p>阿尔巴尼亚的首都是地拉那吗—是</p><p>阿尔巴尼亚的解放日是哪一天—11月29日</p><h4 id="波黑"><a href="#波黑" class="headerlink" title="波黑"></a>波黑</h4><p>萨拉热窝暗杀的是哪国王储—奥匈帝国王储</p><p>全世界第一个全天运行路面电车的国家是—旧金山</p><p>萨拉热窝地区人们常年饮食是凉的，是真是假—真的</p><p>第一次世界大战的导火索是什么事件—萨拉热窝事件</p><p>萨拉热窝被誉为欧洲的—耶路撒冷</p><h4 id="塞尔维亚"><a href="#塞尔维亚" class="headerlink" title="塞尔维亚"></a>塞尔维亚</h4><p>塞尔维亚曾是哪个解体国家的主体—南斯拉夫</p><p>贝尔格莱德建成史上多少次被军队占领—40次</p><p>萨尔维亚最热衷的体育运动是什么—足球</p><p>萨尔维亚信仰哪个宗教—东正教</p><p>萨尔维亚北部是什么地形—平原</p><h4 id="保加利亚"><a href="#保加利亚" class="headerlink" title="保加利亚"></a>保加利亚</h4><p>保加利亚的建筑风格属于—拜占庭式建筑</p><p>保加利亚国徽上的饰带上的文字是—团结就是力量</p><p>保加利亚属于欧盟吗—属于</p><p>索菲亚这座城市因什么而命名—教堂</p><p>当选过保加利亚总理的末代国王是—西蒙二世</p><h4 id="罗马尼亚"><a href="#罗马尼亚" class="headerlink" title="罗马尼亚"></a>罗马尼亚</h4><p>罗马尼亚的和乍得的国旗完全相同吗—-相同</p><p>罗马尼亚是否加入了北约军事组织—-是</p><p>罗马尼亚的独裁者齐奥塞斯库哪年被推翻—-1989</p><p>哪位天王巨星曾在罗马尼亚举办轰动一时的演唱会—-迈克尔杰克逊</p><p>罗马尼亚的祖先—-达契亚人</p><h4 id="摩尔多瓦"><a href="#摩尔多瓦" class="headerlink" title="摩尔多瓦"></a>摩尔多瓦</h4><p>摩尔多瓦最常见的自然灾害是—涝灾</p><p>最后一个占领基希纳乌的政体是—苏联</p><p>没独立前的基希纳乌叫什么—基什尼奥夫</p><p>摩尔多瓦人常用什么酒招待客人—葡萄酒</p><p>摩尔多瓦人认为数字几代表成功幸福—7</p><h4 id="乌克兰"><a href="#乌克兰" class="headerlink" title="乌克兰"></a>乌克兰</h4><p>乌克兰的额定电压是多少伏—230V</p><p>欧洲粮仓乌克兰是世界第几大粮食出口国—第三</p><p>乌克兰与俄罗斯接壤吗—接壤</p><p>乌克兰的主要宗教除了东正教还有—天主教</p><p>乌克兰的独立日是哪一天—8月24日</p><h4 id="波兰"><a href="#波兰" class="headerlink" title="波兰"></a>波兰</h4><p>波兰火车中慢车使用什么颜色表示的—黑色</p><p>波兰人爱喝烈酒对吗—对的</p><p>国徽上的白鹰象征着什么—爱国精神</p><p>波兰初建于几世纪中叶—十三世纪</p><p>1025年谁加冕为波兰国王—博莱斯瓦夫一世</p><h4 id="立陶宛"><a href="#立陶宛" class="headerlink" title="立陶宛"></a>立陶宛</h4><p>立陶宛加入欧元区恰逢欧元诞生多少周年—15周年</p><p>立陶宛的“国树”是什么—桦树</p><p>被称作“立陶宛黄金”的稀有物产是—琥珀</p><p>立陶宛属于欧元区吗—属于</p><p>立陶宛于哪一年宣布独立—1918</p><h4 id="白俄罗斯"><a href="#白俄罗斯" class="headerlink" title="白俄罗斯"></a>白俄罗斯</h4><p>苏联什么时候解体的—1991.12.25</p><p>苏联解体是在哪里宣布的—白俄罗斯</p><p>明斯克在白俄语言里的意思是—交易之城</p><p>白俄罗斯的“国家战略资源”是什么—白俄罗斯美女</p><p>明斯克人称马铃薯为—第二面包</p><h4 id="俄罗斯"><a href="#俄罗斯" class="headerlink" title="俄罗斯"></a>俄罗斯</h4><p>俄罗斯饮品“格瓦斯”的主要原料是—面包</p><p>俄罗斯国土面积是世界第几—第一</p><p>在俄罗斯，表达尊敬要送什么花—菊花</p><p>克里姆林宫坐落在俄罗斯哪做城市—莫斯科</p><p>俄罗斯总统普京是柔道八段运动员吗—是</p><h4 id="拉脱维亚"><a href="#拉脱维亚" class="headerlink" title="拉脱维亚"></a>拉脱维亚</h4><p>拉脱维亚语属于哪个语系—印欧语系</p><p>拉脱维亚属于欧元区吗—属于</p><p>“北方的巴黎”是拉脱维亚哪个城市的别名—里加</p><p>拉脱维亚是申根公约成员国吗—是</p><p>拉脱维亚男性与女性比例大约是—46比54</p><h4 id="芬兰"><a href="#芬兰" class="headerlink" title="芬兰"></a>芬兰</h4><p>下面哪个风靡世界卡通人物原产于芬兰—姆米</p><p>芬兰的国土面积排欧洲第几—第七</p><p>芬兰的国粹是什么呢—桑拿</p><p>赫尔辛基市除了哪里之外，世界上纬度最高的首都—雷克雅未克</p><p>由于芬兰的自然特色，芬兰被冠以什么之名—千湖之国</p><h4 id="瑞典"><a href="#瑞典" class="headerlink" title="瑞典"></a>瑞典</h4><p>瑞典的“国石“是什么—水晶</p><p>瑞典参加第二次世界大战了吗—没有参加</p><p>“瑞典“一次在瑞典语中什么意思—安宁的王国</p><p>瑞典可以将酒作为礼物吗—不可以</p><p>每年8月，瑞典有什么特殊的节日—吃虾节</p><h4 id="挪威"><a href="#挪威" class="headerlink" title="挪威"></a>挪威</h4><p>在挪威，最受欢迎的酒是什么—啤酒</p><p>挪威和瑞典曾经是一个国家吗—是</p><p>第一个到达南极的是挪威人吗—是</p><p>挪威的通行婚姻合法吗—合法</p><p>奥斯陆这座城市有多少年历史—近1000年</p><h4 id="丹麦"><a href="#丹麦" class="headerlink" title="丹麦"></a>丹麦</h4><p>丹麦出租车可以使用信用卡吗—可以</p><p>小美人鱼像有进行搬迁过吗—有</p><p>菲登斯堡宫被成为什么宫—和平宫</p><p>格陵兰岛属于丹麦吗—属于</p><p>丹麦国旗中的白条是等比例的吗—不是</p><h4 id="德国"><a href="#德国" class="headerlink" title="德国"></a>德国</h4><p>德国举办国几次奥运会—2次</p><p>两德什么时候统一—1990</p><p>老鹰是德国的国鸟吗—不是</p><p>哪条河发源于德国境内—多瑙河</p><p>慕尼黑啤酒节又称什么节—十月节</p><h4 id="捷克"><a href="#捷克" class="headerlink" title="捷克"></a>捷克</h4><p>哪位作家不是捷克人—卡夫卡</p><p>捷克的母亲河是什么—伏尔塔瓦河</p><p>布拉格在德语中是什么意思—门槛</p><p>捷克是哪个时区—东一区</p><p>捷克有几个国徽—2个</p><h4 id="奥地利"><a href="#奥地利" class="headerlink" title="奥地利"></a>奥地利</h4><p>以下哪位音乐家是奥地利人—海顿</p><p>奥地利的官方语言是什么—德语</p><p>维也纳是联合国官方驻地吗—是</p><p>“间谍之都“指的是—维也纳</p><p>“奥地利“这个国家名称出现在什么时候—996</p><h4 id="匈牙利"><a href="#匈牙利" class="headerlink" title="匈牙利"></a>匈牙利</h4><p>布达佩斯曾经是两座城市吗—是</p><p>在布达佩斯哪种出行方式更流行—有轨电车</p><p>匈牙利国旗中的绿色代表什么—繁荣昌盛</p><p>“匈牙利“一词含义是什么—十个部落</p><p>匈牙利王国什么时候建立—公元1000年</p><h4 id="意大利"><a href="#意大利" class="headerlink" title="意大利"></a>意大利</h4><p>意大利是“文艺复兴”的发源地吗—是</p><p>意大利第一次夺得世界杯是什么时候—1934年</p><p>米兰大教堂完工了吗—完工</p><p>在意大利家庭中谁最受尊重—外祖母</p><p>意大利国旗是由谁设计的—拿破仑</p><h4 id="瑞士"><a href="#瑞士" class="headerlink" title="瑞士"></a>瑞士</h4><p>瑞士是唯一一个正方形国旗的国家吗—不是</p><p>瑞士最大的城市是什么—苏黎世</p><p>陀飞轮技术是哪位瑞士钟表大师发明的—宝玑先生</p><p>瑞士是否参加过一战—否</p><p>瑞士的雇佣兵出口业务是什么时候开始—15世纪</p><h4 id="比利时"><a href="#比利时" class="headerlink" title="比利时"></a>比利时</h4><p>比利时政府最多有多少天未能组阁—500天</p><p>比利时法律意义上的首都是哪个—布鲁塞尔市</p><p>奥黛丽.赫本是比利时人吗—是</p><p>比利时是第几个通行婚姻合法化国家—第2个</p><p>比利时曾属于罗马共和国吗—属于</p><h4 id="荷兰"><a href="#荷兰" class="headerlink" title="荷兰"></a>荷兰</h4><p>荷兰的领土分为几个区—2个区</p><p>荷兰是世界最早拥有议会选举的国家吗—不是</p><p>荷兰确立海上霸主地位是什么时候—17世纪</p><p>荷兰的字母表有几个字母—27个</p><p>荷兰“女王日”是哪一天—4月的最后一天</p><h4 id="英国"><a href="#英国" class="headerlink" title="英国"></a>英国</h4><p>英国是欧元区国家吗—不是</p><p>英国由几个构成国组成—4个</p><p>塞文河是英国境内最长的河吗—是</p><p>英国举办国几届夏季运动会—3届</p><p>曼彻斯特是英国第一大城市吗—不是</p><h4 id="冰岛"><a href="#冰岛" class="headerlink" title="冰岛"></a>冰岛</h4><p>最早定居冰岛的是什么人—维京人</p><p>冰岛是欧洲人口密度最小的国家吗—是</p><p>冰岛有铁路设施吗—没有</p><p>冰岛是世界上温泉最多的国家吗—是</p><p>冰岛有几大守护神—4</p><h4 id="爱尔兰"><a href="#爱尔兰" class="headerlink" title="爱尔兰"></a>爱尔兰</h4><p>爱尔兰的国庆节也称为—圣帕特里克节</p><p>爱尔兰的国徽是哪种乐器—竖琴</p><p>爱尔兰是永久中立国吗—是</p><p>爱尔兰的有什么别名—翡翠绿岛</p><p>爱尔兰男人的传统服饰是—裙子</p><h4 id="法国"><a href="#法国" class="headerlink" title="法国"></a>法国</h4><p>《马赛曲》创作于什么时候—1792年</p><p>法国是西欧面积最大的国家吗—是</p><p>戛纳国际电影节最高奖称为—金棕榈奖</p><p>法国最大的岛屿叫什么—科西嘉岛</p><p>法国的国鸟是什么—云雀</p><h4 id="摩纳哥"><a href="#摩纳哥" class="headerlink" title="摩纳哥"></a>摩纳哥</h4><p>摩纳哥公民能免费进入赌场吗—不能</p><p>摩纳哥国内水域率是多少—0%</p><p>摩纳哥官方语言是—法语</p><p>摩纳哥的地名起源于哪个地发—希腊</p><p>摩纳哥的主要经济来源—博彩业</p><h4 id="西班牙"><a href="#西班牙" class="headerlink" title="西班牙"></a>西班牙</h4><p>西班牙斗牛士为什么使用红布斗牛—吸引观众注意</p><p>西班牙国家足球队问鼎过几次欧洲杯冠军—3次</p><p>西班牙国土面积占伊比利亚半岛多少—五分之四</p><p>西班牙在非洲有领土吗—有</p><p>西班牙语也称为什么语—卡斯蒂利亚语</p><h4 id="葡萄牙"><a href="#葡萄牙" class="headerlink" title="葡萄牙"></a>葡萄牙</h4><p>葡萄牙的国花是什么—薰衣草</p><p>麦哲伦是葡萄牙人吗—是</p><p>葡萄牙是世界上第几大橄榄油生产国—第四</p><p>葡萄牙国徽图案是什么—浑天仪</p><p>葡萄牙的传统民谣被称为什么—法朵</p>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WalkUp攻略-亚洲</title>
      <link href="/walkup/Asia.html"/>
      <url>/walkup/Asia.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下为<strong>亚洲篇</strong>签证攻略。<br>越南前面的国家没有记录，抱歉。</p></blockquote><a id="more"></a><h3 id="越南"><a href="#越南" class="headerlink" title="越南"></a>越南</h3><p>越南的古时称谓—安南</p><p>越南曾是哪个国家的殖民地—法国</p><p>越南人喜欢戴绿色帽子吗—是</p><p>越南是多民族国家吗—是</p><p>越南三宝之一—香水</p><h3 id="柬埔寨"><a href="#柬埔寨" class="headerlink" title="柬埔寨"></a>柬埔寨</h3><p>柬埔寨的名胜景点中最著名的是哪个—吴哥窟</p><p>哪位担任过柬埔寨国王—西哈莫尼</p><p>柬埔寨有王室吗—有</p><p>柬埔寨是多民族国家,主要民族是哪个民族—高棉族</p><p>柬埔寨在公元几世纪建立了统一的王国—公元1世纪</p><h3 id="泰国"><a href="#泰国" class="headerlink" title="泰国"></a>泰国</h3><p>大多数泰国人信封什么佛—四面佛</p><p>泰国民间会不会重男轻女—不会</p><p>泰国古时叫什么—暹罗国</p><p>人妖平均寿命不超过多少岁—40岁</p><p>泰国常年温度不低于多少度—18</p><h3 id="缅甸"><a href="#缅甸" class="headerlink" title="缅甸"></a>缅甸</h3><p>缅甸最大的城市在哪里—仰光</p><p>缅甸曾是哪个国家的殖民地—英国</p><p>缅甸人机会不能在几月份结婚—12月</p><p>在缅甸会机会抚摸孩子的头吗—会</p><p>缅甸男士常穿的民族服饰是什么—笼基</p><h3 id="尼泊尔"><a href="#尼泊尔" class="headerlink" title="尼泊尔"></a>尼泊尔</h3><p>在尼泊尔购买满百年的股东是否能带回国—不能</p><p>尼泊尔是三大宗教中哪个宗教的发源地—佛教</p><p>尼泊尔是什么类型的国家—农业国</p><p>尼瓦尔族的女人在7至9岁时要与一种见过结婚,这种婚姻叫什么—果实婚</p><p>尼泊尔有空军吗—没有</p><h3 id="印度"><a href="#印度" class="headerlink" title="印度"></a>印度</h3><p>第一个帝国式政权时哪个印度王朝建立的?—孔雀王朝</p><p>最后一个殖民印度的国家时哪个国家?—英国</p><p>印度的圣河叫什么—恒河</p><p>印度钟姓制度中代表僧侣贵族的姓氏是什么—婆罗门</p><p>印度是世界人口第几大国—第二大国</p><h3 id="巴基斯坦"><a href="#巴基斯坦" class="headerlink" title="巴基斯坦"></a>巴基斯坦</h3><p>巴基斯坦人口最多的民族是—旁遮普人</p><p>巴基斯坦第一大城市—卡拉奇</p><p>出于礼貌,在巴基斯坦吃饭一定要使用右手吗—是</p><p>巴基斯坦是一夫多妻制国家吗—是</p><p>伊斯兰堡是哪一年正式迁都成为新首都的—1967年迁都</p><h3 id="阿富汗"><a href="#阿富汗" class="headerlink" title="阿富汗"></a>阿富汗</h3><p>基地组织和塔利班早期成立的目的是什么—反抗前苏联入侵</p><p>对塔利班组织的另一个称呼是什么—伊斯兰学生军</p><p>美国对阿富汗的复仇战争是哪年开始的—2002年</p><p>前苏联曾对阿富汗发动过侵略战争吗—发动过</p><p>911事件是阿富汗哪个武装组织发动的—基地组织</p><h3 id="伊朗"><a href="#伊朗" class="headerlink" title="伊朗"></a>伊朗</h3><p>伊朗是政教合一的国家吗—是</p><p>伊朗的周末在哪天—周五</p><p>伊朗国旗上一共写着几句真主伟大—22</p><p>伊朗的前身曾是哪个古文明帝国—古波斯帝国</p><p>成吉思汗之孙在伊朗建立的王国叫什么—伊利汗国</p><h3 id="阿联酋"><a href="#阿联酋" class="headerlink" title="阿联酋"></a>阿联酋</h3><p>迪拜的政府机构几点下班—下午2点</p><p>迪拜市内公交车里可以吃东西吗—不可以</p><p>世界最高的摩天大楼迪拜塔有多高—828米</p><p>迪拜的帆船酒店是几星级酒店—七星级酒店</p><p>迪拜的帆船酒店里有没有水下套房—没有</p><h3 id="沙特阿拉伯"><a href="#沙特阿拉伯" class="headerlink" title="沙特阿拉伯"></a>沙特阿拉伯</h3><p>沙特阿拉伯是沙漠国家，沙漠占国土面积的百分之多少—0.9</p><p>伊斯兰教创始人默罕默德的诞生地在哪个城市—麦加</p><p>沙特阿拉伯夏季炎热干燥，最高气温可达多少度—50</p><p>沙特阿拉伯是世界上最大的大麦进口国吗—是</p><p>沙特阿拉伯拥有全球已勘探石油总量的百分之多少—0.24</p><h3 id="伊拉克"><a href="#伊拉克" class="headerlink" title="伊拉克"></a>伊拉克</h3><p>古巴比伦是四大文明古国之一吗—是</p><p>伊拉克有哪个古文明遗址—古巴比伦文明</p><p>古时住在这里的苏美尔人发明了了什么文字—楔形文字</p><p>伊拉克的国旗上的文字是什么意思—真主至大</p><p>伊拉克有过宵禁制度吗—有</p>]]></content>
      
      
      <categories>
          
          <category> walkup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> walkup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/JVM/memory.html"/>
      <url>/JVM/memory.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要懂"><a href="#为什么要懂" class="headerlink" title="为什么要懂"></a>为什么要懂</h3><p>对Java程序员来说，有虚拟机的自动内存管理机制，不容易出现内存泄漏和内存溢出问题，一旦出现这种问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将异常艰难。</p><a id="more"></a><p><strong>版本：JDK1.6</strong></p><blockquote><p>一个 Java 源程序文件，会被编译为字节码文件（以 class 为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM 通过字节码解释器加载运行。</p></blockquote><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fpcsetuc1hj206f0b974e.jpg" alt="Markdown"></p><blockquote><p>概括地说来，JVM初始运行的时候都会分配好<strong>Method Area（方法区）</strong>和<strong>Heap（堆）</strong>，而JVM 每遇到一个线程，就为其分配一个<strong>Program Counter Register（程序计数器）</strong>, <strong>VM Stack（虚拟机栈）和Native Method Stack （本地方法栈），</strong>当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因。</p></blockquote><p><img src="https://wx3.sinaimg.cn/mw690/8c564d2agy1fpct5xgwnij20d60bk3zd.jpg" alt="Markdown"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>Java虚拟机所管理的内存<ul><li>程序计数器</li><li>Java虚拟机栈</li><li>本地方法栈</li><li>Java堆</li><li>方法区<ul><li>运行时常量池</li></ul></li></ul></li><li>直接内存(堆外内存)</li></ul><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2aly1fpkm8b565hj20fd0i2q3r.jpg" alt="Markdown"></p><h3 id="运行时数据"><a href="#运行时数据" class="headerlink" title="运行时数据"></a>运行时数据</h3><h4 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器 Program Counter Register"></a>程序计数器 Program Counter Register</h4><ul><li>字节码的行号指示器</li><li>“线程私有”的内存</li><li>没有规定任何OutOfMemoryError情况的区域</li></ul><p><strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就时通过改变这个计数器的值来选取下一条需要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成）。</p><p>Java虚拟机的多线程是通过线程轮流切换并分配处理执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，线程独立存储，互不影响。</p><ul><li>计数器的内容<ul><li>线程执行Java方法<ul><li>正在执行的虚拟机字节码指令的地址</li></ul></li><li>线程执行Native方法<ul><li>Undefined</li></ul></li></ul></li></ul><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fpctc32wwxj20f40auglo.jpg" alt="Markdown"></p><h4 id="Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="Java虚拟机栈 Java Virtual Machine Stacks"></a>Java虚拟机栈 Java Virtual Machine Stacks</h4><ul><li>线程私有</li><li>为虚拟机执行Java方法服务</li></ul><p><strong>Java方法执行的内存模型</strong>。</p><hr><p>Java指令的构成：</p><ul><li>操作码(方法本身)，保存在Stack中</li><li>操作数(方法内部变量)，简单类型保存在Stack中，对象类型在Stack保存地址，在Heap保存值</li></ul><hr><p><strong>栈帧(Stack Frame)</strong>：每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于<strong>存储局部变量表、操作数栈(Operand Stack，记录出栈、入栈的操作)、动态链接、方法出口等</strong>信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</p><p><img src="https://wx1.sinaimg.cn/mw690/8c564d2agy1fpctohrcqwg20cy094t8m.gif" alt="Markdown"></p><p><strong>局部变量表</strong>：存放编译器可知的各种基本数据类型、对象引用和returnAddress类型。所需内存空间在编译期间完成分配，运行时不会改变。</p><blockquote><ul><li>各种基本数据类型<ul><li>boolean</li><li>byte</li><li>char</li><li>short</li><li>int</li><li>float</li><li>long</li><li>double</li></ul></li></ul><p>其中，64位长度的long和double会占用2个局部变量空间(Slot)，其余的只占用1个。</p><ul><li>对象引用<ul><li>reference类型</li><li>不等同对象本身</li><li>可能是一个指向对象起始地址的引用指针</li><li>也可能是指向一个代表对象的句柄或其它与此对象相关的位置</li></ul></li><li>returnAddress<ul><li>指向一条字节码执行的地址</li></ul></li></ul></blockquote><ul><li>Java虚拟机规范中，对此区域规定了两种异常情况<ul><li>如果线程请求的栈深度大于虚拟机所允许的深度<ul><li>StackOverflowError异常</li></ul></li><li>如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存<ul><li>OutOfMemoryError异常</li></ul></li></ul></li></ul><p><a href="https://www.artima.com/insidejvm/ed2/jvm8.html" target="_blank" rel="external">参考资料</a></p><h4 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈 Native Method Stack"></a>本地方法栈 Native Method Stack</h4><ul><li>与虚拟机栈类似</li></ul><ul><li>为虚拟机执行native方法服务</li><li>虚拟机规范中没有强制规定使用的语言、使用方式与数据结构</li><li>异常<ul><li>StackOverflowError异常</li><li>OutOfMemoryError异常</li></ul></li></ul><h4 id="Java堆-Heap"><a href="#Java堆-Heap" class="headerlink" title="Java堆 Heap"></a>Java堆 Heap</h4><ul><li>线程共享</li><li>虚拟机启动时创建</li><li>存放对象实例<ul><li>包括对象的属性值、属性类型、对象本身的类型标记等，对象的方法以栈帧的形式保存在Stack中</li><li>对象在Heap分配好后，需要在Stack中保存一个4字节的Heap内存地址，用来定位该对象实例在Heap中的位置</li></ul></li><li>也称GC堆，因为是垃圾收集器管理的主要区域</li><li>可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可</li><li>大小通过<code>-Xmx</code>和<code>-Xms</code>控制</li><li>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError异常。</li></ul><p>从<strong>内存回收</strong>角度来看：由于现在收集器基本都采用分代收集算法，可分为<code>新生代</code>和<code>老年代</code>。细致划分为：<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivro空间</code>等。</p><p>从<strong>内存分配</strong>角度来看：可能划分出过个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)，进一步划分是为了更好地回收内存，或者更快的分配内存。</p><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2agy1fpcttlyoamj20cs07ljrj.jpg" alt="Markdown"></p><h4 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区 Method Area"></a>方法区 Method Area</h4><ul><li>线程共享</li><li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>Java虚拟机规范中描述为堆的一个逻辑部分，别名为Non-Heap(非堆)</li><li>不需要连续的内存</li><li>可以选择固定大小或者可扩展</li><li>可以选择不实现垃圾收集</li><li>内存回收目标主要是针对常量池的回收和对类型的卸载</li><li>当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常</li></ul><h4 id="运行时常量池-Runtime-Constant-Pool"><a href="#运行时常量池-Runtime-Constant-Pool" class="headerlink" title="运行时常量池 Runtime Constant Pool"></a>运行时常量池 Runtime Constant Pool</h4><ul><li>方法区的一部分</li><li>存放编译器生成的各种字面量和符号引用，将在类加载后进入方法区的运行时常量池中存放</li><li>一般来说，还会存放翻译出来的直接引用</li><li>具备动态性（和Class文件常量池比）<ul><li>编译期和运行期(<code>String.intern()方法</code>)均可放入常量</li></ul></li><li>JVM规范没有细节要求</li><li>无法再申请到内存时会抛出OutOfMemoryError异常</li></ul><blockquote><p>Class文件中的内容：</p><ul><li>类的版本</li><li>字段</li><li>方法</li><li>接口</li><li>常量池Constant Pool Table</li></ul></blockquote><p><a href="http://www.cnblogs.com/DreamSea/archive/2011/11/20/2256396.html" target="_blank" rel="external">参考资料</a></p><h3 id="直接内存Direct-Memory"><a href="#直接内存Direct-Memory" class="headerlink" title="直接内存Direct Memory"></a>直接内存Direct Memory</h3><ul><li>JVM管理的内存区域之外的</li><li>不受Java堆大小的限制</li><li>受<strong>本机总内存大小</strong>（RAM以及SWAP区或者分页文件）及<strong>处理器寻址空间</strong>的限制</li><li>在设置-Xmx参数时要注意直接内存<ul><li>各个内存区域总和<code>&lt;</code>物理内存限制（物理的和操作系统及的限制）</li><li>大于会导致动态扩展时可能会出现OutOfMemoryError异常</li></ul></li></ul><blockquote><p>JDK1.4新增NIO，引入了基于(Channel)与缓冲区(Buffer)的IO方式，NIO使用Native函数直接分配堆外内存，通过存储在Java堆中的DirectByteBufffer对象作为这块内存的引用进行操作。</p><p>一些场景中显著提高性能</p><p>避免了在Java堆和Native堆中来回复制数据</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMShowcase</span> </span>&#123;  </div><div class="line">  <span class="comment">//静态类常量</span></div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String ClASS_CONST = <span class="string">"I'm a Const"</span>;  </div><div class="line">  <span class="comment">//私有实例变量</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> instanceVar=<span class="number">15</span>;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">    <span class="comment">//调用静态方法</span></div><div class="line">    runStaticMethod();  </div><div class="line">    <span class="comment">//调用非静态方法</span></div><div class="line">    JVMShowcase showcase=<span class="keyword">new</span> JVMShowcase();  </div><div class="line">    showcase.runNonStaticMethod(<span class="number">100</span>);  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//常规静态方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">runStaticMethod</span><span class="params">()</span></span>&#123;  </div><div class="line">    <span class="keyword">return</span> ClASS_CONST;  </div><div class="line">  &#125;  </div><div class="line">  <span class="comment">//非静态方法</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runNonStaticMethod</span><span class="params">(<span class="keyword">int</span> parameter)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> methodVar=<span class="keyword">this</span>.instanceVar * parameter;  </div><div class="line">    <span class="keyword">return</span> methodVar;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="JVM执行步骤"><a href="#JVM执行步骤" class="headerlink" title="JVM执行步骤"></a>JVM执行步骤</h4><ul><li>JVM向操作系统申请指定空闲内存<ul><li>操作系统分配出指定内存，返回给JVM内存段的起始地址、终止地址</li><li>JVM准备加载类文件</li></ul></li><li>分配Java内存<ul><li>分配Heap内存</li><li>。。。</li></ul></li><li>文件检查、分析class文件<ul><li>有错误立即返回</li></ul></li><li>加载类<ul><li>JVM默认使用bootstrap加载器，加载rt.jar包下所有类到堆内存的Method Area</li><li>加载用户类（如上文中的<code>JVMShow</code>类），方法区中：<ul><li>main方法的符号引用</li><li>runStaticMethod方法的符号引用</li></ul></li><li>此时，Heap是空的，Stack是空的<ul><li>没有新建对象和执行线程</li></ul></li></ul></li><li>执行方法<ul><li>启动新线程，执行main方法</li><li>方法区中：<ul><li>main方法的符号引用</li><li>runStaticMethod方法的符号引用</li><li>CLASS_CONST(runStaticMethod方法内部第一次被访问时产生)</li></ul></li><li>堆中(<code>JVMShowcase showcase=new JVMShowcase(); 被执行</code>)：<ul><li>两个object？？？<ul><li>JVMShowcase的父类</li></ul></li><li>showcase对象</li></ul></li><li>栈中有三个栈帧：<ul><li>runNonStaticMethod</li><li>runStaticMethod</li><li>main</li></ul></li><li>程序计数器<ul><li>指向下一条要执行的语句</li></ul></li></ul></li><li>释放内存<ul><li>程序运行结束后，向操作系统释放内存。</li></ul></li></ul><h3 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h3><ul><li>Before JDK1.8</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/8c564d2aly1fpts117psxj20ip081q34.jpg" alt="before 1.8"></p><ul><li>After JDK1.8</li></ul><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2aly1fpts13i02pj20jw086t97.jpg" alt="after 1.8"></p><ul><li>在JDK1.7及之后，字符串常量池如果指的是<code>SymbolTable</code>和<code>StringTable</code>，这俩table本身都在native memory中，但它们的引用所存储的位置却发生了变化。<ul><li><code>SymbolTable</code>所引用的符号引用Symbols -&gt; native heap    </li><li><code>StringTable</code>所引用的interned Strings  -&gt; Java heap；</li></ul></li></ul><ul><li>类的静态变量class static variables -&gt; Java heap</li><li>class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li>移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li>永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.journaldev.com/2856/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="external">Java (JVM) Memory Model</a></p><p><a href="https://howtodoinjava.com/core-java/garbage-collection/jvm-memory-model-structure-and-components/" target="_blank" rel="external">JVM Memory Model / Structure and Components</a></p><p><a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" target="_blank" rel="external">Java Memory Model</a></p><p><a href="https://www.cnblogs.com/wangjzh/p/5258254.html" target="_blank" rel="external">深入理解JVM之JVM内存区域与内存分配</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 编译openJDK9</title>
      <link href="/JVM/build.html"/>
      <url>/JVM/build.html</url>
      
        <content type="html"><![CDATA[<ul><li>安装mercurial版本管理</li></ul><p><code>brew install mercurial</code></p><a id="more"></a><ul><li>安装ccache提高编译速度</li></ul><p><code>brew install ccache</code></p><ul><li>安装freetype</li></ul><p><code>brew install freetype</code></p><ul><li>获取源码</li></ul><p><code>hg clone http://hg.openjdk.java.net/jdk9/jdk9 YourOpenJDK</code></p><p><code>cd YourOpenJDK</code></p><p><code>chmod +x get_source.sh</code></p><p><code>./get_source.sh</code></p><ul><li>修改文件属性</li></ul><p><code>chmod +x configure</code></p><ul><li>输入一下命令激活后会生成一个编译配置。</li></ul><p><code>sudo ./configure --enable-debug --with-target-bits=64</code></p><ul><li>修改<code>get_resource.sh</code>，下载过程中，如果失败，则一直尝试，直至成功</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Get clones of all absent nested repositories (harmless if already exist)</div><div class="line">sh ./common/bin/hgforest.sh clone "$@" || exit $?</div><div class="line"></div><div class="line"><span class="meta">#</span> Update all existing repositories to the latest sources</div><div class="line">sh ./common/bin/hgforest.sh pull -u</div></pre></td></tr></table></figure><p>修改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> Get clones of all absent nested repositories (harmless if already exist)</div><div class="line">sh ./common/bin/hgforest.sh clone "$@"</div><div class="line"></div><div class="line">while [ $? -ne 0 ]</div><div class="line">do</div><div class="line">    sh ./common/bin/hgforest.sh clone "$@"</div><div class="line">done</div><div class="line"></div><div class="line"><span class="meta">#</span> Update all existing repositories to the latest sources</div><div class="line">sh ./common/bin/hgforest.sh pull -u</div><div class="line"></div><div class="line">while [ $? -ne 0 ]</div><div class="line">do</div><div class="line">    sh ./common/bin/hgforest.sh pull -u</div><div class="line">done</div></pre></td></tr></table></figure><ul><li>配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./configure --disable-warnings-as-errors --with-boot-jdk=/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/</div></pre></td></tr></table></figure><p><strong>参数解释</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">--with-target-bits：设置32位/64位编译</div><div class="line"></div><div class="line">--with-freetype：设置freetype路径</div><div class="line"></div><div class="line">--enable-ccache：设置启用ccache</div><div class="line"></div><div class="line">--with-jvm-variants=client,server：为了保证兼容性，编译时JVM的Client和Server都会被编译</div><div class="line"></div><div class="line">--with-boot-jdk-jvmargs：提供运行Bootstrap JDK所需要的JVM参数</div><div class="line"></div><div class="line">--disable-zip-debug-info：禁用zip调试信息</div><div class="line"></div><div class="line">--disable-warnings-as-errors：禁用将警告当做错误，避免因为警告而中断编译</div><div class="line"></div><div class="line">--with-debug-level：设置调试等级</div><div class="line"></div><div class="line">2&gt;&amp;1 | tee configure_mac_x64.log：将错误信息重定向至标准输出，并输出到configure_mac_x64.log</div></pre></td></tr></table></figure><p><strong>configure</strong></p><p><code>sudo ./configure --enable-debug --with-target-bits=64</code></p><p> 如果是正式版本，./configure后边不需要加参数。configure过程会检查一些配置，然后在YourOpenJDK/build目录下会有macosx-x86_64-normal-server-fastdebug目录，如果不是fastdebug版本，会有macosx-x86_64-normal-server-release目录。这个过程中遇到一个问题:</p><blockquote><p><code>configure: error: GCC compiler is required</code></p></blockquote><p>对于这个问题，我查到是YourOpenJDK/common/autoconf/generated-configure.sh里边校验抛出，我直接找到下边文本出现的两个地方给注释掉了……</p><blockquote><p><code>as_fn_error $? &quot;GCC compiler is required. Try setting --with-tools-dir.&quot; &quot;$LINENO&quot; 5</code></p></blockquote><p><img src="http://ww4.sinaimg.cn/large/0060lm7Tly1fom4mil51aj31kw0yj4bc.jpg" alt="Markdown"></p><p><strong>编译</strong></p><p><code>sudo make CONF=macosx-x86_64-normal-server-release</code></p><p><strong>验证</strong></p><p><img src="https://wx2.sinaimg.cn/mw690/8c564d2agy1fpigacx7t9j216606mabz.jpg" alt="Markdown"></p><p><strong>问题1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">=== Output from failing command(s) repeated here ===</div><div class="line">/usr/bin/printf &quot;* For target hotspot_variant-server_libjvm_objs_lcm.o:\n&quot;</div><div class="line">* For target hotspot_variant-server_libjvm_objs_lcm.o:</div><div class="line">(/usr/bin/grep -v -e &quot;^Note: including file:&quot; &lt;  /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/make-support/failure-logs/hotspot_variant-server_libjvm_objs_lcm.o.log || true) | /usr/bin/head -n 12</div><div class="line">/Users/2bai/Documents/code/jdk9/hotspot/src/share/vm/opto/lcm.cpp:42:35: error: ordered comparison between pointer and zero (&apos;address&apos; (aka &apos;unsigned char *&apos;) and &apos;int&apos;)</div><div class="line">  if (Universe::narrow_oop_base() &gt; 0) &#123; // Implies UseCompressedOops.</div><div class="line">      ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~</div><div class="line">1 error generated.</div><div class="line">if test `/usr/bin/wc -l &lt; /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/make-support/failure-logs/hotspot_variant-server_libjvm_objs_lcm.o.log` -gt 12; then /bin/echo &quot;   ... (rest of output omitted)&quot; ; fi</div><div class="line">/usr/bin/printf &quot;\n* All command lines available in /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/make-support/failure-logs.\n&quot;</div><div class="line"></div><div class="line">* All command lines available in /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/make-support/failure-logs.</div><div class="line">/usr/bin/printf &quot;=== End of repeated output ===\n&quot;</div><div class="line">=== End of repeated output ===</div><div class="line">if /usr/bin/grep -q &quot;recipe for target .* failed&quot; /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/build.log 2&gt; /dev/null; then /usr/bin/printf &quot;\n=== Make failed targets repeated here ===\n&quot; ; /usr/bin/grep &quot;recipe for target .* failed&quot; /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/build.log ; /usr/bin/printf &quot;=== End of repeated output ===\n&quot; ; /usr/bin/printf &quot;\nHint: Try searching the build log for the name of the first failed target.\n&quot; ; else /usr/bin/printf &quot;\nNo indication of failed target found.\n&quot; ; /usr/bin/printf &quot;Hint: Try searching the build log for &apos;] Error&apos;.\n&quot; ; fi</div><div class="line"></div><div class="line">=== Make failed targets repeated here ===</div><div class="line">lib/CompileJvm.gmk:207: recipe for target &apos;/Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-server-fastdebug/hotspot/variant-server/libjvm/objs/lcm.o&apos; failed</div><div class="line">make/Main.gmk:263: recipe for target &apos;hotspot-server-libs&apos; failed</div><div class="line">=== End of repeated output ===</div><div class="line"></div><div class="line">Hint: Try searching the build log for the name of the first failed target.</div><div class="line">/usr/bin/printf &quot;Hint: See common/doc/building.html#troubleshooting for assistance.\n\n&quot;</div><div class="line">Hint: See common/doc/building.html#troubleshooting for assistance.</div><div class="line"></div><div class="line">gmake[2]: Leaving directory &apos;/Users/2bai/Documents/code/jdk9&apos;</div><div class="line">make[1]: *** [main] Error 2</div><div class="line">make: *** [all] Error 2</div></pre></td></tr></table></figure><p><strong>解决</strong></p><p>修改<code>jdk9/hotspot/src/share/vm/opto/lcm.cpp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (base() &gt; <span class="number">0</span>) &#123; </div><div class="line"><span class="comment">//修改为</span></div><div class="line"><span class="keyword">if</span> (base() != <span class="literal">NULL</span>) &#123;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Universe::narrow_oop_base() &gt; <span class="number">0</span>) &#123; <span class="comment">// Implies UseCompressedOops.</span></div><div class="line"><span class="comment">//修改为</span></div><div class="line"><span class="keyword">if</span> (Universe::narrow_oop_base() != <span class="literal">NULL</span>) &#123; <span class="comment">// Implies UseCompressedOops.</span></div></pre></td></tr></table></figure><p><strong>问题2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jdk9/hotspot/src/jdk.hotspot.agent/macosx/native/libsaproc/MacosxDebuggerLocal.m:692:21: warning: &apos;ePtAttachDeprecated&apos; is deprecated: PT_ATTACH is deprecated. See PT_ATTACHEXC [-Wdeprecated-declarations]</div><div class="line">  if ((res = ptrace(PT_ATTACH, pid, 0, 0)) &lt; 0) &#123;</div><div class="line">                    ^</div><div class="line">/usr/include/sys/ptrace.h:85:19: note: expanded from macro &apos;PT_ATTACH&apos;</div><div class="line">#define PT_ATTACH       ePtAttachDeprecated     /* trace some running process */</div><div class="line">                        ^</div><div class="line">/usr/include/sys/ptrace.h:71:22: note: &apos;ePtAttachDeprecated&apos; has been explicitly marked deprecated here</div><div class="line">        ePtAttachDeprecated __deprecated_enum_msg(&quot;PT_ATTACH is deprecated. See PT_ATTACHEXC&quot;) = 10</div><div class="line">                            ^</div></pre></td></tr></table></figure><p><strong>解决2</strong></p><p>尝试直接把上面报错地方的PT_ATTACH改成10试试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((res = ptrace(PT_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">//修改为</span></div><div class="line"><span class="keyword">if</span> ((res = ptrace(<span class="number">10</span>, pid, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div></pre></td></tr></table></figure><p><strong>问题3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jdk9/jdk/src/java.desktop/share/native/libjavajpeg/jdhuff.c:458:13: warning: shifting a negative signed value is undefined [-Wshift-negative-value]</div><div class="line">  &#123; 0, ((-1)&lt;&lt;1) + 1, ((-1)&lt;&lt;2) + 1, ((-1)&lt;&lt;3) + 1, ((-1)&lt;&lt;4) + 1,</div><div class="line">        ~~~~^</div></pre></td></tr></table></figure><p><strong>解决3</strong></p><p>修改文件：</p><ul><li>jdk9/jdk/src/java.desktop/share/native/libjavajpeg/jdphuff.c:221</li><li>jdk9/jdk/src/java.desktop/share/native/libjavajpeg/jdhuff.c:458</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static const int extend_offset[16] = /* entry n is (-1 &lt;&lt; n) + 1 */</div><div class="line">  &#123; 0, (-(1&lt;&lt;1)) + 1, (-(1&lt;&lt;2)) + 1, (-(1&lt;&lt;3)) + 1, (-(1&lt;&lt;4)) + 1,</div><div class="line">    (-(1&lt;&lt;5)) + 1, (-(1&lt;&lt;6)) + 1, (-(1&lt;&lt;7)) + 1, (-(1&lt;&lt;8)) + 1,</div><div class="line">    (-(1&lt;&lt;9)) + 1, (-(1&lt;&lt;10)) + 1, (-(1&lt;&lt;11)) + 1, (-(1&lt;&lt;12)) + 1,</div><div class="line">    (-(1&lt;&lt;13)) + 1, (-(1&lt;&lt;14)) + 1, (-(1&lt;&lt;15)) + 1 &#125;;</div></pre></td></tr></table></figure><p><strong>问题4</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">=== Output from failing command(s) repeated here ===</div><div class="line">* For target hotspot_variant-server_libjvm_objs_loopPredicate.o:</div><div class="line">../src/share/vm/opto/loopPredicate.cpp:903:73: error: ordered comparison between pointer and zero (&apos;const TypeInt *&apos; and &apos;int&apos;)</div><div class="line">      assert(rng-&gt;Opcode() == Op_LoadRange || _igvn.type(rng)-&gt;is_int() &gt;= 0, &quot;must be&quot;);</div><div class="line">                                              ~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~</div><div class="line">../src/share/vm/utilities/debug.hpp:141:33: note: expanded from macro &apos;assert&apos;</div><div class="line">#define assert(p, ...) vmassert(p, __VA_ARGS__)</div><div class="line">                                ^</div><div class="line">../src/share/vm/utilities/debug.hpp:130:9: note: expanded from macro &apos;vmassert&apos;</div><div class="line">  if (!(p)) &#123;                                                                  \</div><div class="line">        ^</div><div class="line">1 error generated.</div><div class="line"></div><div class="line">* All command lines available in /Users/2bai/Documents/code/jdk9/build/macosx-x86_64-normal-serverANDclient-slowdebug/make-support/failure-logs.</div><div class="line">=== End of repeated output ===</div></pre></td></tr></table></figure><p><strong>解决4</strong></p><p>修改<code>jdk9/hotspot/src/share/vm/opto/loopPredicate.cpp:903</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(rng-&gt;Opcode() == Op_LoadRange || _igvn.type(rng)-&gt;is_int() &gt;= 0, &quot;must be&quot;);</div></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">assert(rng-&gt;Opcode() == Op_LoadRange || _igvn.type(rng)-&gt;is_int()-&gt;_lo &gt;= 0, &quot;must be&quot;);</div></pre></td></tr></table></figure><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p><strong>和编译openJDK9无关！！！！</strong></p><p>之前编译的时候取消了JAVA_HOME，怕自己忘记，记一下。</p><ul><li>JAVA_HOME</li></ul><p><code>/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home</code></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot验证</title>
      <link href="/Spring/validation.html"/>
      <url>/Spring/validation.html</url>
      
        <content type="html"><![CDATA[<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><a id="more"></a><ul><li>Bean Validation（JSR-303）：介绍 Java Bean 验证、核心 API、实现框架 Hibernate Validator</li><li>Apache commons-validator ：介绍最传统 Apache 通用验证器框架，如：长度、邮件等方式</li><li>Spring Validator：介绍 Spring 内置验证器 API、以及自定义实现</li></ul><hr><h3 id="Bean-Validation-1-1-JSR-303"><a href="#Bean-Validation-1-1-JSR-303" class="headerlink" title="Bean Validation 1.1 JSR-303"></a>Bean Validation 1.1 JSR-303</h3><h4 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>命名规则(Since Spring Boot 1.4)：Spring Boot大多数情况采用<code>starter</code>(启动器，包含一些自动装配的Spring组建)，官方的命名规则：<code>spring-boot-starter-{name}</code>。非官方采用<code>{name}-spring-boot-starter</code></p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> javax.validation.constraints.Max;</div><div class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="meta">@Max</span>(value=<span class="number">10000</span>)</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="meta">@NotNull</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> String cardNumber;</div><div class="line"></div><div class="line">    <span class="comment">//ignore getter and setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.bai.springbootvalidation.domain.User;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"><span class="keyword">import</span> javax.validation.Valid;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user/save"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">save</span><span class="params">(@Valid @RequestBody User user)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> user;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>请求时，当id&gt;10000或name为null时，会报错。</strong></p><ul><li>优点<ul><li>节省代码。</li></ul></li><li>其它方式<ul><li>API方式<ul><li><code>Assert.hasText(user.getName(),&quot;名称不能为空&quot;);</code></li><li>不能为空，必须有文字</li><li>返回500</li></ul></li><li>JVM断言<ul><li><code>assert user.getId() &lt;= 10000;</code></li><li>返回400</li></ul></li><li>缺点<ul><li>耦合了业务逻辑，虽然可以通过<code>HandlerInterceptor</code>或<code>Filter</code>做拦截，但是也是非常不优雅的。</li><li>还可以通过AOP方式，也可以提升代码的可读性。</li><li>以上方式都不是统一的标准</li></ul></li></ul></li></ul><h3 id="自定义Bean-Validation"><a href="#自定义Bean-Validation" class="headerlink" title="自定义Bean Validation"></a>自定义Bean Validation</h3><p>通过员工的卡号来校验，需要通过工号的前缀和后缀来判断。前缀必须以<code>2BAI-</code>开头。后缀必须以<code>数字</code>结尾。需要通过Bean Validation校验。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>复制成熟 Bean Validation Annotation的模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(FIELD)</div><div class="line"><span class="meta">@Retention</span>(RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ValidCardNumber &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>参考和理解@Constraint</li><li>实现ConstraintValidator 接口</li><li>将实现ConstraintValidator 接口 定义到@Constraint#validatedBy</li><li>给@ValidCardNumber 添加 message 参数</li></ul><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><code>org.springframework.util.StringUtils.delimitedListToStringArray</code>来分割字符串取代<code>Split</code><ul><li>该方法使用了正则表达式</li><li>其次是空指针NPE保护不够</li><li>如果在依赖中没有<code>StringUtils.delimitedListToStringArray</code>，可以使用<code>JDK</code>里的<code>StringTokenizer</code>(不足：类似于枚举<code>Enumeration</code>)或<code>org.apache.commons.lang3.StringUtils</code></li></ul></li><li>采用三方类库时，尽量用一套类库，不要A库用一点，B库用一点。</li></ul><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p>Q：JSON校验如何办？</p><p>A：尝试变成 Bean 的方式。</p><p>Q：实际中很多参数都要校验，这样写会增加很多类</p><p>A：确实会增加部分工作量，大多数场景，不需要自定义，除非很特殊情况。Bean Validation 的主要缺点，单元测试不方便。需要拿到Annotation，然后构造参数去测试。</p><p>Q：如果前端固定表单的话，这种校验方式很好。但是灵活性不够，如果表单是动态的话，如何校验呢？</p><p>A：表单字段与 Form 对象绑定即可，再走 Bean Validation 逻辑。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">command</span>=<span class="string">"form"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"$&#123;form.name&#125;"</span> /&gt;</span></div><div class="line">  ...</div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"$&#123;form.age&#125;"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><p>也可以通过责任链模式（Pipeline），一个接一个验证：</p><p>field 1-&gt; field 2 -&gt; field 3 -&gt; compute -&gt; result</p><p>Q：如何自定义，返回格式？如何最佳实现？</p><p>A：可以通过REST来实现，比如 XML 或者 JSON 的格式（视图）。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot JDBC</title>
      <link href="/Spring/JDBC.html"/>
      <url>/Spring/JDBC.html</url>
      
        <content type="html"><![CDATA[<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><a id="more"></a><ul><li>数据源DataSource</li><li>事务Transation</li><li>JDBC4.0(JSR-221)</li><li>问题及回答</li></ul><hr><h3 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h3><blockquote><p>数据源是数据库连接的来源，通过DataSource接口获取。</p></blockquote><ul><li>类型<ul><li>通用型数据源<ul><li>javax.sql.DataSource</li></ul></li><li>分布式数据源<ul><li>javax.sql.XADataSource</li></ul></li><li>嵌入式数据源<ul><li>org.springframework.jdbc.datasource.embedded.EmbeddedDatasource</li></ul></li></ul></li></ul><h4 id="Spring-Boot实际使用场景"><a href="#Spring-Boot实际使用场景" class="headerlink" title="Spring Boot实际使用场景"></a>Spring Boot实际使用场景</h4><blockquote><ul><li>在Spring Boot 2.0.0<ul><li>如果采用Spring WebMVC作为Web服务，默认情况下，使用嵌入式Tomcat。</li><li>如果采用Spring WebFlux，默认情况下，使用嵌入式Netty Web Server。</li></ul></li><li>传统的Servlet采用HttpServletRequest、HttpServletResponse</li><li>WebFlux采用：ServletRequest、ServletResponse<ul><li>不再限制于Servlet容器，可以选择自定义实现，比如Netty Web Server</li></ul></li></ul></blockquote><h5 id="单数据源的场景"><a href="#单数据源的场景" class="headerlink" title="单数据源的场景"></a>单数据源的场景</h5><p><strong>数据库连接池技术</strong></p><p><a href="http://commons.apache.org/proper/commons-dbcp/" target="_blank" rel="external">Apache Commons DBCP</a></p><ul><li>commons-dbcp2<ul><li>依赖commons-pool2</li></ul></li><li>commons-dbcp<ul><li>依赖commons-pool</li></ul></li></ul><p><a href="http://tomcat.apache.org/tomcat-8.5-doc/jndi-datasource-examples-howto.html" target="_blank" rel="external">Tomcat DBCP</a></p><h6 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h6><ul><li><a href="http://start.spring.io/" target="_blank" rel="external">创建项目</a><ul><li>版本<ul><li>2.0.0M7</li></ul></li><li>依赖<ul><li>JDBC、MySQL、Reactive Web</li></ul></li></ul></li><li>启动项目<ul><li>会报错：<code>Cannot determine embedded database driver class for database type NONE</code></li></ul></li><li>如果没有配置数据源，就将pom文件下<code>jdbc</code>依赖注释掉。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>报错源码</strong></p><ul><li>调用流程</li></ul><p><code>org.springframework.boot.autoconfigure.jdbc</code>包下</p><p><code>DataSourceConfiguration.Hikari#dataSource</code> -&gt; <code>DataSourceConfiguration#createDataSource</code>-&gt; <code>DataSourceProperties#initializeDataSourceBuilder</code> -&gt;</p><p><code>DataSourceProperties#determineDriverClassName</code></p><ul><li>报错位置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">determineDriverClassName</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.driverClassName)) &#123;</div><div class="line">    Assert.state(driverClassIsLoadable(),</div><div class="line">                 () -&gt; <span class="string">"Cannot load driver class: "</span> + <span class="keyword">this</span>.driverClassName);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.driverClassName;</div><div class="line">  &#125;</div><div class="line">  String driverClassName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</div><div class="line">    driverClassName = DatabaseDriver.fromJdbcUrl(<span class="keyword">this</span>.url).getDriverClassName();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</div><div class="line">    driverClassName = <span class="keyword">this</span>.embeddedDatabaseConnection.getDriverClassName();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//这里报错</span></div><div class="line">  <span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceBeanCreationException(<span class="keyword">this</span>.embeddedDatabaseConnection,</div><div class="line">                                              <span class="keyword">this</span>.environment, <span class="string">"driver class"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> driverClassName;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h6 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h6><ul><li><p><code>application.properties</code>添加内容</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</div><div class="line">spring.datasource.url= jdbc://localhost:3306/test</div><div class="line">spring.datasource.username= root</div><div class="line">spring.datasource.password= root</div></pre></td></tr></table></figure></li><li><p>再次启动</p><ul><li>控制台输出<code>Located MBean &#39;dataSource&#39;: registering with JMX server as MBean [com.zaxxer.hikari:name=dataSource,type=HikariDataSource]</code></li><li>代表已经配置好了 </li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@ConfigurationProperties 对应 application.properties</span></div><div class="line"><span class="comment">//prefix 就是内容</span></div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span></span></div></pre></td></tr></table></figure><h5 id="多数据源的场景"><a href="#多数据源的场景" class="headerlink" title="多数据源的场景"></a>多数据源的场景</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.springbootjdbc.config;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.jdbc.DataSourceBuilder;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary;</div><div class="line"><span class="keyword">import</span> javax.sql.DataSource;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 多数据源配置</span></div><div class="line"><span class="comment"> * 方法的名称作为Bean的名称</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleDataSourceConfiguration</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span></div><div class="line"><span class="comment">     * spring.datasource.url= jdbc://localhost:3306/test</span></div><div class="line"><span class="comment">     * spring.datasource.username= root</span></div><div class="line"><span class="comment">     * spring.datasource.password= root</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Primary</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">masterDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();</div><div class="line">        DataSource dataSource = dataSourceBuilder.driverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>)</div><div class="line">                .url(<span class="string">"jdbc://localhost:3306/test"</span>)</div><div class="line">                .username(<span class="string">"root"</span>)</div><div class="line">                .password(<span class="string">"root"</span>)</div><div class="line">                .build();</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">slaveDataSource</span><span class="params">()</span> </span>&#123;</div><div class="line">        DataSourceBuilder dataSourceBuilder = DataSourceBuilder.create();</div><div class="line">        DataSource dataSource = dataSourceBuilder.driverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>)</div><div class="line">                .url(<span class="string">"jdbc://localhost:3306/test2"</span>)</div><div class="line">                .username(<span class="string">"root"</span>)</div><div class="line">                .password(<span class="string">"root"</span>)</div><div class="line">                .build();</div><div class="line">        <span class="keyword">return</span> dataSource;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>考虑到容灾、负载均衡的情况，更多的是通过MySQL的代理来做。</p><p>配置多数据源不能通过<code>application.properties</code>，是因为无法区分Bean的名称。</p><h3 id="事务Transaction"><a href="#事务Transaction" class="headerlink" title="事务Transaction"></a>事务Transaction</h3><blockquote><p>事务用于提供数据完整性，并在并发访问下确保数据视图的一致性。</p></blockquote><ul><li>概念<ul><li>自动提交模式Auto-commitmode</li><li>事务隔离级别Transaction isolation levels</li><li>保护点Savepoints</li></ul></li></ul><h4 id="自动提交模式和手动提交"><a href="#自动提交模式和手动提交" class="headerlink" title="自动提交模式和手动提交"></a>自动提交模式和手动提交</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">  Connection connection = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    connection = <span class="keyword">this</span>.masterDataSource.getConnection();</div><div class="line">    <span class="comment">//手动提交</span></div><div class="line">    <span class="comment">//connection.setAutoCommit(false);</span></div><div class="line">    PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">"INSERT INTO users(name) VALUES (?);"</span>);</div><div class="line">    preparedStatement.setString(<span class="number">1</span>, user.getName());</div><div class="line">    result = preparedStatement.executeUpdate() &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">    preparedStatement.close();</div><div class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//手动提交</span></div><div class="line">        <span class="comment">//connection.commit();</span></div><div class="line">        connection.close();</div><div class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Annotation-驱动"><a href="#Annotation-驱动" class="headerlink" title="Annotation 驱动"></a>Annotation 驱动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">  result=jdbcTemplate.execute(<span class="string">"INSERT INTO users(name) VALUES (?);"</span>, <span class="keyword">new</span> PreparedStatementCallback&lt;Boolean&gt;() &#123;</div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement preparedStatement)</span> <span class="keyword">throws</span> SQLException, DataAccessException </span>&#123;</div><div class="line">      preparedStatement.setString(<span class="number">1</span>, user.getName());</div><div class="line">      <span class="keyword">return</span> preparedStatement.executeUpdate() &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="事务隔离级别Transaction-isolation-levels"><a href="#事务隔离级别Transaction-isolation-levels" class="headerlink" title="事务隔离级别Transaction isolation levels"></a>事务隔离级别Transaction isolation levels</h4><blockquote><p><strong>脏读</strong>：脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。</p><p><strong>不可重复读</strong>：不可重复读的重点是修改 。不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。</p><p><strong>幻读</strong>：幻读的重点在于新增或者删除 。统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。</p></blockquote><ul><li><code>java.sql.Connection</code>中四个属性<ul><li><code>TRANSACTION_READ_UNCOMMITTED</code><ul><li>读取未提交的</li><li>脏读、不可重复读、幻读会发生</li></ul></li><li><code>TRANSACTION_READ_COMMITTED</code><ul><li>读取已提交的</li><li>解决脏读，但不可重复读、幻读会发生</li></ul></li><li><code>TRANSACTION_REPEATABLE_READ</code><ul><li>不可重复读</li><li>解决脏读和不可重复读，幻读会发生</li></ul></li><li><code>TRANSACTION_SERIALIZABLE</code><ul><li>事务</li><li>解决脏读、不可重复读和幻读</li></ul></li></ul></li><li>脏读、不可重复读、幻读的级别高低是：脏读 &lt; 不可重复读 &lt; 幻读。</li><li>级别越高性能越差</li></ul><p>Spring JDBC Transaction实现重写了JDBC API：</p><p><code>org.springframework.transaction.annotation.Isolation</code> -&gt;<code>org.springframework.transaction.TransactionDefinition</code> -&gt;</p><p><code>java.sql.Connection</code></p><p>通过AOP的方式代理了Connection，自动提交模式关闭，经过一系列操作后，方法执行完毕，再提交事务。</p><h5 id="Transaction执行代理-TransactionInterceptor"><a href="#Transaction执行代理-TransactionInterceptor" class="headerlink" title="@Transaction执行代理-TransactionInterceptor"></a>@Transaction执行代理-<code>TransactionInterceptor</code></h5><p><code>org.springframework.transaction.annotation.Transactional</code></p><ul><li>可以控制rollback的异常粒度<ul><li><code>rollbackFor</code>方法以及<code>noRollbackFor</code>方法</li></ul></li><li>可以执行事务管理器<ul><li><code>transactionManager</code></li></ul></li></ul><h4 id="API驱动"><a href="#API驱动" class="headerlink" title="API驱动"></a>API驱动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">  DefaultTransactionAttribute defaultTransactionAttribute=<span class="keyword">new</span> DefaultTransactionAttribute();</div><div class="line">  <span class="comment">//开始事务</span></div><div class="line">  TransactionStatus transactionStatus=platformTransactionManager.getTransaction(defaultTransactionAttribute);</div><div class="line">  result=jdbcTemplate.execute(<span class="string">"INSERT INTO users(name) VALUES (?);"</span>, <span class="keyword">new</span> PreparedStatementCallback&lt;Boolean&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement preparedStatement)</span> <span class="keyword">throws</span> SQLException, DataAccessException </span>&#123;</div><div class="line">      preparedStatement.setString(<span class="number">1</span>, user.getName());</div><div class="line">      <span class="keyword">return</span> preparedStatement.executeUpdate() &gt; <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  platformTransactionManager.commit(transactionStatus);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>场景选择</p><p>是否事务嵌套，这就涉及到了事务传播</p><p>打了<code>@Transactional</code>标签的<code>save</code>方法调用没有打<code>@Transactional</code>的<code>save2</code>方法，单独调用<code>save2</code>是没有事务的</p><ul><li><code>org.springframework.transaction.annotation.Propagation</code><ul><li><code>REQUIRED</code><ul><li>默认</li><li>无：新建；有：加入当前事务</li></ul></li><li><code>SUPPORTS</code><ul><li>无：按非事务执行；有：使用当前事务</li></ul></li><li><code>MANDATORY</code><ul><li>无：报错；有：使用当前事务</li></ul></li><li><code>REQUIRES_NEW</code><ul><li>无：新建一个事务；有：当前事务挂起</li></ul></li><li><code>NOT_SUPPORTED</code><ul><li>无：按照非事务执行；有：当前事务挂起</li></ul></li><li><code>NEVER</code><ul><li>无：非事务执行，有：报错</li></ul></li><li><code>NESTED</code><ul><li>无：新建事务；有：当前事务嵌套其它事务</li></ul></li></ul></li></ul><h4 id="保护点Savepoints"><a href="#保护点Savepoints" class="headerlink" title="保护点Savepoints"></a>保护点Savepoints</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">jdbcSave</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connection = <span class="keyword">this</span>.masterDataSource.getConnection();</div><div class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">            PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">"INSERT INTO users(name) VALUES (?);"</span>);</div><div class="line">            preparedStatement.setString(<span class="number">1</span>, user.getName());</div><div class="line">            result = preparedStatement.executeUpdate() &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">            Savepoint savepoint = connection.setSavepoint(<span class="string">"T1"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                transactionalSave(user);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                connection.rollback(savepoint);</div><div class="line">            &#125;</div><div class="line">            connection.commit();</div><div class="line">            connection.releaseSavepoint(savepoint);</div><div class="line">            preparedStatement.close();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    connection.commit();</div><div class="line">                    connection.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Transactional</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transactionalSave</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">      <span class="comment">// 故意写错列名</span></div><div class="line">        result = jdbcTemplate.execute(<span class="string">"INSERT INTO logs(name1) VALUES (?);"</span>, <span class="keyword">new</span> PreparedStatementCallback&lt;Boolean&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Nullable</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement preparedStatement)</span> <span class="keyword">throws</span> SQLException, DataAccessException </span>&#123;</div><div class="line">                preparedStatement.setString(<span class="number">1</span>, <span class="string">"rollback"</span>);</div><div class="line">                <span class="keyword">return</span> preparedStatement.executeUpdate() &gt; <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><code>jdbcSave</code>调用<code>transactionalSave</code>，在<code>transactionalSave</code>内部故意写错列名导致发生错误，最后结果是<code>jdbcSave</code>可以正常提交保存成功，<code>transactionalSave</code>被回滚，数据不会插入到数据库中。</p><h3 id="问题-amp-解答"><a href="#问题-amp-解答" class="headerlink" title="问题&amp;解答"></a>问题&amp;解答</h3><p>Q：用reactive web，原来MVC的好多东西都不能用了？</p><p>A：不是，Reactive Web还是能够兼容Spring Web Mvc</p><p>Q：SP1调用SP2，如果SP2是注解新开一个事务的话，那么和嵌套事务有什么区别？</p><p>A：<code>NESTED</code>是根据JDBC驱动来实现的，不是Spring实现的，不一定所有数据库都支持。<code>REQUIRES_NEW</code>有独立的事务环境，<code>NESTED</code>是共享的(commit和rollback)</p><p>Q：开个线程池事务控制API方式？比如写的Excutor.fixExcutor(5)</p><p>A：<code>TransactionSynchronizationManager</code>使用大量的<code>ThreadLocal</code>来实现的。</p><p>Q：假设一个service方法打了<code>@Transation</code>，在这个方法中还有其它service的某个方法，这个方法没有加<code>@Transation</code>，那么如果内部方法报错，会回滚吗？</p><p>A：会。当前可以过滤掉一些无关紧要的异常noRollbackfor()。</p><p>Q：Spring 分布式事务生产环境实现方式有哪些?</p><p>A：<a href="https://docs.spring.io/spring-boot/docs/2.0.0.M5/reference/htmlsingle/#boot-features-jta" target="_blank" rel="external">Distributed Transactions with JTA</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot初体验</title>
      <link href="/Spring/first.html"/>
      <url>/Spring/first.html</url>
      
        <content type="html"><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><a id="more"></a><ul><li>Spring Boot技术栈<ul><li>介绍Spring Boot完整的技术栈(图片格式，暂时没有上传)<ul><li>Web应用</li><li>数据操作</li><li>消息</li><li>测试</li><li>运维管理</li></ul></li></ul></li><li>Spring Boot构建方式<ul><li>图形化</li><li>命令行</li></ul></li><li>Spring Boot多模块应用<ul><li>构建分层、多模块应用</li></ul></li><li>Spring Boot运行方式<ul><li>IDEA</li><li>命令行</li><li>Maven插件</li></ul></li><li>Spring Boot简单应用<ul><li>Spring Web MVC</li><li>Spring Web Flux技术</li><li>编程简单应用</li></ul></li><li>Spring Boot三大特性<ul><li>自动装配</li><li>嵌入式容器</li><li>为生产准备的特性</li></ul></li></ul><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a href="https://projects.spring.io/spring-boot/" target="_blank" rel="external">定义</a></h3><ul><li>应用<ul><li>功能性<ul><li>系统所设计的业务范畴</li></ul></li><li>非功能性<ul><li>安全</li><li>性能</li><li>监控</li><li>数据指标(CPU利用率、网卡使用率)</li><li>production-ready(为产品而准备)</li></ul></li></ul></li></ul><ul><li>特性<ul><li>约定大于配置<ul><li>大多数组件不需要自行配置，而是自动装配</li><li>简化开发</li><li>例如maven</li></ul></li><li>独立Spring容器，不需要外部依赖<ul><li>例如依赖Tomcat</li><li>嵌入式Tomcat、Jetty</li></ul></li></ul></li></ul><hr><ul><li>外部配置<ul><li>启动参数</li><li>配置文件</li><li>环境变量</li></ul></li><li>外部应用<ul><li>Servlet应用</li><li>Spring Web MVC</li><li>Spring Web Flux</li><li>WebSocket</li><li>WebService</li></ul></li></ul><hr><h3 id="Spring-Boot构建方式"><a href="#Spring-Boot构建方式" class="headerlink" title="Spring Boot构建方式"></a>Spring Boot构建方式</h3><ul><li><a href="http://start.spring.io/" target="_blank" rel="external">图形化方式</a></li><li>命令行方式(Maven)<ul><li><code>mvn archetype:generate -DgroupId=com.bai -DartifactId=first-spring-boot-app -Dversion=1.0.0-SNAPSHOT -DinteractiveMode=false</code></li></ul></li><li>修改<code>pom</code>文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--不加parent会报错：spring-boot-starter-webflux没有指定版本--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.M7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>first-spring-boot-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>first-spring-boot-app<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--当前使用的2.0.0M7版本在maven库中没有，只存在在spring的中央库内--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>修改<code>App.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Hello world!</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span></span></div><div class="line"><span class="comment"> * 和</span></div><div class="line"><span class="comment"> * <span class="doctag">@SpringBootConfiguration</span></span></div><div class="line"><span class="comment"> * <span class="doctag">@EnableAutoConfiguration</span></span></div><div class="line"><span class="comment"> * <span class="doctag">@ComponentScan</span></span></div><div class="line"><span class="comment"> * 等价</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        SpringApplication springBootApplication=<span class="keyword">new</span> SpringApplication(App.class);</div><div class="line">        springBootApplication.run(args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Q : 为什么<code>new SpringApplication</code>的时候需要把<code>App.class</code>传进去</p><p>A : <code>@SpringBootApplication</code>打在了App这个类上，App就相当于配置类</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li>启动时容器为内置Netty</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">INFO <span class="number">10206</span> --- [ctor-http-nio-<span class="number">1</span>] r.ipc.netty.tcp.BlockingNettyContext     : Started HttpServer on /<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">8080</span></div><div class="line">INFO <span class="number">10206</span> --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : <span class="function">Netty started on <span class="title">port</span><span class="params">(s)</span>: 8080</span></div><div class="line"><span class="function">INFO 10206 --- [           main] com.bai.App                              : Started App in 3.529 <span class="title">seconds</span> <span class="params">(JVM running <span class="keyword">for</span> <span class="number">4.775</span>)</span></span></div></pre></td></tr></table></figure><h4 id="一些理论"><a href="#一些理论" class="headerlink" title="一些理论"></a>一些理论</h4><p>Mono 和 Flux 是 Reactive streams 的<a href="http://projectreactor.io/docs/core/release/reference/docs/index.html#intro-reactive" target="_blank" rel="external">发布者</a>实现。</p><ul><li><p>body</p><ul><li><p>Mono</p><ul><li><p>0-1元素</p></li><li><p>Optional(Java8)</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collection&lt;User&gt; users=userRepository.findAll();</div><div class="line">Mono&lt;Collection&lt;User&gt;&gt; userMono=Mono.just(users);</div></pre></td></tr></table></figure></li></ul></li><li><p>Flux</p><ul><li><p>0-N元素</p></li><li><p>类似于Iterable或者Collection</p></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collection&lt;User&gt; users=userRepository.findAll();</div><div class="line">Flux&lt;User&gt; userFlux=Flux.fromIterable(users);</div></pre></td></tr></table></figure></li><li><p>Req -&gt; WebFlux -&gt; 1-N线程执行函数式任务</p></li><li><p>推的方式</p></li></ul></li></ul></li></ul><p>Mono和Flux都是Publisher。</p><p>Publisher -&gt; publish(1)</p><p>Subscription(1)：订阅消息</p><p>Subs(A)#onNext() -&gt; Subs(B)#onNext() -&gt; Subs(C)#onNext()</p><p>Java9里面API称之为Flow，可以理解为责任链，也叫观察者模式。</p><p>Reactive是推模式</p><p>Iterable是拉模式</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>编码</strong></p><ul><li>如果方法返回的是集合，尽量返回<ul><li>原子的</li><li>只读的</li></ul></li></ul><p><strong>书籍</strong></p><ul><li>《Effective Java》- 第二版</li></ul><p><strong>架构</strong></p><ul><li>Spring-webFlux不能和Spring-webmvc同时使用</li></ul><p><strong>资料</strong></p><ul><li><a href="https://docs.spring.io/spring/docs/5.0.3.BUILD-SNAPSHOT/spring-framework-reference/web-reactive.html#webflux-fn" target="_blank" rel="external">Spring官网示例代码错误</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//官方示例（错误）</span></div><div class="line">RouterFunction&lt;ServerResponse&gt; helloWorldRoute =</div><div class="line">    RouterFunctions.route(RequestPredicates.path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; Response.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确版本</span></div><div class="line">RouterFunction&lt;ServerResponse&gt; helloWorldRoute =</div><div class="line">    RouterFunctions.route(RequestPredicates.path(<span class="string">"/hello-world"</span>),</div><div class="line">    request -&gt; ServerResponse.ok().body(fromObject(<span class="string">"Hello World"</span>)));</div></pre></td></tr></table></figure><hr><h3 id="构建多模块应用"><a href="#构建多模块应用" class="headerlink" title="构建多模块应用"></a>构建多模块应用</h3><ul><li>修改主工程类型 jar -&gt; pom</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>新建web工程，将遗留代码全部移动到web/java目录下</li><li>再从web工程，独立出model工程</li><li>将web工程依赖model工程</li><li>重复步骤3，独立出persistence</li><li>再从persistence添加model的依赖</li><li>最终依赖关系 web -&gt; persistence -&gt; model</li></ul><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>persistence<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!--和当前项目版本保持一致--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>IDE</li><li>命令行</li><li>Maven脚本</li></ul><h4 id="构建可执行jar"><a href="#构建可执行jar" class="headerlink" title="构建可执行jar"></a>构建可执行jar</h4><ul><li>项目根路径下执行<code>mvn -Dmaven.text.skip -U clean package</code></li></ul><ul><li><code>cd web/target</code></li><li><code>java -jar web-1.0.0-SNAPSHOT.jar</code></li></ul><p><strong>no main manifest attribute, in web-1.0.0-SNAPSHOT.jar？</strong></p><blockquote><p>jar包里有MANIFEST.MF，有Main-Class的属性，API：java.util.jar.Manifest#getAttributes</p></blockquote><p>需要一个Spring Boot的插件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--web下的pom文件--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure><p>会保找不到插件，需要添加插件仓库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--总项目的pom文件--&gt;</span>    </div><div class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!--当前使用的2.0.0M7版本在maven库中没有，只存在在spring的中央库内--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="构建方式从jar切换为war"><a href="#构建方式从jar切换为war" class="headerlink" title="构建方式从jar切换为war"></a>构建方式从jar切换为war</h4><ul><li>修改web下pom文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div></pre></td></tr></table></figure><h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><ul><li>创建<code>webapp/WEB-INF</code>（相对于<code>src/main</code>目录）</li><li>新建空的<code>web.xml</code></li></ul><p>上两步是为了绕过war插件的限制</p><h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--取消web.xml验证--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">failOnMissingWebXml</span>&gt;</span>false<span class="tag">&lt;/<span class="name">failOnMissingWebXml</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="启动多个"><a href="#启动多个" class="headerlink" title="启动多个"></a>启动多个</h4><p>正常启动一个后，默认端口被占用，这时候需要用其它端口来启动服务。</p><p><code>java -jar web-1.0.0-SNAPSHOT.war --server.port=0</code></p><p><code>--server.port=0</code>随机挑选一个可用端口</p><p><code>server.por</code>源码位置：</p><p><code>org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration</code> -&gt; <code>ServerProperties</code>类中的<code>prefix</code> 是<code>server</code>，<code>port</code>就是下面的属性。</p><h3 id="maven启动"><a href="#maven启动" class="headerlink" title="maven启动"></a>maven启动</h3><ul><li>项目跟路径下执行<code>mvn spring-boot:run</code><ul><li>如果报本地仓库没有则执行：<code>mvn -Dmaven.test.skip -U clean install</code>，然后再启动就可以了。</li></ul></li></ul><h4 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h4><ul><li>解压<code>web-1.0.0-SNAPSHOT</code><ul><li><code>BOOT-INF</code><ul><li>这是Spring Boot1.4开始才有的。</li></ul></li></ul></li><li>当使用依赖或者插件时，如果版本是Milestone，需要增加</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--当前使用的2.0.0M7版本在maven库中没有，只存在在spring的中央库内--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></div></pre></td></tr></table></figure><ul><li><code>META-INF/MANIFEST.MF</code>里面有指定<ul><li>Main-Class</li><li>Start-Class </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Main-Class: org.springframework.boot.loader.JarLauncher</div><div class="line">Start-Class: com.bai.App</div></pre></td></tr></table></figure><ul><li>除了jar或者war启动的方式，还有目录启动方式<ul><li>可以帮助解决过期的jar不支持Spring Boot新方式，比如老版本的MyBatis<ul><li>如果是jar包<ul><li><code>cd /web/target/web-1.0.0-SNAPSHOT</code></li><li><code>java org.springframework.boot.loader.JarLauncher</code></li></ul></li><li>如果是war包<ul><li><code>cd /web/target/web-1.0.0-SNAPSHOT</code></li><li><code>java org.springframework.boot.loader.WarLauncher</code></li></ul></li></ul></li></ul></li></ul><hr><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>自动装配模式：xxxAutoConfiguration</p><p> 不同版本中名称可能会发生变化。</p><h4 id="问题及回答"><a href="#问题及回答" class="headerlink" title="问题及回答"></a>问题及回答</h4><p>Q：webFluxConfiguration里面的映射路径和controller里面的路径有什么区别？</p><p>A：基本上没有区别，注意不要重复定义或URL语义有重复。</p><p>Q：webFlux不是跟MVC不能一起吗，怎么启动了</p><p>A：spring-boot-starter-webmvc和spring-boot-starter-webflux可以放在同一个应用，可是webFlux不会工作，默认使用webmvc，webFlux不会被采用。其实webFlux是兼容Annotation驱动，比如<code>@RequestMapping</code>。</p><p>Q：webFlux可以定义rest吗</p><p>A：可以。</p><p>Q：Spring的老项目迁移到spring-boot，如何操作</p><p>A：老的XML方式采用<code>@ImportResource</code>导入</p><p>Q：嵌入式Tomcat如何调优</p><p>A：两种方式：</p><ul><li>通过application.properties文件调整参数</li><li>通过接口回调：<code>TomcatConnectorCustomizer</code>、<code>TomcatContextCustomizer</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Web MVC</title>
      <link href="/Spring/MVC.html"/>
      <url>/Spring/MVC.html</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Web-MVC"><a href="#Spring-Web-MVC" class="headerlink" title="Spring Web MVC"></a>Spring Web MVC</h3><a id="more"></a><p>M : Model</p><p>V  : View</p><p>C  : Controller -&gt; DispatcherServlet</p><p>Front Controller =  DispatcherServlet</p><p>Application Controller = <code>@Controller</code> or  <code>xx implements Controller</code></p><ul><li>Context<ul><li>ServletContextListener -&gt; ContextLoaderListener -&gt; Root WebApplicationContext</li><li>DispatcherServlet -&gt; Servlet WebApplicationContext</li></ul></li><li>Services<ul><li>@Services</li></ul></li><li>Repositories<ul><li>@Repositories</li></ul></li></ul><h3 id="映射处理"><a href="#映射处理" class="headerlink" title="映射处理"></a>映射处理</h3><ul><li>Servlet匹配规则<ul><li>精确匹配<ul><li><code>/IndexServlet</code></li></ul></li><li>模糊匹配<ul><li><code>/*.jsp</code></li><li>当前目录下的所有目录</li></ul></li><li>/匹配<ul><li><code>/</code></li><li>当前目录</li></ul></li></ul></li></ul><ul><li>Servlet请求映射<ul><li>Servlet URL Pattern</li><li>Filter URL Pattern</li></ul></li><li>Spring Web MVC<ul><li>DispatcherServlet</li><li>HandlerMapping</li></ul></li></ul><h4 id="RestController-Controller-ResponseBody"><a href="#RestController-Controller-ResponseBody" class="headerlink" title="@RestController=@Controller+@ResponseBody"></a><code>@RestController</code>=<code>@Controller</code>+<code>@ResponseBody</code></h4><p><code>org.springframework.web.bind.annotation.RestController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</div><div class="line"><span class="comment">//ignore</span></div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="comment">//关键点</span></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The value may indicate a suggestion for a logical component name,</span></div><div class="line"><span class="comment"> * to be turned into a Spring bean in case of an autodetected component.</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></div><div class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0.1</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@AliasFor</span>(annotation = Controller.class)</div><div class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>DispatcherServlet &lt; FrameworkServlet &lt; HttpServletBean &lt; HttpServlet</p><ul><li>新建项目，依赖Web</li><li>新建packet-&gt;controller -&gt; 新建Controller -&gt; RestDemoController</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.springwebmvc.controller;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Rest Demo Controller</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestDemoController</span> </span>&#123;</div><div class="line">    <span class="meta">@GetMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>浏览器访问:localhost:8080,页面显示“Hello World”。</p><h4 id="问题及回答"><a href="#问题及回答" class="headerlink" title="问题及回答"></a>问题及回答</h4><p>Q ： 为什么Controller没有映射地址却能启动起来</p><p>A ： 自动装配，详情参见下面源码：<code>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</code>。此处的ServletContext path =”” or “/“，此二者等价。</p><p>Request URL = ServletContext path + @RequestMapping(“”) 或者 @GetMapping()</p><p>当前例子中，Request URL = “”+“”=“” -&gt; RestDemoController#index</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet;</div><div class="line"></div><div class="line"><span class="comment">// ignore import</span></div><div class="line"></div><div class="line"><span class="meta">@AutoConfigureOrder</span>(-<span class="number">2147483648</span>)</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ConditionalOnWebApplication</span>(</div><div class="line">    type = Type.SERVLET</div><div class="line">)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123;DispatcherServlet.class&#125;)</div><div class="line"><span class="meta">@AutoConfigureAfter</span>(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)</div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;ServerProperties.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;</div><div class="line">  </div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The bean name for a DispatcherServlet that will be mapped to the root URL "/"</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = <span class="string">"dispatcherServlet"</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * The bean name for a ServletRegistrationBean for the DispatcherServlet "/"</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = <span class="string">"dispatcherServletRegistration"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Conditional</span>(DefaultDispatcherServletCondition.class)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(ServletRegistration.class)</div><div class="line">    <span class="comment">//关键点</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(WebMvcProperties.class)</div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletConfiguration</span> </span>&#123;</div><div class="line">      <span class="comment">//ignore</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Q : 为什么访问localhost:8080可以调用到RestDemoController#index？</p><p>A : Spring MVC的处理方式是HandlerMapping自动寻找Request URL，匹配的Handler，Handler是处理的方法，当前这是一种实例。Request -&gt; Handler -&gt; 执行结果 -&gt; 返回(Rest) -&gt; 普通的文本。</p><p>HandlerMapping -&gt; RequestMappingHandlerMapping -&gt; @RequestMapping + Handler Mapping </p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><hr><p>Spring Web MVC 的配置 Bean ：<code>org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties</code></p><p>Spring Boot允许通过application.properties去定义配置，配置外部化。</p><p><code>WebMvcProperties</code>配置前缀：<code>spring.mvc</code></p><hr><p><code>@PostMapping</code>     Post请求    @RequestMapping(method = RequestMethod.POST)      Create(C)</p><p><code>@GetMapping</code>       Get请求      @RequestMapping(method = RequestMethod.GET)        Read(R)</p><p><code>@PutMapping</code>       Put请求      @RequestMapping(method = RequestMethod.PUT)        Update(R)</p><p><code>@DeleteMapping</code> Delete请求 @RequestMapping(method = RequestMethod.DELETE) Delete(D)</p><p>无HeadMapping</p><hr><p>拦截器：HandlerInterceptor ，可以理解handler到底是什么</p><p><strong>如何装配</strong></p><p>在启动类(xxxApplication,@SpringBootApplication) 继承WebMvcConfigurerAdapter(此类已经逐渐被淘汰)，重写addInterceptors方法，通过registry.addInterceptor方法将自定义拦截器装配。</p><p><strong>处理顺序</strong></p><p>preHandle(true) -&gt; HandlerMethod(因为采用了@GetMapping，其它场景可能会有不同)执行(Method#invoke) -&gt; postHandle -&gt; afterCompletion</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><a href="https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="external">异常处理</a></h3><ul><li>Servlet标准</li><li>Spring Web MVC</li><li>Spring Boot</li></ul><h4 id="理解web-xml错误页面"><a href="#理解web-xml错误页面" class="headerlink" title="理解web.xml错误页面"></a>理解web.xml错误页面</h4><h5 id="传统的Servlet-web-xml错误页面"><a href="#传统的Servlet-web-xml错误页面" class="headerlink" title="传统的Servlet web.xml错误页面"></a>传统的Servlet web.xml错误页面</h5><p>Servlet -&gt; web.xml(schema -&gt; .xsd) -&gt; 错误页面</p><p><error-page>处理逻辑：</error-page></p><ul><li>处理状态码<error-code></error-code></li><li>处理异常类型<exception-type></exception-type></li><li>处理服务<location></location></li><li>优点<ul><li>统一处理，业界标准</li></ul></li><li>不足<ul><li>灵活度不够，只能定义在web.xml文件或annotation里面</li></ul></li></ul><h5 id="Spring-Web-MVC-异常处理"><a href="#Spring-Web-MVC-异常处理" class="headerlink" title="Spring Web MVC 异常处理"></a>Spring Web MVC 异常处理</h5><ul><li>@ExceptionHandler</li></ul><ul><li>@RestControllerAdvice=@ControllerAdvice+@ResponseBody</li><li>@ControllerAdvice专门拦截@Controller</li></ul><ul><li>不足<ul><li><a href="https://docs.spring.io/spring/docs/5.0.2.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers" target="_blank" rel="external">很难完全掌握所有的异常类型</a></li></ul></li><li>优点<ul><li>易于理解，尤其是全局异常处理</li></ul></li></ul><h5 id="Spring-Boot错误处理页面"><a href="#Spring-Boot错误处理页面" class="headerlink" title="Spring Boot错误处理页面"></a>Spring Boot错误处理页面</h5><ul><li>实现<code>ErrorPageRegistrar</code>接口</li></ul><ul><li>注册ErrorPage对象</li><li>实现ErrorPage对象中的Path路径Web服务</li></ul><ul><li>不足<ul><li>页面处理的路径必须笃定</li></ul></li><li>优点<ul><li>状态码<ul><li>比较通用，不需要理解SpringWebMVC异常体系</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.springwebmvc;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.bai.springwebmvc.interceptor.DefaultHandlerInterceptor;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.web.server.ErrorPage;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.web.server.ErrorPageRegistrar;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.web.server.ErrorPageRegistry;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringWebmvcApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span></span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(SpringWebmvcApplication.class, args);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</div><div class="line">registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND,<span class="string">"/404.html"</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="视图技术"><a href="#视图技术" class="headerlink" title="视图技术"></a>视图技术</h3><ul><li>View</li></ul><ul><li>ViewResolver<ul><li>ContentNegotiatingViewResolver</li></ul></li><li>实战<ul><li>Thymeleaf</li></ul></li></ul><hr><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p><code>org.springframework.web.servlet.View#render</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; model,</span></span></div><div class="line"><span class="function"><span class="params">HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure><ul><li>处理页面渲染的逻辑<ul><li>Velocity</li><li>JSP</li><li>Thymeleaf</li></ul></li></ul><h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>页面+解析器(resolve)</p><p><code>org.springframework.web.servlet.ViewResolver#resolveViewName</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * viewName : view的名称</span></div><div class="line"><span class="comment"> * locale   : 多语言(国际化)</span></div><div class="line"><span class="comment"> * 寻找对应的View对象</span></div><div class="line"><span class="comment"> * requestURI -&gt; RequestMappingHandlerMaping -&gt; HanleMethod -&gt;</span></div><div class="line"><span class="comment"> * return "viewName" -&gt; ViewResolver -&gt; View -&gt; render -&gt; HTML</span></div><div class="line"><span class="comment"> * 完整的页面名称 = prefix + "viewName" + suffix</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Nullable</span></div><div class="line"><span class="function">View <span class="title">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception</span>;</div></pre></td></tr></table></figure><p>prefix 和 suffix 在<code>org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.View的属性内</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Spring MVC view prefix.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> String prefix;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">   * Spring MVC view suffix.</span></div><div class="line"><span class="comment">   */</span></div><div class="line">  <span class="keyword">private</span> String suffix;</div><div class="line">  <span class="comment">//ignore</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="Spring-Boot接续完整的页面路径"><a href="#Spring-Boot接续完整的页面路径" class="headerlink" title="Spring Boot接续完整的页面路径"></a>Spring Boot接续完整的页面路径</h5><p>spring.view.prefix + hanlerMethod return + spring.view.suffix</p><p><strong>自动装配类</strong>：<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</code></p><p>进行自动装配，html不需要在web.xml里配置</p><p><strong>配置项类</strong>：<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafProperties</code></p><p>配置项前缀：<code>spring.thymeleaf</code></p><p>模板寻找前缀：<code>spring.thymeleaf.prefix</code></p><p>模板寻找后缀：<code>spring.thymeleaf.suffix</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.thymeleaf;</div><div class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</div><div class="line">  <span class="comment">//ignore</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ContentNegotiatingViewResolver"><a href="#ContentNegotiatingViewResolver" class="headerlink" title="ContentNegotiatingViewResolver"></a>ContentNegotiatingViewResolver</h4><p><code>org.springframework.web.servlet.view.ContentNegotiatingViewResolver</code></p><ul><li>用于处理多个ViewResolver<ul><li>JSP</li><li>Velocity</li><li>Thymeleaf</li></ul></li></ul><ul><li>当所有的ViewResover配置完成时，它们的order默认值时一样的，所以先来先服务(List)</li><li>当它们定义自己的order，通过order来倒序排列<ul><li>ViewResolver有优先级,排序在#getCandidateViews内</li></ul></li></ul><ul><li>流程<ul><li>得到CandidateViews(List)</li><li>得到最匹配的View</li><li>render</li></ul></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ul><li>添加maven依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--Thymeleaf--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>修改默认配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--resources/application.properties--&gt;</span></div><div class="line">spring.thymeleaf.prefix = classpath:/thymeleaf/</div><div class="line">spring.thymeleaf.suffix = .htm</div></pre></td></tr></table></figure><ul><li>添加页面<ul><li>resources下添加directory:<code>thymeleaf</code></li><li>在<code>thymeleaf</code>下添加file：<code>index.htm</code></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--/*@thymesVar id="name" type="java.lang.String"*/--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"#&#123;home.welcome&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>添加controller</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.springwebmvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">indexController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>浏览器访问localhost:8080，页面显示<code>??home.welcome_zh_CN??</code></li></ul><h3 id="国际化-i18N"><a href="#国际化-i18N" class="headerlink" title="国际化(i18N)"></a>国际化(i18N)</h3><ul><li>Locale/LocaleContext</li><li>LocaleContextHolder<ul><li>Spring内的对象</li><li>缓存context</li></ul></li><li>LocaleResolver/LocaleContextResolver</li></ul><p><code>org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</code></p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><ul><li>修改application.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.messages.basename=META-INF/locale/messages</div></pre></td></tr></table></figure><ul><li>在上面的文件夹下添加文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#文件路径META-INF/locale/messages/messages.properties</div><div class="line">home.welcome = welcome</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#文件路径META-INF/locale/messages/messages_zh_cn.properties</div><div class="line">home.welcome = 欢迎</div></pre></td></tr></table></figure><ul><li>访问localhost:8080,页面会根据浏览器的设置返回对应语言的文字</li></ul><h3 id="问题及回答-1"><a href="#问题及回答-1" class="headerlink" title="问题及回答"></a>问题及回答</h3><p>Q：遇到新问题如何查文档</p><p>A：在能定位错误范围的前提下，尽量不Google，找规范文档。解决问题后，读相关资料，不要为了解决问题而解决，而是要尽量扩充知识面，积累知识。</p><p>Q：怎么处理异常比较优雅</p><p>A：采用ExceptionHandler，代码层面易于理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.springwebmvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.NoHandlerFoundException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="meta">@RestControllerAdvice</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestControllerAdvicer</span> </span>&#123;</div><div class="line"><span class="comment">//多个Exception中间用","分隔</span></div><div class="line">    <span class="meta">@ExceptionHandler</span>(&#123;NoHandlerFoundException.class,IllegalAccessException.class&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">pageNotFound</span><span class="params">(HttpStatus status,HttpServletRequest request, Throwable throwable)</span></span>&#123;</div><div class="line">        Map&lt;String,Object&gt; errors =<span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        errors.put(<span class="string">"statusCode"</span>,request.getAttribute(<span class="string">"javax.servlet.error.status_code"</span>));</div><div class="line">        errors.put(<span class="string">"requestUri"</span>,request.getAttribute(<span class="string">"javax.servlet.error.request_uri"</span>));</div><div class="line">        <span class="keyword">return</span> errors;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@ExceptionHandler</span>(NullPointerException.class)</div><div class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">handleNPE</span><span class="params">( Throwable throwable)</span></span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> throwable.getMessage();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring REST</title>
      <link href="/Spring/REST.html"/>
      <url>/Spring/REST.html</url>
      
        <content type="html"><![CDATA[<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><a id="more"></a><p><a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="external">Representational state transfer</a></p><blockquote><p><strong>Representational state transfer</strong> (<strong>REST</strong>) or <strong>RESTful</strong> <a href="https://en.wikipedia.org/wiki/Web_service" target="_blank" rel="external">web services</a> are a way of providing interoperability between computer systems on the <a href="https://en.wikipedia.org/wiki/Internet" target="_blank" rel="external">Internet</a>. REST-compliant Web services allow requesting systems to access and manipulate textual representations of <a href="https://en.wikipedia.org/wiki/Web_resource" target="_blank" rel="external">Web resources</a> using a uniform and predefined set of <a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="external">stateless</a> operations. Other forms of Web services exist, which expose their own arbitrary sets of operations such as <a href="https://en.wikipedia.org/wiki/Web_Services_Description_Language" target="_blank" rel="external">WSDL</a> and <a href="https://en.wikipedia.org/wiki/SOAP" target="_blank" rel="external">SOAP</a>.<a href="https://en.wikipedia.org/wiki/Representational_state_transfer#cite_note-1" target="_blank" rel="external">[1]</a> </p></blockquote><ul><li>特性<ul><li>性能</li><li>伸缩性</li><li>简化统一接口</li><li>组件的可修改性</li><li>通讯的可视性</li><li>组件移植性</li><li>可靠性</li></ul></li><li>约束<ul><li>客户端计算能力薄弱，服务端计算能力较强</li><li>无状态<ul><li>如果需要持久化状态<ul><li>redis</li><li>数据库</li></ul></li></ul></li><li>缓存</li><li>分层系统</li><li>统一接口</li><li>自描述消息</li></ul></li></ul><ul><li>类型<ul><li>GET<ul><li>读</li></ul></li><li>PUT<ul><li>改</li><li>幂等</li></ul></li><li>POST<ul><li>增</li><li>非幂等</li></ul></li><li>DELETE<ul><li>删</li><li>幂等</li></ul></li><li>PATCH<ul><li>不常用</li></ul></li></ul></li></ul><blockquote><p> <strong>幂等</strong>：</p><p> 初始状态：0</p><p> 修改状态：1 * N</p><p> 最终状态：1</p><p> <strong>非幂等</strong>：</p><p> 初始状态：1</p><p> 修改状态：1+1=2</p><p> N次修改：1+N=N+1</p><p> 最终状态：N+1</p><p> 幂等/非幂等 依赖于服务端实现，这种方式是一种契约。</p></blockquote><ul><li>服务端核心接口<ul><li>定义相关<ul><li>@Controller</li><li>RestController</li></ul></li><li>映射相关<ul><li>@RequestMapping</li><li>@PathVariable</li></ul></li><li>方法相关<ul><li>RequestMethod</li></ul></li></ul></li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li><a href="http://start.spring.io/" target="_blank" rel="external">创建工程</a></li><li>创建实体类Person</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.domain;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>创建Controller</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.bai.restonwebwebmvc.domain.Person;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> &#125; &#123;<span class="doctag">@link</span> org.springframework.web.bind.annotation.RestController&#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)</div><div class="line">    <span class="comment">//required = false,参数不强制传输</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">(@PathVariable Long id, @RequestParam(required = <span class="keyword">false</span>)</span> String name )</span>&#123;</div><div class="line">        Person person=<span class="keyword">new</span> Person();</div><div class="line">        person.setId(id);</div><div class="line">        person.setName(name);</div><div class="line">        <span class="keyword">return</span> person;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>启动程序(xxxApplication)<ul><li>如果IDE用的是<a href="http://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a>，可以通过<code>Tools-&gt;Test RESTful Web Service</code>进行访问<code>http://localhost:8080/person/1?name=2bai</code>。</li><li>返回：<code>{&quot;id&quot;:1,&quot;name&quot;:&quot;2bai&quot;}</code></li></ul></li></ul><h3 id="自描述消息"><a href="#自描述消息" class="headerlink" title="自描述消息"></a>自描述消息</h3><blockquote><p>Accept:</p><p>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<em>/</em>;q=0.8</p></blockquote><ul><li>第一优先顺序<ul><li>text/html</li><li>application/xhtml+xml</li><li>application/xml</li></ul></li><li>第二优先顺序<ul><li>image/webp</li><li>image/apng</li></ul></li><li>q=0.9<ul><li>权重</li><li>浏览器默认设置</li><li>可以自行修改</li></ul></li></ul><h4 id="按照xml格式返回"><a href="#按照xml格式返回" class="headerlink" title="按照xml格式返回"></a>按照xml格式返回</h4><ul><li>添加pom依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--依赖包是通过org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport类中jackson2XmlPresent的className在search.maven.org中搜索得来--&gt;</span></div><div class="line"><span class="comment">&lt;!--search.maven.org -&gt; search -&gt; Advanced Search -&gt; By Classname--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>再次访问，会以<code>XML</code>格式返回。</li></ul><h3 id="问题及解答"><a href="#问题及解答" class="headerlink" title="问题及解答"></a>问题及解答</h3><p>Q：为什么第一次是JSON，后来添加了XML依赖后，又变成了XML</p><p>A：Spring Boot应用默认没有增加XML处理器实现，所以最后采用轮询的方式去逐一尝试是否可读(canWrite(POJO))，如果返回true，说明可以序列化改POJO对象，那么Jackson2恰好能处理，那么Jackson输出了。可以查阅源码<code>org.springframework.web.servlet.mvc.method.annotation.ResponseBodyEmitterReturnValueHandler#sendInternal</code>。</p><p>Q：当Accept请求头未被指定时，为什么还是JSON</p><p>A：依赖于messageConverters的插入顺序。</p><p>Q：converters中的顺序可以修改吗？</p><p>A：可以。参考下面实现的扩展之调整顺序。</p><h3 id="源码导读"><a href="#源码导读" class="headerlink" title="源码导读"></a>源码导读</h3><h4 id="EnableWebMvc"><a href="#EnableWebMvc" class="headerlink" title="@EnableWebMvc"></a><code>@EnableWebMvc</code></h4><p><code>org.springframework.web.servlet.config.annotation.EnableWebMvc</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Import</span>(&#123;DelegatingWebMvcConfiguration.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</div><div class="line">  <span class="comment">//ignore</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//List集合：先来先服务</span></div><div class="line"><span class="comment">//所有的HTTP自描述消息处理器均在messageConverters里</span></div><div class="line"><span class="comment">//这个集合会传递到RequestMappingHandlerAdapter类里</span></div><div class="line"><span class="comment">//最终控制写出。</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addDefaultHttpMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> </span>&#123;</div><div class="line">        StringHttpMessageConverter stringConverter = <span class="keyword">new</span> StringHttpMessageConverter();</div><div class="line">        stringConverter.setWriteAcceptCharset(<span class="keyword">false</span>);</div><div class="line">  <span class="comment">//开始按顺序添加</span></div><div class="line"><span class="comment">//debug得出下列顺序,重复添加的为Spring Boot的一个bug</span></div><div class="line"> <span class="comment">//0 = &#123;ByteArrayHttpMessageConverter@6489&#125; </span></div><div class="line"> <span class="comment">//1 = &#123;StringHttpMessageConverter@6490&#125; </span></div><div class="line"> <span class="comment">//2 = &#123;StringHttpMessageConverter@6491&#125; </span></div><div class="line"> <span class="comment">//3 = &#123;ResourceHttpMessageConverter@6492&#125; </span></div><div class="line"> <span class="comment">//4 = &#123;ResourceRegionHttpMessageConverter@6493&#125; </span></div><div class="line"> <span class="comment">//5 = &#123;SourceHttpMessageConverter@6494&#125; </span></div><div class="line"> <span class="comment">//6 = &#123;AllEncompassingFormHttpMessageConverter@6495&#125; </span></div><div class="line"> <span class="comment">//7 = &#123;MappingJackson2HttpMessageConverter@6166&#125; </span></div><div class="line"> <span class="comment">//8 = &#123;MappingJackson2HttpMessageConverter@6240&#125; </span></div><div class="line"> <span class="comment">//9 = &#123;MappingJackson2XmlHttpMessageConverter@6247&#125; </span></div><div class="line"> <span class="comment">//10 = &#123;MappingJackson2XmlHttpMessageConverter@6258&#125; </span></div><div class="line">  </div><div class="line">        messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</div><div class="line">        messageConverters.add(stringConverter);</div><div class="line">        messageConverters.add(<span class="keyword">new</span> ResourceHttpMessageConverter());</div><div class="line">        messageConverters.add(<span class="keyword">new</span> ResourceRegionHttpMessageConverter());</div><div class="line">        messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter());</div><div class="line">        messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</div><div class="line">        <span class="keyword">if</span> (romePresent) &#123;</div><div class="line">            messageConverters.add(<span class="keyword">new</span> AtomFeedHttpMessageConverter());</div><div class="line">            messageConverters.add(<span class="keyword">new</span> RssChannelHttpMessageConverter());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Jackson2ObjectMapperBuilder builder;</div><div class="line">  <span class="comment">//xml</span></div><div class="line">        <span class="keyword">if</span> (jackson2XmlPresent) &#123;</div><div class="line">            builder = Jackson2ObjectMapperBuilder.xml();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">                builder.applicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter(builder.build()));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jaxb2Present) &#123;</div><div class="line">            messageConverters.add(<span class="keyword">new</span> Jaxb2RootElementHttpMessageConverter());</div><div class="line">        &#125;</div><div class="line"><span class="comment">//json</span></div><div class="line">        <span class="keyword">if</span> (jackson2Present) &#123;</div><div class="line">            builder = Jackson2ObjectMapperBuilder.json();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">                builder.applicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">            &#125;</div><div class="line"><span class="comment">//以application/json为例，Spring Boot中默认使用Jackson2序列化方式</span></div><div class="line"><span class="comment">//媒体类型application/json，处理类为MappingJackson2HttpMessageConverter</span></div><div class="line">            <span class="comment">//提供两类方法：</span></div><div class="line">            <span class="comment">//1.读read*:通过HTTP请求内容转化成对应的Bean</span></div><div class="line">          <span class="comment">//2.写write*:通过Bean序列化成对应文本内容作为响应内容</span></div><div class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter(builder.build()));</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gsonPresent) &#123;</div><div class="line">            messageConverters.add(<span class="keyword">new</span> GsonHttpMessageConverter());</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jsonbPresent) &#123;</div><div class="line">            messageConverters.add(<span class="keyword">new</span> JsonbHttpMessageConverter());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (jackson2SmilePresent) &#123;</div><div class="line">            builder = Jackson2ObjectMapperBuilder.smile();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">                builder.applicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2SmileHttpMessageConverter(builder.build()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (jackson2CborPresent) &#123;</div><div class="line">            builder = Jackson2ObjectMapperBuilder.cbor();</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext != <span class="keyword">null</span>) &#123;</div><div class="line">                builder.applicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            messageConverters.add(<span class="keyword">new</span> MappingJackson2CborHttpMessageConverter(builder.build()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//protected 包内可见/继承类可见</span></div><div class="line"><span class="comment">//final 不允许修改</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;</div><div class="line">  <span class="comment">//初始化时如果为空</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="comment">//创建一个并加以扩展</span></div><div class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    configureMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">    <span class="comment">//如果没有扩展</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters.isEmpty()) &#123;</div><div class="line">      <span class="comment">//添加默认</span></div><div class="line">      addDefaultHttpMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">    &#125;</div><div class="line">    extendMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.messageConverters;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title">requestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">  RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();</div><div class="line">  <span class="comment">//内容协调管理器</span></div><div class="line">  <span class="comment">//此类中有一个方法：resolveMediaTypes</span></div><div class="line">  adapter.setContentNegotiationManager(mvcContentNegotiationManager());</div><div class="line">  adapter.setMessageConverters(getMessageConverters());</div><div class="line">  adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());</div><div class="line">  adapter.setCustomArgumentResolvers(getArgumentResolvers());</div><div class="line">  adapter.setCustomReturnValueHandlers(getReturnValueHandlers());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (jackson2Present) &#123;</div><div class="line">    adapter.setRequestBodyAdvice(Collections.singletonList(<span class="keyword">new</span> JsonViewRequestBodyAdvice()));</div><div class="line">    adapter.setResponseBodyAdvice(Collections.singletonList(<span class="keyword">new</span> JsonViewResponseBodyAdvice()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  AsyncSupportConfigurer configurer = <span class="keyword">new</span> AsyncSupportConfigurer();</div><div class="line">  configureAsyncSupport(configurer);</div><div class="line">  <span class="keyword">if</span> (configurer.getTaskExecutor() != <span class="keyword">null</span>) &#123;</div><div class="line">    adapter.setTaskExecutor(configurer.getTaskExecutor());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (configurer.getTimeout() != <span class="keyword">null</span>) &#123;</div><div class="line">    adapter.setAsyncRequestTimeout(configurer.getTimeout());</div><div class="line">  &#125;</div><div class="line">  adapter.setCallableInterceptors(configurer.getCallableInterceptors());</div><div class="line">  adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());</div><div class="line"></div><div class="line">  <span class="keyword">return</span> adapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>org.springframework.http.converter.json.MappingJackson2HttpMessageConverter#MappingJackson2HttpMessageConverter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MappingJackson2HttpMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</div><div class="line">     <span class="keyword">super</span>(objectMapper, <span class="keyword">new</span> MediaType[]&#123;MediaType.APPLICATION_JSON, <span class="keyword">new</span> MediaType(<span class="string">"application"</span>, <span class="string">"*+json"</span>)&#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="扩展自描述消息"><a href="#扩展自描述消息" class="headerlink" title="扩展自描述消息"></a>扩展自描述消息</h3><p><code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#getMessageConverters</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; getMessageConverters() &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="comment">//扩展点</span></div><div class="line">    <span class="comment">//有没有自定义配置</span></div><div class="line">    configureMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">    <span class="comment">//如果没有</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageConverters.isEmpty()) &#123;</div><div class="line">      <span class="comment">//加载默认配置</span></div><div class="line">      addDefaultHttpMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">    &#125;</div><div class="line">    extendMessageConverters(<span class="keyword">this</span>.messageConverters);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.messageConverters;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="一次失败的试验"><a href="#一次失败的试验" class="headerlink" title="一次失败的试验"></a>一次失败的试验</h4><ul><li>创建类，继承WebMvcConfigurer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.config;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Configurable;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">        converters.add(<span class="keyword">new</span> MappingJackson2HttpMessageConverter());</div><div class="line">        <span class="comment">//converters:[org.springframework.http.converter.json.MappingJackson2HttpMessageConverter@317a118b]</span></div><div class="line">        System.err.println(<span class="string">"converters:"</span>+converters);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>但是，经debug发现，<code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#getMessageConverters</code>方法内，判断<code>this.messageConverters.isEmpty()</code>为true，还是加载了默认配置，这可能是个bug。其实扩展已经加载成功了，可能在某一地方又清空了。</li></ul><h4 id="这次是成功的"><a href="#这次是成功的" class="headerlink" title="这次是成功的"></a>这次是成功的</h4><h5 id="添加扩展"><a href="#添加扩展" class="headerlink" title="添加扩展"></a>添加扩展</h5><ul><li>把默认实现的方法<code>configureMessageConverters</code>换为<code>extendMessageConverters</code></li><li>debug发现，在加载默认配置后，自定义配置已经加载成功。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.config;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object object;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">      <span class="comment">//加载自定义配置</span></div><div class="line">        converters.add(<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="调整顺序"><a href="#调整顺序" class="headerlink" title="调整顺序"></a>调整顺序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.config;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object object;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">      <span class="comment">//将自定义配置添加到最前</span></div><div class="line">        converters.set(<span class="number">0</span>,<span class="keyword">new</span> MappingJackson2XmlHttpMessageConverter());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代码示例-完整版"><a href="#代码示例-完整版" class="headerlink" title="代码示例-完整版"></a>代码示例-完整版</h3><ul><li>POJO类—<code>Person</code></li><li>扩展处理类—<code>PropertiesPersonHttpMessageConverter</code></li><li>配置类—<code>WebMvcConfig</code></li><li>Controller—<code>PersonRestController</code></li></ul><blockquote><p> 反序列化：JSON -&gt; MappingJackson2HttpMessageConverter把文本转化为Person对象</p><p> 序列化 Person对象 -&gt; <code>PropertiesPersonHttpMessageConverter#write</code>-&gt;Properties文本</p></blockquote><ul><li>如果请求中accept中和produces不一样，controller是不能执行的，会返回HTTP 状态码406</li><li>并不一定需要POJO，这么做是简化操作<ul><li>JSON -&gt; 反序列化 -&gt; Map -&gt; Properties</li><li>增加了操作的复杂度</li></ul></li></ul><h4 id="Person"><a href="#Person" class="headerlink" title="Person"></a><code>Person</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.domain;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="PropertiesPersonHttpMessageConverter"><a href="#PropertiesPersonHttpMessageConverter" class="headerlink" title="PropertiesPersonHttpMessageConverter"></a><code>PropertiesPersonHttpMessageConverter</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.http.message;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.bai.restonwebwebmvc.domain.Person;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</div><div class="line"><span class="keyword">import</span> org.springframework.http.HttpOutputMessage;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.AbstractHttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotReadableException;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageNotWritableException;</div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.nio.charset.Charset;</div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesPersonHttpMessageConverter</span> <span class="keyword">extends</span> <span class="title">AbstractHttpMessageConverter</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PropertiesPersonHttpMessageConverter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//设置支持的自定义媒体类型</span></div><div class="line">        <span class="keyword">super</span>(MediaType.valueOf(<span class="string">"application/properties+person"</span>));</div><div class="line">        setDefaultCharset(Charset.forName(<span class="string">"UTF-8"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否支持当前POJO类型</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</div><div class="line">        <span class="comment">//必须是Person的子类</span></div><div class="line">        <span class="keyword">return</span> clazz.isAssignableFrom(Person.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将HTTP请求中的内容，并将内容转化成响应的POJO对象</span></div><div class="line"><span class="comment">     * properties -&gt; Person</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> HttpMessageNotReadableException</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Person <span class="title">readInternal</span><span class="params">(Class&lt;? extends Person&gt; clazz, HttpInputMessage inputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotReadableException </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * person.id=1</span></div><div class="line"><span class="comment">         * person.name=2bai</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="comment">//请求体</span></div><div class="line">        InputStream inputStream=inputMessage.getBody();</div><div class="line">        Properties properties=<span class="keyword">new</span> Properties();</div><div class="line"></div><div class="line">        <span class="comment">//将请求中的内容转化成properties</span></div><div class="line">        properties.load(<span class="keyword">new</span> InputStreamReader(inputStream,getDefaultCharset()));</div><div class="line"></div><div class="line">        <span class="comment">//将properties内容转化到Person字段中</span></div><div class="line">        Person person=<span class="keyword">new</span> Person();</div><div class="line">        person.setId(Long.valueOf(properties.getProperty(<span class="string">"person.id"</span>)));</div><div class="line">        person.setName(properties.getProperty(<span class="string">"person.name"</span>));</div><div class="line">        <span class="keyword">return</span> person;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将POJO内容序列化成文本内容，最终输出到响应中</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> outputMessage</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> HttpMessageNotWritableException</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeInternal</span><span class="params">(Person person, HttpOutputMessage outputMessage)</span> <span class="keyword">throws</span> IOException, HttpMessageNotWritableException </span>&#123;</div><div class="line">        OutputStream outputStream=outputMessage.getBody();</div><div class="line">        Properties properties=<span class="keyword">new</span> Properties();</div><div class="line">        properties.setProperty(<span class="string">"person.id"</span>,String.valueOf(person.getId()));</div><div class="line">        properties.setProperty(<span class="string">"person.name"</span>,person.getName());</div><div class="line">        properties.store(<span class="keyword">new</span> OutputStreamWriter(outputStream,getDefaultCharset()),<span class="string">"Written By Application Server"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="WebMvcConfig"><a href="#WebMvcConfig" class="headerlink" title="WebMvcConfig"></a><code>WebMvcConfig</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.config;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> com.bai.restonwebwebmvc.http.message.PropertiesPersonHttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</div><div class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</div><div class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2017.11.28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extendMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</div><div class="line">        converters.add(<span class="keyword">new</span> PropertiesPersonHttpMessageConverter());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="PersonRestController"><a href="#PersonRestController" class="headerlink" title="PersonRestController"></a><code>PersonRestController</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.restonwebwebmvc.controller;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.bai.restonwebwebmvc.domain.Person;</div><div class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> &#125; &#123;<span class="doctag">@link</span> org.springframework.web.bind.annotation.RestController&#125;</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span> 2bai</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span> 2017.11.28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRestController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * required = false,参数不强制传输</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/person/&#123;id&#125;"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">(@PathVariable Long id, @RequestParam(required = <span class="keyword">false</span>)</span> String name )</span>&#123;</div><div class="line">        Person person=<span class="keyword">new</span> Person();</div><div class="line">        person.setId(id);</div><div class="line">        person.setName(name);</div><div class="line">        <span class="keyword">return</span> person;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * value    : 路径</span></div><div class="line"><span class="comment">     * consumes ：请求类型 Content-Type</span></div><div class="line"><span class="comment">     * produces ：响应类型 Accept</span></div><div class="line"><span class="comment">     * input :</span></div><div class="line"><span class="comment">     * &#123;</span></div><div class="line"><span class="comment">        "id": 1,</span></div><div class="line"><span class="comment">        "name": "2bai"</span></div><div class="line"><span class="comment">       &#125;</span></div><div class="line"><span class="comment">       output:</span></div><div class="line"><span class="comment">        #Written By Application Server</span></div><div class="line"><span class="comment">        #Tue Nov 28 16:22:48 CST 2017</span></div><div class="line"><span class="comment">        person.name=2bai</span></div><div class="line"><span class="comment">        person.id=1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@PostMapping</span>(value=<span class="string">"/person/json/to/properties"</span>,</div><div class="line">            consumes = MediaType.APPLICATION_JSON_UTF8_VALUE,</div><div class="line">            produces = <span class="string">"application/properties+person"</span></div><div class="line">    )</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personJsonToProperties</span><span class="params">(@RequestBody Person person)</span></span>&#123;</div><div class="line">        <span class="comment">//@RequestBody读取的是JSON格式</span></div><div class="line">        <span class="comment">//响应的格式是proerties</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> person;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * value    : 路径</span></div><div class="line"><span class="comment">     * consumes ：请求类型 Content-Type</span></div><div class="line"><span class="comment">     * produces ：响应类型 Accept</span></div><div class="line"><span class="comment">     * input :</span></div><div class="line"><span class="comment">     person.name=2bai</span></div><div class="line"><span class="comment">     person.id=1</span></div><div class="line"><span class="comment">     output:</span></div><div class="line"><span class="comment">     &#123;</span></div><div class="line"><span class="comment">     "id": 1,</span></div><div class="line"><span class="comment">     "name": "2bai"</span></div><div class="line"><span class="comment">     &#125;</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@PostMapping</span>(value=<span class="string">"/person/properties/to/json"</span>,</div><div class="line">            consumes = <span class="string">"application/properties+person"</span>,</div><div class="line">            produces = MediaType.APPLICATION_JSON_UTF8_VALUE</div><div class="line">    )</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">personPropertiesToJson</span><span class="params">(@RequestBody Person person)</span></span>&#123;</div><div class="line">        <span class="comment">//@RequestBody读取的是proerties</span></div><div class="line">        <span class="comment">//响应的格式是JSON格式</span></div><div class="line">        <span class="keyword">return</span> person;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li>HttpMessageConverter执行逻辑<ul><li>读操作<ul><li>尝试是否能读取，canRead方法去尝试，如果返回true，下一步执行read</li></ul></li><li>写操作<ul><li>尝试是否能写入，canWrite方法去尝试，如果返回true，下一步执行write</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AIO概述</title>
      <link href="/IO/AIO.html"/>
      <url>/IO/AIO.html</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><a id="more"></a><ul><li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="_blank" rel="external">Java AIO (Asynchronous IO)</a><ul><li>jdk1.7(NIO2)才是真正的异步AIO</li><li>把IO读写操作完全交给操作系统</li><li>学习了linux的epoll模式</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>类<ul><li>服务端：<code>AsynchronousServerSocketChannel</code></li><li>客户端：<code>AsynchronousSocketChannel</code></li><li>用户处理器：<code>CompletionHandler</code>接口<ul><li>实现应用程序向操作系统发起IO请求，当完成后处理具体逻辑，否则做自己该做的事情</li></ul></li></ul></li></ul><p>异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态通知给用户线程，由用户线程自行读取数据、处理数据。</p><p>而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p>异步IO模型使用了Proactor设计模式实现了这一机制。</p><h3 id="NIO-amp-AIO-对比"><a href="#NIO-amp-AIO-对比" class="headerlink" title="NIO &amp; AIO 对比"></a>NIO &amp; AIO 对比</h3><table><thead><tr><th>属性</th><th>同步阻塞IO(BIO)</th><th>伪异步IO</th><th>非阻塞IO(NIO)</th><th>异步IO(AIO)</th></tr></thead><tbody><tr><td>客户端数：IO线程数</td><td>1:1</td><td>M:N(M&gt;N)</td><td>M:1</td><td>M:0</td></tr><tr><td>阻塞类型</td><td>阻塞</td><td>阻塞</td><td>非阻塞</td><td>非阻塞</td></tr><tr><td>同步</td><td>同步</td><td>同步</td><td>同步(多路复用)</td><td>异步</td></tr><tr><td>API使用难度</td><td>简单</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>调试难度</td><td>简单</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>非常差</td><td>差</td><td>高</td><td>高</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><code>Server</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOServer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT = <span class="number">8001</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String IP = <span class="string">"127.0.0.1"</span>;</div><div class="line"><span class="keyword">private</span> AsynchronousServerSocketChannel server = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AIOServer</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//同样是利用工厂方法产生一个通道，异步通道 AsynchronousServerSocketChannel</span></div><div class="line">server = AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(IP,PORT));</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用这个通道(server)来进行客户端的接收和处理</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</div><div class="line">System.out.println(<span class="string">"Server listen on "</span>+PORT);</div><div class="line"><span class="comment">//注册事件和事件完成后的处理器，这个CompletionHandler就是事件完成后的处理器</span></div><div class="line">server.accept(<span class="keyword">null</span>,<span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel,Object&gt;()&#123;</div><div class="line"><span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result,Object attachment)</span> </span>&#123;</div><div class="line">Future&lt;Integer&gt; writeResult = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">buffer.clear();</div><div class="line">result.read(buffer).get(<span class="number">100</span>,TimeUnit.SECONDS);</div><div class="line">System.out.println(<span class="string">"In server: "</span>+ <span class="keyword">new</span> String(buffer.array()));</div><div class="line"><span class="comment">//将数据写回客户端</span></div><div class="line">buffer.flip();</div><div class="line">writeResult = result.write(ByteBuffer.wrap(<span class="string">"hi"</span>.getBytes()));</div><div class="line">&#125;<span class="keyword">catch</span>(InterruptedException | ExecutionException | TimeoutException e)&#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;<span class="keyword">finally</span>&#123;</div><div class="line">server.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">System.out.println(writeResult.get());</div><div class="line">result.close();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"failed:"</span>+exc);</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"><span class="keyword">new</span> AIOServer().start();</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Client</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</div><div class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIOClient</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">final</span> AsynchronousSocketChannel client = AsynchronousSocketChannel.open();</div><div class="line"></div><div class="line">InetSocketAddress serverAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8001</span>);</div><div class="line"></div><div class="line">CompletionHandler&lt;Void, ? <span class="keyword">super</span> Object&gt; handler = <span class="keyword">new</span> CompletionHandler&lt;Void, Object&gt;() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Object attachment)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">client.write(ByteBuffer.wrap(<span class="string">"hello"</span>.getBytes()), <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</div><div class="line"><span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">buffer.flip();</div><div class="line">System.out.println(<span class="string">"In client: "</span>+<span class="keyword">new</span> String(buffer.array()));</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line">&#125;); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">client.connect(serverAddress, <span class="keyword">null</span>, handler);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO原理</title>
      <link href="/IO/NIO.html"/>
      <url>/IO/NIO.html</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><a id="more"></a><h4 id="阻塞Block和非阻塞Non-Block"><a href="#阻塞Block和非阻塞Non-Block" class="headerlink" title="阻塞Block和非阻塞Non-Block"></a>阻塞Block和非阻塞Non-Block</h4><blockquote><p>进程在访问数据的时候，<strong>数据是否准备就绪</strong>的一种处理方式。</p><ul><li>当数据没有准备的时候<ul><li>阻塞<ul><li>往往需要等待缓冲区中的数据准备好过后才处理其它的事情，否则一直等待</li></ul></li><li>非阻塞<ul><li>直接返回，不回等待。</li></ul></li></ul></li></ul></blockquote><table><thead><tr><th>IO模型</th><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>方式</td><td>从硬盘到内存</td><td>从内存到硬盘</td></tr><tr><td>通信</td><td>面向流(乡村公路)</td><td>面向缓冲区(高速公路，多路复用技术)</td></tr><tr><td>处理</td><td>阻塞IO(多线程)</td><td>非阻塞IO(反应堆Reactor)</td></tr><tr><td>触发</td><td>无</td><td>选择器(轮循机制)</td></tr></tbody></table><blockquote><ul><li>流<ul><li>每次从流中读一个或多个字节，直至读取所有字节，没有被缓存在任何地方。</li><li>不能前后移动流中的数据<ul><li>需要移动从流中读区的数据，需要先将它缓存到一个缓冲区</li></ul></li></ul></li><li>缓冲<ul><li>数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动<ul><li>增加了处理过程中的灵活性</li><li>需检查是否该缓冲区中包含所有需要处理的数据</li><li>需确保当跟多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据</li></ul></li></ul></li></ul></blockquote><h4 id="同步Synchronization和异步Asynchronous"><a href="#同步Synchronization和异步Asynchronous" class="headerlink" title="同步Synchronization和异步Asynchronous"></a>同步Synchronization和异步Asynchronous</h4><blockquote><p>基于应用程序和操作系统<strong>处理IO事件</strong>所采用的方式。</p><ul><li>同步<ul><li>应用程序直接参与IO读写的操作</li><li>处理IO事件时，必须阻塞在某个方法上等待IO事件完成</li><li>阻塞IO事件或者通过轮询IO事件的方式</li><li>阻塞到IO事件，阻塞到read或者write，不能做其它事情</li><li>读写方法加入到线程里面，通过阻塞线程来实现，对线程的性能开销比较大</li></ul></li><li>异步<ul><li>所有的IO读写交给操作系统去处理，应用程序需要等待通知时，可以去做其它事情</li></ul></li></ul></blockquote><h4 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h4><blockquote><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道。</p><p>这些通道里已经有可以处理的输入或者选择已准备写入的通道。</p><p>这种选择机制，使得一个单独的线程很容易来管理多个通道。</p></blockquote><h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><ul><li>对NIO或IO类的API调用</li><li>数据处理</li><li>用来处理数据的线程数<ul><li>NIO<ul><li>只使用一个或几个单线程管理多个通道（网络连接或文件）</li><li>代价是解析数据可能会从一个阻塞流中读取更复杂</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流方式</span></div><div class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d://info.txt"</span>);</div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input)); </div><div class="line"><span class="comment">//返回时数据已经读完</span></div><div class="line"><span class="comment">//仅在有新数据读入时才运行，并不知道每步的数据时什么</span></div><div class="line"><span class="comment">//一旦正在运行的线程一处理过读入的某些数据</span></div><div class="line"><span class="comment">//该线程不会再回退数据</span></div><div class="line"><span class="comment">//Stream&lt;-Thread</span></div><div class="line">String nameLine = reader.readLine();</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//缓冲</span></div><div class="line"><span class="comment">//Channel--(fill data)-&gt;Buffer&lt;--(check data)-Thread</span></div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</div></pre></td></tr></table></figure><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><ul><li>NIO<ul><li>数据先读入缓冲区再处理</li></ul></li><li>IO<ul><li>从一个InputStream/Reader逐字节读取</li></ul></li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">Java NIO</a></h3><ul><li>Java 1.4</li><li>面向Block</li></ul><h4 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h4><ul><li>缓冲区Buffer</li><li>通道Channel</li><li>选择器Selector</li></ul><h4 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/Buffer.html" target="_blank" rel="external">缓冲区Buffer</a></h4><blockquote><p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。NIO库中，所有数据都是用缓冲区处理的。从缓冲区读，写入到缓冲区。</p><p>所有的缓冲区类型都继承于抽象类Buffer。</p></blockquote><ul><li>Buffer<ul><li>ByteBuffer<ul><li>MappedByteBuffer</li></ul></li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.IntBuffer;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntBuffer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">// 分配新的 int 缓冲区，参数为缓冲区容量</span></div><div class="line">      <span class="comment">// 新缓冲区的当前位置将为零，其界限(限制位置)将为其容量。它将具有一个底层实现数组， 其数组偏移量将为零。</span></div><div class="line">      IntBuffer buffer = IntBuffer.allocate(<span class="number">8</span>);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123; </div><div class="line">          <span class="keyword">int</span> j = <span class="number">2</span> * (i + <span class="number">1</span>);</div><div class="line">          <span class="comment">// 将给定整数写入此缓冲区的当前位置，当前位置递增 </span></div><div class="line">          buffer.put(j);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为 0 </span></div><div class="line">      buffer.flip();</div><div class="line">      <span class="comment">// 查看在当前位置和限制位置之间是否有元素 </span></div><div class="line">      <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">          <span class="comment">// 读取此缓冲区当前位置的整数，然后当前位置递增 </span></div><div class="line">          <span class="keyword">int</span> j = buffer.get();</div><div class="line">          <span class="comment">// 2 4 6 8 10 12 14 16 </span></div><div class="line">          System.out.print(j + <span class="string">" "</span>);</div><div class="line">      &#125;</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="深入剖析Buffer"><a href="#深入剖析Buffer" class="headerlink" title="深入剖析Buffer"></a>深入剖析Buffer</h5><blockquote><p>一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用 get()方法从缓冲区获取数据，或者使用 put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p></blockquote><p><strong>重要属性</strong></p><ul><li>position<ul><li>指定了下一个将要被写入或者读取的元素索引</li><li>它的值由 get()/put()方法自动更新</li><li>在新创建一个Buffer对象时，position被初始化为0。</li></ul></li><li>limit<ul><li>指定还有多少数据需要取出(在从缓冲区写入通道时)</li><li>或者还有多少空间可以放入数据(在从通道读入缓冲区时)</li></ul></li><li>capacity<ul><li>指定了可以存储在缓冲区中的最大数据容量</li><li>实际上，它指定了底层数据的大小</li><li>或者至少是指定了准许使用的底层数组的容量</li></ul></li></ul><p><strong>0 &lt;=position&lt;=limit&lt;=capacity</strong></p><p><strong>都是在JVM允许范围内</strong></p><p>例子：</p><ul><li>创建一个新的容量大小为10的ByteBuffer对象<ul><li>初始化时<ul><li>position为0</li><li>limit和capacity被设置为10</li></ul></li><li>使用过程中<ul><li>capacity不会发生变化</li><li>position和limit会变化</li></ul></li><li>读取4个数据<ul><li>从通道读取数据，相当于往缓冲区中写入数据</li><li>position为4<ul><li>下一个将要被写入的字节索引为4</li></ul></li><li>limit依旧为10</li></ul></li><li>读取的数据写入到通道中，相当于从缓冲区中读取数据<ul><li>调用flip()<ul><li>把limit设置为当前的position值<ul><li>保证读取的数据正好是之前写入到缓冲区中的数据</li></ul></li><li>把position设置为0<ul><li>可以保证在下一步输出时读取到的是缓冲区的第一个字节</li></ul></li></ul></li><li>调用get()<ul><li>从缓冲区中读取数据写入到输出通道</li><li>position增加</li><li>limit不变</li><li>position不会超过limit</li></ul></li><li>读取之前写入到缓冲区的4个字节之后<ul><li>position和limit都为4</li></ul></li><li>从缓冲区读取数据完毕后<ul><li>limit的值仍然保持在调用flip()方法时的值</li></ul></li></ul></li><li>调用clear()能够把所有的状态变化设置为初始化时的值</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.nio.*;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * output:</span></div><div class="line"><span class="comment">初始化 : </span></div><div class="line"><span class="comment">capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">调用 read() : </span></div><div class="line"><span class="comment">capacity: 10, position: 10, limit: 10</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">调用 flip() : </span></div><div class="line"><span class="comment">capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">调用 get() : </span></div><div class="line"><span class="comment">capacity: 10, position: 10, limit: 10</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">调用 clear() : </span></div><div class="line"><span class="comment">capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">FileChannel fc = fin.getChannel();</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">output(<span class="string">"初始化"</span>, buffer);</div><div class="line">fc.read(buffer);</div><div class="line">output(<span class="string">"调用 read()"</span>, buffer);</div><div class="line">buffer.flip();</div><div class="line">output(<span class="string">"调用 flip()"</span>, buffer);</div><div class="line"><span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">byte</span> b = buffer.get();</div><div class="line"><span class="comment">// System.out.print(((char)b));</span></div><div class="line">&#125;</div><div class="line">output(<span class="string">"调用 get()"</span>, buffer);</div><div class="line"></div><div class="line">buffer.clear();</div><div class="line">output(<span class="string">"调用 clear()"</span>, buffer);</div><div class="line">fin.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String step, Buffer buffer)</span> </span>&#123;</div><div class="line">System.out.println(step + <span class="string">" : "</span>);</div><div class="line">System.out.print(<span class="string">"capacity: "</span> + buffer.capacity() + <span class="string">", "</span>);</div><div class="line">System.out.print(<span class="string">"position: "</span> + buffer.position() + <span class="string">", "</span>);</div><div class="line">System.out.println(<span class="string">"limit: "</span> + buffer.limit());</div><div class="line">System.out.println();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="缓冲区的分配"><a href="#缓冲区的分配" class="headerlink" title="缓冲区的分配"></a>缓冲区的分配</h5><blockquote><p>在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量。其实调用allocate（）相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。也可以直接将一个的数组，包装为缓冲区对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferWrap</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配指定大小的缓冲区</span></div><div class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">    <span class="comment">// 包装一个现有的数组</span></div><div class="line">    <span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">    ByteBuffer buffer2 = ByteBuffer.wrap( array );</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h5><blockquote><p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区。</p><p>现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的。</p><p>子缓冲区相当于是现有缓冲区的一个视图窗口。</p><p>调用slice()可以创建一个子缓冲区。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">0</span></div><div class="line"><span class="comment">1</span></div><div class="line"><span class="comment">2</span></div><div class="line"><span class="comment">30</span></div><div class="line"><span class="comment">40</span></div><div class="line"><span class="comment">50</span></div><div class="line"><span class="comment">60</span></div><div class="line"><span class="comment">7</span></div><div class="line"><span class="comment">8</span></div><div class="line"><span class="comment">9</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">  <span class="comment">// 缓冲区中的数据 0-9</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    buffer.put((<span class="keyword">byte</span>) i);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 创建子缓冲区</span></div><div class="line">  buffer.position(<span class="number">3</span>);</div><div class="line">  buffer.limit(<span class="number">7</span>);</div><div class="line">  ByteBuffer slice = buffer.slice();</div><div class="line">  <span class="comment">// 改变子缓冲区的内容</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slice.capacity(); ++i) &#123;</div><div class="line">    <span class="keyword">byte</span> b = slice.get(i);</div><div class="line">    b *= <span class="number">10</span>;</div><div class="line">    slice.put(i, b);</div><div class="line">  &#125;</div><div class="line">  buffer.position(<span class="number">0</span>);</div><div class="line">  buffer.limit(buffer.capacity());</div><div class="line">  <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(buffer.get());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h5><blockquote><p>只能读取，不能写入。</p><p>通过调用asReadOnlyBuffer()，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过是只读的。</p><p>如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化。</p><p>常规缓冲区可以转换为只读缓冲区，<br>只读缓冲区不能转换为常规缓冲区。</p><p>常用于控制权限（回调方法），比如：在将缓冲区的引用传递给某个对象的方法时，你无法确定这个方法是否会修改缓冲区中的数据，这个时候，就可以创建一个只读缓冲区，然后把只读缓冲区的引用传递给那个方法，这样就能保证，使用那个方法的人没办法去修改缓冲区中的数据了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">  <span class="comment">// 缓冲区中的数据 0-9</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    buffer.put((<span class="keyword">byte</span>) i);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 创建只读缓冲区</span></div><div class="line">  ByteBuffer readonly = buffer.asReadOnlyBuffer();</div><div class="line">  <span class="comment">// 改变原缓冲区的内容</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    <span class="keyword">byte</span> b = buffer.get(i);</div><div class="line">    b *= <span class="number">10</span>;</div><div class="line">    buffer.put(i, b);</div><div class="line">  &#125;</div><div class="line">  readonly.position(<span class="number">0</span>);</div><div class="line">  readonly.limit(buffer.capacity());</div><div class="line">  <span class="comment">// 只读缓冲区的内容也随之改变</span></div><div class="line">  <span class="keyword">while</span> (readonly.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(readonly.get());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html" target="_blank" rel="external">通道Channel</a></h4><blockquote><ul><li>通道是一个对象，可以读取和写入数据。</li><li>所有数据都通过Buffer对象来处理，不会将字节直接写入通道或直接从通道中读取数据。</li><li>所有的通道对象都实现了Channel接口。</li></ul></blockquote><h5 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h5><ul><li>从FileInputStream获取Channel</li><li>创建Buffer</li><li>将数据从Channel读取到Buffer中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">  FileInputStream fin = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    fin = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">    <span class="comment">// 获取通道</span></div><div class="line">    FileChannel fc = fin.getChannel(); <span class="comment">// 创建缓冲区</span></div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 读取数据到缓冲区</span></div><div class="line">    fc.read(buffer);</div><div class="line">    buffer.flip();</div><div class="line">    <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">byte</span> b = buffer.get();</div><div class="line">      System.out.print(((<span class="keyword">char</span>) b));</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      fin.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="使用NIO写入数据"><a href="#使用NIO写入数据" class="headerlink" title="使用NIO写入数据"></a>使用NIO写入数据</h5><ul><li>从FileInputStream获取Channel</li><li>创建Buffer</li><li>将数据从Channel写入到Buffer中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">  FileChannel fc = fout.getChannel();</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">  buffer.put(Charset.forName(<span class="string">"utf8"</span>).encode(<span class="string">"你好你好你好你好你好"</span>));</div><div class="line">  buffer.flip();</div><div class="line">  fc.write(buffer);</div><div class="line">  fout.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="反应堆Reactor"><a href="#反应堆Reactor" class="headerlink" title="反应堆Reactor"></a><a href="http://kasunpanorama.blogspot.com/2015/04/understanding-reactor-pattern-with-java.html" target="_blank" rel="external">反应堆Reactor</a></h4><h5 id="阻塞I-O通信模型"><a href="#阻塞I-O通信模型" class="headerlink" title="阻塞I/O通信模型"></a>阻塞I/O通信模型</h5><p><strong>缺点</strong></p><ul><li>当客户端多时，会创建大量的处理线程，且每个线程都要占用栈空间和CPU时间</li><li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。在这种情况下非阻塞I/O就又了它的应用前景</li></ul><h5 id="Java-NIO原理及通信模型"><a href="#Java-NIO原理及通信模型" class="headerlink" title="Java NIO原理及通信模型"></a>Java NIO原理及通信模型</h5><ul><li>由一个专门的线程来处理所有的IO事件，并负责分发</li><li>事件驱动机制<ul><li>事件到的时候触发，而不是同步的去监视事件</li></ul></li><li>线程通讯<ul><li>线程之间通过wait、notify等方式通讯</li><li>保证每次上下文切换都是有意义的，减少无谓的线程切换</li></ul></li></ul><p><strong>客户端—&gt;Reactor(分发wait/notify)—&gt;处理线程N(read、decode、compute、encode、send)</strong></p><p>每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送相应。</p><h4 id="选择器Seletor"><a href="#选择器Seletor" class="headerlink" title="选择器Seletor"></a><a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/Selector.html" target="_blank" rel="external">选择器Seletor</a></h4><p>传统的Server/Client模式会基于TPR(Thread per Request)，服务器会为每个客户端请求建立一个线程，由该线程单独处理一个客户请求。</p><p>问题：线程数量的剧增，大量线程会增大服务器开销。</p><p>解决：线程池。</p><p>产生问题：线程池中的线程都在处理，超过线程池数量的请求无法处理。</p><blockquote><p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，可以注册感兴趣的特定I/O事件，如可读数据到达，新的Socket连接等等，在发生特定事件时，系统再通知。</p><p>NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件的地方。而且当事件发生时，就是Selector告诉所发生的事件。</p><p>当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectorKey，同事从SelectorKey中可以找到发生的事件和该事件所发生的具体SelectableChannel，以获得客户端发送过来的数据。</p><p>Select是NIO的核心，底层使用epoll模型。 </p></blockquote><ul><li>使用NIO中非阻塞I/O编写服务器处理程序<ul><li>向Selector对象注册感兴趣的事件</li><li>从Selector中获得去感兴趣的事件</li><li>根据不同的事件进行相应的处理</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">关键点：</span></div><div class="line"><span class="comment">1.创建一个ServerSocketChannel，和一个Selector，并且把这个server channel 注册到 selector上，注册的时间指定，这个channel 所感觉兴趣的事件是 SelectionKey.OP_ACCEPT，这个事件代表的是有客户端发起TCP连接请求。</span></div><div class="line"><span class="comment">2.使用 select 方法阻塞住线程，当select 返回的时候，线程被唤醒。再通过selectedKeys方法得到所有可用channel的集合。</span></div><div class="line"><span class="comment">3.遍历这个集合，如果其中channel 上有连接到达，就接受新的连接，然后把这个新的连接也注册到selector中去。</span></div><div class="line"><span class="comment">4.如果有channel是读，那就把数据读出来，并且把它感兴趣的事件改成写。如果是写，就把数据写出去，并且把感兴趣的事件改成读。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 注册事件</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// 创建 Selector 对象</span></div><div class="line">  Selector sel = Selector.open();</div><div class="line">  <span class="comment">// 创建可选择通道</span></div><div class="line">  ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line">  <span class="comment">// 配置为非阻塞模式</span></div><div class="line">  server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">  <span class="comment">// 绑定通道到指定端口</span></div><div class="line">  ServerSocket socket = server.socket();</div><div class="line">  InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">  socket.bind(address);</div><div class="line">  <span class="comment">// 向 Selector 中注册感兴趣的事件(监听accept事件)</span></div><div class="line">  <span class="comment">// 新的连接发生时所产生的事件</span></div><div class="line">  <span class="comment">// OP option</span></div><div class="line">  server.register(sel, SelectionKey.OP_ACCEPT);</div><div class="line">  <span class="keyword">return</span> sel;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 开始监听</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">  System.out.println(<span class="string">"listen on "</span> + port);</div><div class="line">  <span class="comment">// 非阻塞I/O中，内部循环模式基本都是遵循这种方式</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="comment">// 该调用会阻塞，直到至少有一个事件发生</span></div><div class="line">      selector.select();</div><div class="line">      <span class="comment">// 获取发生事件的SelectionKey</span></div><div class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">      <span class="comment">// 迭代器循环</span></div><div class="line">      Iterator&lt;SelectionKey&gt; iter = keys.iterator();</div><div class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">        SelectionKey key = (SelectionKey) iter.next();</div><div class="line">        iter.remove();</div><div class="line">        process(key);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 根据不同的事件做处理</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123; </div><div class="line">  <span class="comment">// 接收请求</span></div><div class="line">  <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">    ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">    SocketChannel channel = server.accept();</div><div class="line">    channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">    channel.register(selector, SelectionKey.OP_READ);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 读信息</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    <span class="keyword">int</span> len = channel.read(buffer);</div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</div><div class="line">      buffer.flip();</div><div class="line">      String name = <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len);</div><div class="line">      SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);</div><div class="line">      sKey.attach(name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      channel.close();</div><div class="line">    &#125;</div><div class="line">    buffer.clear();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 写事件</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    String name = (String) key.attachment();</div><div class="line">    ByteBuffer block = ByteBuffer.wrap((<span class="string">"Hello "</span> + name).getBytes());</div><div class="line">    <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">      channel.write(block);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      channel.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>类</p><p><code>FileChannel</code></p><p><code>ServerSocketchannel</code></p><p><code>SocketChannel</code></p><p><code>ByteBuffer</code></p><p><code>MappedByteBuffer</code></p><p>方法</p><p><code>wrap</code></p><p><code>slice</code></p><p><code>allocate</code></p><p><code>allocateDirect</code></p><p><code>asReadOnlyBuffer</code></p><p>动态改变position的值(油表)</p><p><code>put</code></p><p><code>get</code></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/6-b27/" target="_blank" rel="external">源码分析</a></h3><h4 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open()"></a><code>Selector.open()</code></h4><p><code>java.nio.channels.Selector#open</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">return</span> SelectorProvider.provider().openSelector();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Selector</code>是调用的<code>SelectorProvider.provider()</code>拿到的<code>provider</code>对象创建的<code>ServerSocketChannel</code>，上文的<code>Selector</code>、<code>Pipe</code>都是通过这一个<code>provider</code>对象创建的。</p><p><code>java.nio.channels.spi.SelectorProvider#provider</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">    <span class="comment">//保证了整个server程序中只有一个provider对象</span></div><div class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</div><div class="line">      <span class="keyword">return</span> provider;</div><div class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">      <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (loadProviderFromProperty())</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">          <span class="keyword">if</span> (loadProviderAsService())</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">          <span class="comment">//会根据操作系统来返回不同的实现类</span></div><div class="line">          <span class="comment">//windows-&gt;WindowsSelectorProvider</span></div><div class="line">          provider = sun.nio.ch.DefaultSelectorProvider.create();</div><div class="line">          <span class="keyword">return</span> provider;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于windows操作系统来说他的实现类就是<code>WindowsSelectorProvider</code>，而<code>WindowsSelectorProvider</code>类中只是实现了<code>openSelector</code>方法。</p><p><code>WindowsSelectorProvider#openSelector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    <span class="comment">//和操作系统有关系</span></div><div class="line">    <span class="comment">//调用了操作系统底层的API</span></div><div class="line">    <span class="comment">// Windows -&gt; WindowsSelectorImpl</span></div><div class="line">    <span class="comment">// Mac     -&gt; KQueueSelectorImpl</span></div><div class="line">    <span class="comment">// Linux   -&gt; PollSelectorImpl</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>WindowsSelectorImpl(SelectorProvider)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">WindowsSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123; </div><div class="line"><span class="keyword">super</span>(sp);</div><div class="line">    <span class="comment">//pollWrapper保存selector上注册的FD</span></div><div class="line">    <span class="comment">//包括pipe的write端FD和ServerSocketChannel所用的FD</span></div><div class="line">pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</div><div class="line">    <span class="comment">//wakeupPipi:通道</span></div><div class="line">    <span class="comment">//其实就是两个FD：一个read、一个write</span></div><div class="line">    <span class="comment">//关键点</span></div><div class="line">wakeupPipe = Pipe.open();</div><div class="line">wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();</div><div class="line"><span class="comment">// Disable the Nagle algorithm so that the wakeup is more immediate</span></div><div class="line">SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();</div><div class="line">(sink.sc).socket().setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">wakeupSinkFd = ((SelChImpl)sink).getFDVal();</div><div class="line">pollWrapper.addWakeupSocket(wakeupSourceFd, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>java.nio.channels.Pipe#open</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">return</span> SelectorProvider.provider().openPipe();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.SelectorProviderImpl#openPipe</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Pipe <span class="title">openPipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PipeImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.PipeImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PipeImpl(SelectorProvider sp) &#123;</div><div class="line"><span class="keyword">int</span>[] fdes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    <span class="comment">//关键点</span></div><div class="line">IOUtil.initPipe(fdes, <span class="keyword">true</span>);</div><div class="line">FileDescriptor sourcefd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">IOUtil.setfdVal(sourcefd, fdes[<span class="number">0</span>]);</div><div class="line">source = <span class="keyword">new</span> SourceChannelImpl(sp, sourcefd);</div><div class="line">FileDescriptor sinkfd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">IOUtil.setfdVal(sinkfd, fdes[<span class="number">1</span>]);</div><div class="line">sink = <span class="keyword">new</span> SinkChannelImpl(sp, sinkfd);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.IOUtil#initPipe</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">initPipe</span><span class="params">(<span class="keyword">int</span>[] fda, <span class="keyword">boolean</span> blocking)</span></span>;</div></pre></td></tr></table></figure><p><code>solaris/native/sun/nio/ch/IOUtil.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</div><div class="line">Java_sun_nio_ch_IOUtil_initPipe(JNIEnv *env, jobject <span class="keyword">this</span>,</div><div class="line">                                    jintArray intArray, jboolean block)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">    jint *ptr = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Pipe failed"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (block == JNI_FALSE) &#123;</div><div class="line">        <span class="keyword">if</span> ((configureBlocking(fd[<span class="number">0</span>], JNI_FALSE) &lt; <span class="number">0</span>)</div><div class="line">            || (configureBlocking(fd[<span class="number">1</span>], JNI_FALSE) &lt; <span class="number">0</span>)) &#123;</div><div class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Configure blocking failed"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ptr = (*env)-&gt;GetPrimitiveArrayCritical(env, intArray, <span class="number">0</span>);</div><div class="line">    ptr[<span class="number">0</span>] = fd[<span class="number">0</span>];</div><div class="line">    ptr[<span class="number">1</span>] = fd[<span class="number">1</span>];</div><div class="line">    (*env)-&gt;ReleasePrimitiveArrayCritical(env, intArray, ptr, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="ServerSocketChannel-open"><a href="#ServerSocketChannel-open" class="headerlink" title="ServerSocketChannel.open()"></a><code>ServerSocketChannel.open()</code></h4><p><code>java.nio.channels.ServerSocketChannel#open</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>openServerSocketChannel</code>方法也和<code>openPipe</code>方法一样由父类<code>SelectorProviderImpl</code>来实现的</p><p><code>sun.nio.ch.SelectorProviderImpl#openServerSocketChannel</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ServerSocketChannelImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.ServerSocketChannelImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="comment">//调用父类的构造方法将SelectorProvider这个对象</span></div><div class="line">    <span class="comment">//初始化到父类的父类AbstractSelectableChannel中的</span></div><div class="line"><span class="keyword">super</span>(sp);</div><div class="line">    <span class="comment">//创建了一个文件描述符对象设置为成员属性，注意这里传入的参数是true</span></div><div class="line">    <span class="comment">//代表创建的ServerSocketChannel对应的文件描述符对象是阻塞的</span></div><div class="line"><span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</div><div class="line">    <span class="comment">//设置fdVal值，保存的是内核中文件当前文件描述符对象的index</span></div><div class="line"><span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</div><div class="line">    <span class="comment">//设置一个ServerSocketChannel的状态</span></div><div class="line"><span class="keyword">this</span>.state = ST_INUSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="server-configureBlocking-false"><a href="#server-configureBlocking-false" class="headerlink" title="server.configureBlocking(false);"></a><code>server.configureBlocking(false);</code></h4><p><code>java.nio.channels.spi.AbstractSelectableChannel#configureBlocking</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (regLock) &#123;</div><div class="line">    <span class="keyword">if</span> (!isOpen())</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">    <span class="keyword">if</span> (blocking == block)</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</div><div class="line">        <span class="comment">//关键点</span></div><div class="line">    implConfigureBlocking(block);</div><div class="line">    blocking = block;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.ServerSocketChannelImpl#implConfigureBlocking</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implConfigureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">//将当前ServerSocketChannel设置为非阻塞的模式</span></div><div class="line">IOUtil.configureBlocking(fd, block);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="server-socket"><a href="#server-socket" class="headerlink" title="server.socket();"></a><code>server.socket();</code></h4><p><code>sun.nio.ch.ServerSocketChannelImpl#socket</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (stateLock) &#123;</div><div class="line">      <span class="comment">//ServerSocketImpl中并没有看到创建ServerSocket对象的语句</span></div><div class="line">      <span class="comment">//所以if (socket == null)的判断肯定是返回的true</span></div><div class="line">      <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</div><div class="line">          socket = ServerSocketAdaptor.create(<span class="keyword">this</span>);</div><div class="line">      <span class="keyword">return</span> socket;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.ServerSocketAdaptor#create</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocket <span class="title">create</span><span class="params">(ServerSocketChannelImpl ssc)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServerSocketAdaptor(ssc);</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//ServerSocketAdaptor类的构造方法如下</span></div><div class="line"><span class="comment">//创建的ServerSocketAdaptor中保存了ServerSocketChannelImpl的引用</span></div><div class="line"><span class="comment">//ServerSocketAdaptor类是ServerSocket的子类</span></div><div class="line"><span class="comment">//它覆盖了父类中的bind，accept，close等方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServerSocketAdaptor</span><span class="params">(ServerSocketChannelImpl ssc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"><span class="keyword">this</span>.ssc = ssc;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="socket-bind"><a href="#socket-bind" class="headerlink" title="socket.bind"></a><code>socket.bind</code></h4><p><code>sun.nio.ch.ServerSocketAdaptor#bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">bind(local, <span class="number">50</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">if</span> (local == <span class="keyword">null</span>)</div><div class="line">    local = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    ssc.bind(local, backlog);</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception x) &#123;</div><div class="line">    Net.translateException(x);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.ServerSocketChannelImpl#bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">    <span class="keyword">if</span> (!isOpen())</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">    <span class="keyword">if</span> (isBound())</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException();</div><div class="line">        InetSocketAddress isa = (local == <span class="keyword">null</span>) ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>) :</div><div class="line">        Net.checkAddress(local);</div><div class="line">        SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</div><div class="line">          sm.checkListen(isa.getPort());</div><div class="line">        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</div><div class="line">        <span class="comment">//关键点</span></div><div class="line">        <span class="comment">//底层调用的是native方法</span></div><div class="line">        Net.bind(fd, isa.getAddress(), isa.getPort());</div><div class="line">        Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</div><div class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</div><div class="line">          localAddress = Net.localAddress(fd);</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="server-register"><a href="#server-register" class="headerlink" title="server.register"></a><code>server.register</code></h4><p><strong>往Selector注册Channel,通道触发了一个事件意味着该事件已经就绪</strong></p><p><code>java.nio.channels.SelectableChannel#register</code></p><ul><li>可以注册四种事件,<code>java.nio.channels.SelectionKey</code>内定义：<ul><li><code>OP_READ</code>(1)<ul><li>一个有数据可读的通道</li></ul></li><li><code>OP_WRITE</code>(4)<ul><li>等待写数据的通道</li></ul></li><li><code>OP_CONNECT</code>(8)<ul><li>某个channel成功连接到另一个服务器</li></ul></li><li><code>OP_ACCEPT</code>(16)<ul><li>一个server socket channel准备好接收新进入的连接</li></ul></li></ul></li><li>注册多个事件，用“位或|”<ul><li><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SelectionKey包含：</span></div><div class="line"><span class="comment">//interest集合</span></div><div class="line"><span class="comment">//ready集合</span></div><div class="line"><span class="comment">//Channel</span></div><div class="line"><span class="comment">//Selector</span></div><div class="line"><span class="comment">//附加的对象（可选）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> ClosedChannelException</span>&#123;</div><div class="line"><span class="keyword">return</span> register(sel, ops, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>java.nio.channels.spi.AbstractSelectableChannel#register</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SelectionKey保存注册时的channel、selector、event</span></div><div class="line"><span class="comment">// 以及保存在pollWrapper的偏移位置index</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,Object att)</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</div><div class="line"><span class="keyword">synchronized</span> (regLock) &#123;</div><div class="line">      <span class="keyword">if</span> (!isOpen())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">      <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">      <span class="keyword">if</span> (blocking)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</div><div class="line">      SelectionKey k = findKey(sel);</div><div class="line">      <span class="comment">// 1 如果该channel和selector已经注册过，则直接添加感兴趣的事件和附件</span></div><div class="line">      <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</div><div class="line">        k.interestOps(ops);</div><div class="line">        k.attach(att);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 2 否则通过selector实现注册过程，调用select的regist</span></div><div class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// New registration</span></div><div class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</div><div class="line">          <span class="keyword">if</span> (!isOpen())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">          <span class="comment">//关键点</span></div><div class="line">          <span class="comment">//调用select的regist</span></div><div class="line">          k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</div><div class="line">          addKey(k);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.SelectorImpl#register</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,<span class="keyword">int</span> ops,Object attachment)</span></span>&#123;</div><div class="line"><span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</div><div class="line">    <span class="comment">//1.创建了一个SelectionKeyImpl对象</span></div><div class="line">    <span class="comment">//注册感兴趣事件和附件</span></div><div class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</div><div class="line">    <span class="comment">//调用attach方法将传入的附件类attachment放入到SelectionKeyImpl的属性中</span></div><div class="line">    k.attach(attachment);</div><div class="line">    <span class="keyword">synchronized</span> (publicKeys) &#123;</div><div class="line">      implRegister(k);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用SelectionKeyImpl的interestOps方法将感兴趣的操作（SelectionKey.OP_ACCEPT）传入</span></div><div class="line">    <span class="comment">//实际上这个interestOps方法也是将这个值放到了KQueueSelectorImpl的pollWrapper属性中</span></div><div class="line">    k.interestOps(ops);</div><div class="line">    <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="implRegister"><a href="#implRegister" class="headerlink" title="implRegister"></a><code>implRegister</code></h5><p><code>sun.nio.ch.SelectionKeyImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> SelChImpl channel;                            <span class="comment">// package-private</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectorImpl selector;</div><div class="line"><span class="comment">//保存了Selector的实现类和ServerSocketChannel的实现类</span></div><div class="line"><span class="comment">//这个构造方法中接受的第一个参数是SelChImpl类</span></div><div class="line"><span class="comment">//那么ServerSocketChannel的实现类肯定实现了这个类</span></div><div class="line">SelectionKeyImpl(SelChImpl ch, SelectorImpl sel) &#123;</div><div class="line">  channel = ch;</div><div class="line">  selector = sel;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接着调用implRegister，这个方法的实现就是Selector的实现类，系统不同，实现类不同。</p><p>PollSelectorImpl(Linux)，WindowsSelectorImpl(Windows)，KQueueSelectorImpl(Mac)</p><p><code>sun.nio.ch.AbstractPollSelectorImpl#implRegister</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (closeLock) &#123;</div><div class="line">            <span class="keyword">if</span> (closed)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">            <span class="comment">// Check to see if the array is large enough</span></div><div class="line">            <span class="comment">//如果totalChannels的channel数量达到了channelArray的长度（默认是8）</span></div><div class="line">      <span class="comment">//查看pollWrapper中的pollfd数组是否足够大</span></div><div class="line">            <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</div><div class="line">                <span class="comment">// Make a larger array</span></div><div class="line"><span class="comment">//那么channelArray 急需要扩充，扩充为2倍                </span></div><div class="line">                <span class="keyword">int</span> newSize = pollWrapper.totalChannels * <span class="number">2</span>;</div><div class="line">                SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</div><div class="line">                <span class="comment">// Copy over</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++)</div><div class="line">                    temp[i] = channelArray[i];</div><div class="line">                channelArray = temp;</div><div class="line">                <span class="comment">// Grow the NativeObject poll array</span></div><div class="line">                <span class="comment">//同时保存文件描述符对象的PollArrayWrapper类也需要扩充</span></div><div class="line">                pollWrapper.grow(newSize);</div><div class="line">            &#125;</div><div class="line">      <span class="comment">//2.把新建的SelectionKey添加到pollWrapper的channel数组</span></div><div class="line">            channelArray[totalChannels] = ski;</div><div class="line">            <span class="comment">//设置SelectionKeyImpl对象的index属性也就是他在channelArray数组中的位置</span></div><div class="line">            ski.setIndex(totalChannels);</div><div class="line">            <span class="comment">//将SelectionKeyImpl对象的channel放到pollWrapper中</span></div><div class="line">            pollWrapper.addEntry(ski.channel);</div><div class="line">            <span class="comment">//totalChannels自增</span></div><div class="line">            totalChannels++;</div><div class="line">            <span class="comment">//将SelectionKeyImpl对象放到keys属性中</span></div><div class="line">            keys.add(ski);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="interestOps"><a href="#interestOps" class="headerlink" title="interestOps"></a><code>interestOps</code></h5><p><code>sun.nio.ch.SelectionKeyImpl#interestOps</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</div><div class="line">  ensureValid();</div><div class="line">  <span class="keyword">return</span> nioInterestOps(ops);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.SelectionKeyImpl#nioInterestOps</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">nioInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((ops &amp; ~channel().validOps()) != <span class="number">0</span>)</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    channel.translateAndSetInterestOps(ops, <span class="keyword">this</span>);</div><div class="line">    interestOps = ops;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Selector</code>和<code>ServerSocketChannel</code>都创建好了，通过<code>ServerSocketChannel</code>的<code>register</code>方法把二者绑定在一起，也就是把创建<code>ServerSocketChannel</code>时创建的<code>FD</code>(file descriptor)与Selector绑定在了一起。</p><p>至此，server端已经启动完成了。</p><h4 id="selector-select"><a href="#selector-select" class="headerlink" title="selector.select()"></a><code>selector.select()</code></h4><p><strong>监听哪些Channel已经就绪</strong></p><p><strong>selectNow的选择过程是非阻塞的，select(timeout)和select()的选择过程是阻塞的</strong></p><p><code>sun.nio.ch.SelectorImpl#select</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回值表示有多少通道已经就绪</span></div><div class="line"><span class="comment">//select()底层调用为select(0)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</div><div class="line">  <span class="comment">//关键点</span></div><div class="line">  <span class="keyword">return</span> lockAndDoSelect((timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">return</span> select(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.SelectorImpl#lockAndDoSelect</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isOpen())</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">        <span class="keyword">synchronized</span> (publicKeys) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</div><div class="line">                <span class="comment">//关键点</span></div><div class="line">              <span class="keyword">return</span> doSelect(timeout);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.PollSelectorImpl#doSelect</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></div><div class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelArray == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">        <span class="comment">//处理已经不监听的事件（文件描述符或Channel）</span></div><div class="line">        processDeregisterQueue();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//标志开始一个可能会被中断的IO操作</span></div><div class="line">            begin();</div><div class="line">            <span class="comment">//核心</span></div><div class="line">            <span class="comment">//底层调用native方法poll0</span></div><div class="line">            <span class="comment">//本质上是调用了系统的epoll方法</span></div><div class="line">            <span class="comment">//调用native方法epoll获取已经就绪的pollfd</span></div><div class="line">            <span class="comment">//totalChannels：</span></div><div class="line">            <span class="comment">//The number of valid channels in this Selector's poll array</span></div><div class="line">            pollWrapper.poll(totalChannels, <span class="number">0</span>, timeout);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            end();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//处理已经不监听的事件（文件描述符或Channel）</span></div><div class="line">        processDeregisterQueue();</div><div class="line">        <span class="comment">//2 获取就绪的Key的数目，并且将就绪的Key赋值给selector的selectedKey</span></div><div class="line">        <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</div><div class="line">        <span class="keyword">if</span> (pollWrapper.getReventOps(<span class="number">0</span>) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Clear the wakeup pipe</span></div><div class="line">            <span class="comment">//清除wakeup通道</span></div><div class="line">            pollWrapper.putReventOps(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            <span class="keyword">synchronized</span> (interruptLock) &#123;</div><div class="line">                IOUtil.drain(fd0);</div><div class="line">                interruptTriggered = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numKeysUpdated;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><code>sun.nio.ch.PollArrayWrapper#poll</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">int</span> numfds, <span class="keyword">int</span> offset, <span class="keyword">long</span> timeout)</span> </span>&#123;</div><div class="line">  <span class="comment">//SIZE_POLLFD:8</span></div><div class="line">  <span class="keyword">return</span> poll0(pollArrayAddress + (offset * SIZE_POLLFD),</div><div class="line">               numfds, timeout);</div><div class="line">&#125;</div><div class="line"><span class="comment">//这一方法是一个native方法，本质上是调用了系统的epoll方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">poll0</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout)</span></span>;</div></pre></td></tr></table></figure><p><strong>如果有已经就绪的pollfd，poll0()就会返回，没有则一直阻塞，也就是selector.select()会一直阻塞。poll0()返回后，selector.select()就会返回，所以在监听时要用while(true)，这样就可以保证在selector接收到数据并处理完后继续监听poll()。</strong></p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="selector-wakeUp"><a href="#selector-wakeUp" class="headerlink" title="selector.wakeUp()"></a><code>selector.wakeUp()</code></h4><blockquote><p>个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><p>wakeup()是通过pipe发送一个字节来唤醒poll().</p></blockquote><h4 id="selector-close"><a href="#selector-close" class="headerlink" title="selector.close()"></a><code>selector.close()</code></h4><blockquote><p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p></blockquote><h4 id="查找native方法源码"><a href="#查找native方法源码" class="headerlink" title="查找native方法源码"></a>查找native方法源码</h4><p>一般，从JDK目录下的native目录(可能跟OS平台相关)根据包名路径去找相关的Class名.c文件即可找到对应的native方法。</p><p>如果间接调用了hotspot的实现(jvm会以动态库的形式被加载，prims定义了hotspot与其它模块的接口及实现)，那么从share/vm/prims/jvm.cpp文件可找到JVM_XXX函数的实现。</p><h4 id="NIO-amp-AIO-对比"><a href="#NIO-amp-AIO-对比" class="headerlink" title="NIO &amp; AIO 对比"></a>NIO &amp; AIO 对比</h4><table><thead><tr><th>属性</th><th>同步阻塞IO(BIO)</th><th>伪异步IO</th><th>非阻塞IO(NIO)</th><th>异步IO(AIO)</th></tr></thead><tbody><tr><td>客户端数：IO线程数</td><td>1:1</td><td>M:N(M&gt;N)</td><td>M:1</td><td>M:0</td></tr><tr><td>阻塞类型</td><td>阻塞</td><td>阻塞</td><td>非阻塞</td><td>非阻塞</td></tr><tr><td>同步</td><td>同步</td><td>同步</td><td>同步(多路复用)</td><td>异步</td></tr><tr><td>API使用难度</td><td>简单</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>调试难度</td><td>简单</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>非常差</td><td>差</td><td>高</td><td>高</td></tr><tr><td>吞吐量</td><td>低</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/6-b14/" target="_blank" rel="external">grepcode-openjdk</a></p><p><a href="http://hg.openjdk.java.net/" target="_blank" rel="external">hg.openjdk.java.net</a></p><h4 id="eclipse插件"><a href="#eclipse插件" class="headerlink" title="eclipse插件"></a>eclipse插件</h4><p><a href="http://marketplace.eclipse.org/content/java-source-attacher" target="_blank" rel="external">Java Source Attacher</a></p>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案</title>
      <link href="/distributed/solution.html"/>
      <url>/distributed/solution.html</url>
      
        <content type="html"><![CDATA[<h3 id="分布式事务产生背景"><a href="#分布式事务产生背景" class="headerlink" title="分布式事务产生背景"></a>分布式事务产生背景</h3><a id="more"></a><blockquote><p> 一般情况下，讲分布式事务都是说数据库的事务(database transaction)。后来一些非数据库的事务也借鉴了此概念。</p><p> <strong>事务</strong>：运行在数据库上的逻辑单元，一切命令SQL具有原子性的操作特点(要么完全成功的执行，要么完全撤销不执行)。</p></blockquote><h4 id="数据库事务要满足的要求ACID"><a href="#数据库事务要满足的要求ACID" class="headerlink" title="数据库事务要满足的要求ACID"></a>数据库事务要满足的要求ACID</h4><ul><li>原子性Atomic<ul><li>事务必须是原子的工作单元</li></ul></li><li>隔离性Isolation<ul><li>并发事务所做的修改必须和其它事务所做的修改时隔离的</li></ul></li></ul><ul><li>一致性Consistent<ul><li>事务完成时，必须使所有数据都保持一致状态</li></ul></li><li>持久性Duration<ul><li>事务完成之后，对系统的影响是永久性的</li></ul></li></ul><blockquote><p>隔离性通过锁实现，其他特性通过数据库的事务日志来实现。涉及到IO操作。这就是事务操作的性能瓶颈所在。</p></blockquote><h4 id="Mysql里的事务处理过程"><a href="#Mysql里的事务处理过程" class="headerlink" title="Mysql里的事务处理过程"></a>Mysql里的事务处理过程</h4><ul><li>记录<code>redo</code>和<code>undo</code>的log文件，确保日志在磁盘上的持久化</li><li>更新数据记录</li><li>提交事务，redo写入commit记录</li></ul><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p><strong>分库分表</strong></p><ul><li>数据库拆分<ul><li>读库</li><li>写库</li></ul></li><li>SOA化<ul><li>单机可以支撑的系统做拆分<ul><li>用户中心</li><li>库存中心</li><li>订单中心</li><li>商品中心</li><li>…</li></ul></li></ul></li></ul><h3 id="经典的X-OpenDTP事务模型"><a href="#经典的X-OpenDTP事务模型" class="headerlink" title="经典的X/OpenDTP事务模型"></a>经典的X/OpenDTP事务模型</h3><blockquote><p> X/Open Distributed Transaction Processing Reference Model分布式事务处理模型。</p><p> X/Open是一个组织机构，定义出的一套分布式事务标准，定义了规范的API接口，由具体厂商负责实现。</p><p> J2EE 遵循了X/open DTP规范，设计并实现了java里面的分布式事务编程接口规范-JTA。</p><p> XA是X/Open DTP定义的中间件与数据库之间的接口规范。 XA接口函数由数据库厂商提供。</p></blockquote><h4 id="X-OpenDTP角色"><a href="#X-OpenDTP角色" class="headerlink" title="X/OpenDTP角色"></a>X/OpenDTP角色</h4><ul><li>AP<ul><li>application   </li></ul></li><li>RM <ul><li>resouces manager</li><li>资源管理器</li><li>一般情况下是数据库或者是文件系统</li><li>XA定义的接口</li></ul></li><li>TM<ul><li>transaction manager</li><li>事务管理器，事务协调者</li><li>负责接收来自AP的XA事务指令，并协调RM执行XA指令</li></ul></li></ul><h4 id="二阶段提交（2PC）"><a href="#二阶段提交（2PC）" class="headerlink" title="二阶段提交（2PC）"></a>二阶段提交（2PC）</h4><blockquote><p> 2PC（two -phase-commit）, 用来保证分布式事务的完整性。</p></blockquote><p><strong>阶段一：提交事务请求（投票）</strong></p><ul><li>TM向所有的AP发送prepare请求(事务内容，事务的预提交，相当于把耗时的操作先执行)，询问是否可以执行事务的提交操作，并等待各个AP的响应</li><li>执行事务<ul><li>各个AP节点执行事务操作，将undo和redo信息记录到事务日志中，尽量把提交过程中所消耗时间的操作和准备都提前完成后确保后续事务提交的成功率</li></ul></li></ul><ul><li>各个AP向TM反馈事务询问的响应<ul><li>各个AP成功执行了事务操作，那么反馈给TM<code>yes</code>的response</li><li>如果AP没有成功执行事务，就反馈TM<code>no</code>的response</li></ul></li></ul><p><strong>阶段二：执行事务提交</strong></p><ul><li>TM向AP发送commit请求（提交事务请求）<ul><li>执行提交事务<ul><li>全部返回<code>yes</code></li></ul></li></ul></li><li>TM向AP发送abort请求（中断事务提交）<ul><li>只要任何一个返回返回了<code>no</code>，协调者就认为这个事务需要回滚</li><li>按照undo日志回滚，回滚后释放事务资源（包括锁），返回<code>ack</code>给TM</li></ul></li></ul><blockquote><p>假设一个事务的提交过程总共需要30s，其中prepare操作需要28s（事务日志落地磁盘及各种IO操作），而真正commit只需要2s。那么，commit阶段发生错误的概率和prepare相比，2/28(&lt;10%).只要第一个阶段成功，那么commit阶段出现失败的概率就非常小，大大增加了分布式事务的成功概率。</p></blockquote><h5 id="2PC存在的问题"><a href="#2PC存在的问题" class="headerlink" title="2PC存在的问题"></a>2PC存在的问题</h5><ul><li>数据一致性问题<ul><li>在二阶段，参与者和协调者都挂了，挂了的参与者AP在挂之前已经执行了一个操作，但是由于挂了，其他机器不知道执行了什么操作。<ul><li>TM可以通过leader选举或其它方式来产生，新TM需要保证与AP保证数据一致性， 如果三个AP中两个执行了commit，另外一个在挂掉之前执行了rollback，这时候就会产生数据一致性的问题。</li></ul></li></ul></li><li>同步阻塞<ul><li>TM发送请求后，需等待AP返回响应，这个过程中，TM处于等待状态，AP返回yes，TM发送commit后挂了，AP处于阻塞状态，会导致性能问题。</li></ul></li></ul><h4 id="三阶段提交3PC-three-phase-commit"><a href="#三阶段提交3PC-three-phase-commit" class="headerlink" title="三阶段提交3PC(three phase commit)"></a>三阶段提交3PC(three phase commit)</h4><ul><li>canCommit<ul><li>有没有时间去钓鱼</li></ul></li><li>preCommit<ul><li>暂定某天去钓鱼并告知所有人</li></ul></li><li>doCommit<ul><li>到了预定的那天，一起去钓鱼</li></ul></li></ul><blockquote><p> 引入超时机制，preCommit没有响应，则认为该事务失败。</p><p> 增加询问的操作，确保挂掉后能正常恢复。</p><p> 但其实依旧存在一致性问题，Zookeeper那采用多阶段提交，可以查看源码一探究竟。</p></blockquote><h3 id="分布式事务的常见实现"><a href="#分布式事务的常见实现" class="headerlink" title="分布式事务的常见实现"></a>分布式事务的常见实现</h3><ul><li>JOTM(java open transaction manager)<ul><li>Object Web开源的基于J2EE的JTA规范的实现</li></ul></li><li>Atomikos<ul><li>本身是一个商业项目，开源</li><li>常用</li></ul></li></ul><h3 id="互联网行业分布式事务解决方案"><a href="#互联网行业分布式事务解决方案" class="headerlink" title="互联网行业分布式事务解决方案"></a>互联网行业分布式事务解决方案</h3><p><strong>柔性事务</strong>：相对于强一致性的ACID刚性事务</p><ul><li>最终一致性<ul><li>eBay模式<ul><li>BASE理论<ul><li>无需保证数据在某一点的强一致性，保证最终一致性</li></ul></li></ul></li></ul></li><li>TCC事务</li><li>补偿机制</li></ul><p><strong>消息重复消费解决方案</strong></p><ul><li>幂等校验<ul><li>数据库mq_reciver,key为消息的唯一值<ul><li>发送消息在数据库里插入</li></ul></li></ul></li><li>日志表、状态判断<ul><li>记录消费表<ul><li>msgId、status</li><li>处理后更改status</li></ul></li></ul></li></ul><p><strong>保证最终一致性的模式</strong></p><ul><li>查询模式<ul><li>提供接口，返回当前操作是否成功的状态<ul><li><a href="https://help.aliyun.com/document_detail/48726.html" target="_blank" rel="external">阿里GTS</a></li></ul></li><li>衰减查询</li></ul></li><li>补偿模式<ul><li>即在事务链中的任何一个正向事务操作，都必须存在一个完全符合回滚规则的可逆事务。<ul><li>自动恢复<ul><li>A调B，失败了。自动重试。</li><li>衰减查询后的结果一直是失败的，自动对原有操作做回滚。</li></ul></li><li>通知运营<ul><li>自动恢复不了，成本较大，通过运营系统人工补偿</li></ul></li><li>通知技术<ul><li>监控、预警</li><li>修复数据</li></ul></li></ul></li></ul></li><li>TCC事务模型（支付宝的DTS事务架构）<ul><li>放宽了数据库强一致性约束，保证数据最终一致性的方案</li><li>三个阶段<ul><li>TRYING—lock(尝试执行业务)<ul><li>完成所有业务检查(一致性)</li><li>预留必须业务资源(准隔离性)</li></ul></li><li>CONFIRMING—commit(确认执行任务)<ul><li>真正执行业务</li><li>不做任何业务检查</li><li>只使用Try阶段预留的业务资源</li><li>Confirm操作满足幂等性</li></ul></li><li>CANCELING—rollback(取消执行业务)<ul><li>释放Try阶段预留的业务资源</li><li>Cancel操作满足幂等性</li></ul></li></ul></li><li>开源框架(可以整合dubbo)<ul><li><a href="https://github.com/changmingxie/tcc-transaction" target="_blank" rel="external">tcc-transation</a></li><li><a href="https://github.com/liuyangming/ByteTCC" target="_blank" rel="external">bytetcc</a></li></ul></li></ul></li><li>最大努力通知型<ul><li>同步</li><li>异步</li><li>查询掉单</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo主干源码分析</title>
      <link href="/Dubbo/rootcode.html"/>
      <url>/Dubbo/rootcode.html</url>
      
        <content type="html"><![CDATA[<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><a id="more"></a><ul><li>dubbo-admin:<ul><li>控制台</li></ul></li><li>dubbo-cluster<ul><li>集群</li><li>负载均衡<ul><li>loadbalance<ul><li>AbstractLoadBalance</li><li>ConsistentHashLoadBalance</li><li>LeastActiveLoadBalance</li><li>RandomLoadBalance</li><li>RoundRobinLoadBalance</li></ul></li></ul></li></ul></li><li>dubbo-common<ul><li>公共的逻辑模块<ul><li>工具类<ul><li>json</li><li>log</li><li>…</li></ul></li></ul></li></ul></li><li>dubbo-config<ul><li>配置层<ul><li>spring配置的集成</li></ul></li></ul></li><li>dubbo-container<ul><li>容器</li></ul></li><li>dubbo-demo<ul><li>演示案例</li></ul></li><li>dubbo-filter<ul><li>过滤器<ul><li>验证</li><li>缓存</li></ul></li></ul></li><li>dubbo-maven<ul><li>​</li></ul></li><li>dubbo-monitor<ul><li>监测中心</li></ul></li><li>dubbo-registry<ul><li>注册中心<ul><li>multicase</li><li>redis</li><li>zookeeper</li><li>…</li></ul></li></ul></li><li>dubbo-remoting<ul><li>远程通讯协议<ul><li>grizzly</li><li>http</li><li>mima</li><li>netty</li><li>netty4</li><li>p2p</li><li>zookeeper</li></ul></li></ul></li><li>dubbo-rpc<ul><li>远程传输协议<ul><li>dubbo协议的实现</li></ul></li></ul></li><li>dubbo-simple<ul><li>简单的监控中心</li></ul></li><li>dubbo-test<ul><li>​</li></ul></li><li>dubbo-lite<ul><li>hessian序列化协议的一个包<ul><li>dubbo对hessian做了改造，不是原生的hessian协议。</li></ul></li></ul></li></ul><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><ul><li>基于App.java中的main方法去运行，main方法基于spring容器去启动。所以先到<code>dubbo-config</code>中找到<code>dubbo-config-spring</code>。</li><li>使用dubbo时，都是基于自定义的dubbo配置。相当于对spring配置的一个扩展。需要自定义配置时使用的两个接口<ul><li>NamespaceHandler<ul><li>注册BeanDefinitionParser，利用它来解析</li></ul></li><li>BeanDefinitionParser<ul><li>解析配置文件的元素</li></ul></li></ul></li><li>resources/spring.handlers<ul><li>做spring扩展，默认加载。</li><li>spring会默认加载jar包下/META-INF/spring.handlers  找到对应的NamespaceHandler</li><li>com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler#init</li></ul></li><li>Main.main(args)—container.start()—context.start—init—DubboBeanDefinitionParser<ul><li>解析<ul><li>application</li><li>module</li><li>registry</li><li>monitor</li><li>provider</li><li>consumer</li><li>protocol</li><li>service</li><li>reference</li><li>annotation</li></ul></li><li>单独处理<ul><li>ProtocolConfig</li><li>ServiceBean</li><li>ProviderConfig</li><li>ConsumerConfig</li></ul></li></ul></li></ul><p><code>com.alibaba.dubbo.config.spring.ServiceBean</code>实现了</p><ul><li>InitializingBean<ul><li>当spring容器初始化后，触发afterPropertiesSet方法</li></ul></li><li>DisposableBean<ul><li>Bean被销毁时，调用destroy方法</li></ul></li><li>ApplicationContextAware<ul><li>Bean注入成功以后，注入一个ApplicationContext对象，获取spring上下文</li></ul></li><li>ApplicationListener<ul><li>spring容器启动后，会触发事件通知</li></ul></li><li>BeanNameAware<ul><li>Bean初始化完成后，可以获得bean相关属性</li></ul></li></ul><p><code>afterPropertiesSet</code>方法</p><ul><li>检查<code>Provider</code>、<code>Application</code>、<code>Module</code>、<code>Registry</code>、<code>Monitor</code>、<code>Protocol</code>、<code>Path</code>是否为空，如果为空，则赋值。</li><li>判断是否延迟，不延迟则发布服务export—doExport<ul><li>获得注册中心的配置、多协议发布<ul><li><code>com.alibaba.dubbo.config.ServiceConfig#doExportUrls</code></li><li><code>List&lt;URL&gt; registryURLs = loadRegistries(true);</code></li></ul></li><li>如果协议名称没有配置，则采用dubbo协议<ul><li><code>com.alibaba.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code></li></ul></li><li>获得host</li><li>获得port<ul><li><code>com.alibaba.dubbo.config.ServiceConfig#findConfigedPorts</code></li><li>解析环境变量配置的port</li><li>取协议的默认端口(dubbo默认20880)</li><li>都没有，则随机生成</li></ul></li><li>用Map<string, string="">来存储配置信息<ul><li>dubboVersion</li><li>timestamp</li><li>pid</li><li>application</li><li>module</li><li>provider</li><li>…</li></ul></string,></li><li>根据<code>name</code>、<code>host</code>、<code>port</code>、<code>path</code>、<code>map</code>生成发布服务的URL</li><li>如果register不为空，则将服务注册</li><li>通过<code>protocol.export</code>发布服务<ul><li><code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#export</code></li><li>openServer—发布服务的URL存放到serverMap<ul><li><code>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol#createServer</code></li><li><code>ExchangeServer</code>为协议层的API</li><li><code>server = Exchangers.bind(url, requestHandler);</code><ul><li><code>com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger#bind</code></li><li><code>Transporters.bind</code>绑定传输协议<ul><li>Grizzly</li><li>Mina</li><li>Netty</li><li>Netty4</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><hr><h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><p><code>External Libraries</code>—<code>dubbo-2.5.3.jar</code>—<code>META-INF</code>—<code>dubbo.internal</code>—<code>com.alibaba.dubbo.rpc.Protocol</code>配置的是协议的实现(Key-Value)。</p><p>Netty的SPI机制就相当于一个插件化的支持。</p><p>原生SPI通过serviceLoader一次性加载，而在上述文件中会根据<code>name</code>加载。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><ul><li>创建类<code>MyProtocol</code>实现<code>com.alibaba.dubbo.rpc.Protocol</code>接口及方法<ul><li><code>int getDefaultPort()</code></li><li><code>&lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</code></li><li><code>&lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</code></li><li><code>void destroy();</code></li></ul></li><li><code>META-INF/services/</code>—<code>META-INF/dubbo/</code>—<code>META-INF/dubbo/internal/</code>这几个文件夹皆可<ul><li>创建<code>com.alibaba.dubbo.rpc.Protocol</code>文件 </li><li>写入<code>myprotocol=com.bai.dubbo.demo.MyProtocol</code></li></ul></li><li><code>App</code>类内<code>Protocol protocol=ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(&quot;myprotocol&quot;);</code></li><li>可以获得到自定义端口</li></ul><h4 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h4><p><code>com.alibaba.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol</code></p><p><strong><code>Exporter&lt;?&gt; exporter = protocol.export(invoker);</code></strong></p><p>会通过动态代理的方式生成动态类<code>ProtocolAdaptive</code>。</p><p><code>com.alibaba.dubbo.common.extension.Adaptive</code></p><p>每一个扩展里都有一个自适配的Adaptive，如果没有配置自定义协议，则采用dubbo协议。</p><p>Adaptive注解可以放在类上也可以放在方法上。</p><p>通过扩展去调用方法,会有getAdaptive方法，在协议里有自适配的Adaptive。</p><p><code>com.alibaba.dubbo.common.extension.ExtensionLoader</code></p><p><strong><code>getExtensionLoader</code></strong></p><ul><li>判断类是否为null，为null报错</li><li>判断是否为接口，不是接口报错</li><li>判断带SPI注解，没带SPI注解报错</li><li>每个定义的SPI的接口都会构建一个ExtensionLoader实例，存储在<code>ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS</code></li><li>从<code>EXTENSION_LOADERS</code>里取类对应的ExtensionLoader实例，如果为<code>null</code>，则<code>new</code>一个，再存储到<code>EXTENSION_LOADERS</code>里</li></ul><p><strong>带参构造</strong></p><ul><li>找到一个适配的Extension</li></ul><p><strong><code>getAdaptiveExtension</code></strong></p><p><strong><code>createAdaptiveExtension</code></strong></p><p>A类内有成员变量B类，B类继承了C类。通过SPI扩展时，如何判断需要注入的是B还是C。此方法会生成一个Adaptive。</p><ul><li>ProtocolFilterWrapper<ul><li>根据invoker的url的协议判断该协议是该注册还是该发布<ul><li>registry<ul><li>RegitstryProtocol</li></ul></li><li>dubbo<ul><li>DubboProtocol</li></ul></li></ul></li></ul></li><li>ProtocolListenerWrapper</li></ul><p><strong><code>loadFile</code></strong></p><ul><li>启动初始化时，会填充ExtensionLoader类的一些缓存数据(cacheXXX)，从目录中(<code>META-INF/services/</code>—<code>META-INF/dubbo/</code>—<code>META-INF/dubbo/internal/</code>)读取，通过ClassLoader去加载。</li><li>逐行读取com.alibaba.dubbo.rpc.Protocol里的内容，<ul><li>有<code>@Adaptive</code>，则将此类作为Protocol协议的适配，加载到缓存(cahedNames)里,然后根据name找到class，再去通过ClassLoader实例化(new Instance())</li><li>没有<code>@Adaptive</code>，适配类通过javassist修改字节码生成。<ul><li>判断实现类是否存在入参为接口的构造器（就是DubbboProtocol类是否还有入参为Protocol的构造器），有的话作为包装类缓存到此ExtensionLoader的Set<class<?>&gt;集合中，这个其实是个装饰模式</class<?></li></ul></li><li>既不是适配对象也不是wrapped对象，那就是扩展点的具体实现对象，查找<code>@Activate</code><ul><li>有，缓存到cachedActivates</li></ul></li></ul></li></ul><p><strong>服务消费</strong></p><p>根据dubbo内配置的dubboReference加载spring配置。</p><p><code>com.alibaba.dubbo.config.spring.ReferenceBean#afterPropertiesSet</code></p><p>最后会调用<code>getObject</code>方法。跳转到<code>com.alibaba.dubbo.config.ReferenceConfig#init</code>。判断—生成参数—createProxy</p><ul><li>一个JVM内，会通过本地方式调用，否则用远程方式调用。</li><li><code>com.alibaba.dubbo.rpc.Invoker</code>  ,通过它去调用具体的服务</li><li><code>refprotocol.refer</code><ul><li><code>com.alibaba.dubbo.registry.integration.RegistryProtocol#refer</code><ul><li>通过<code>proxyFactory.getInvoker</code>调用</li></ul></li></ul></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>dubbo核心设计</strong></p><ul><li>exporter</li><li>invoker</li><li>protocol</li><li>SPI</li></ul><p><strong>dubbo和dubbox有什么区别</strong></p><p>dubbox是当当的架构师在dubbo的基础上做了升级后的开源框架</p><p>序列化—<code>kryo</code>—比hessian序列化更好</p><p><strong>dubbo执行代码的编译</strong></p><ul><li>利用JDk工具类变异</li><li>利用javassist根据源代码生成字节码</li></ul><p><strong>ObjectFactory是如何根据类型和名字来获取对象的</strong></p><ul><li>ExtensionFactory    <ul><li>AdaptiveExtensionFactory<ul><li>持有所有ExtensionFactory对象的集合</li></ul></li><li>SpiExtensionFactory<ul><li>优先查找</li><li>获取要被注入的对象，就是要获取dubbo spi扩展的实现，所以传入的参数类型必须是接口类型并且接口上打上了@SPI注解，返回的是一个设配类对象。</li></ul></li><li>SpringExtensionFactory<ul><li>SpiExtensionFactory获取结果为null再在此查找</li><li>Dubbo利用spring的扩展机制跟spring做了很好的融合。在发布或者去引用一个服务的时候，会把spring的容器添加到SpringExtensionFactory工厂集合中去， 当SpiExtensionFactory没有获取到对象的时候会遍历SpringExtensionFactory中的spring容器来获取要注入的对象</li></ul></li></ul></li></ul><blockquote><p> ObjectFactory也是基于dubbo的spi扩展机制的。</p><p>它跟Compiler接口一样设配类注解@Adaptive是打在类AdaptiveExtensionFactory上的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo服务最佳实践</title>
      <link href="/Dubbo/best.html"/>
      <url>/Dubbo/best.html</url>
      
        <content type="html"><![CDATA[<h3 id="服务最佳实践"><a href="#服务最佳实践" class="headerlink" title="服务最佳实践"></a>服务最佳实践</h3><a id="more"></a><h4 id="分包"><a href="#分包" class="headerlink" title="分包"></a>分包</h4><ul><li>服务接口、请求服务模型、异常信息都放在api里面<ul><li>符合重用发布等价原则，共同重用原则</li></ul></li><li>api里面放去spring的引用配置。也可以放在模块的包目录下<ul><li>com.bai.order/<em>*</em>-reference.xml</li></ul></li></ul><h4 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h4><ul><li>尽可能把接口设置成粗力度，每个服务方法代表一个独立的功能，而不是某个功能的步骤。否则就会涉及到分布式事务</li><li>服务接口建议以业务场景为单位划分。并对相近业务做抽象，防止接口暴增</li><li>不建议使用过于抽象的通用接口T&lt;泛型&gt;<ul><li>接口没有明确的语义，带来后期的维护</li></ul></li></ul><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><ul><li>每个接口都应该定义版本，为后续的兼容性提供前瞻性的考虑<ul><li>version(maven-snapshot)没有做环境隔离会有问题</li></ul></li><li>建议使用两位版本号，因为第三位版本号表示兼容性升级，只有不兼容时才需要变更服务版本</li><li>当接口做不兼容升级的时候，先升级一半或者一台提供者为新版本，再将消费全部升级新版本，然后再将剩下的一半提供者升级新版本<ul><li>预发布环境</li></ul></li></ul><h3 id="推荐用法-配置"><a href="#推荐用法-配置" class="headerlink" title="推荐用法(配置)"></a>推荐用法(配置)</h3><ul><li>在provider端尽可能配置consumer端的属性<ul><li>timeout、retires、线程池大小、loadBalance等</li></ul></li><li>配置管理员信息<ul><li>application上面配置的owner</li><li>建议配置2个人以上</li><li>因为owner都能够在监控中心看到</li></ul></li></ul><h3 id="配置dubbo缓存文件"><a href="#配置dubbo缓存文件" class="headerlink" title="配置dubbo缓存文件"></a>配置dubbo缓存文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">file</span>=<span class="string">".."</span> /&gt;</span></div></pre></td></tr></table></figure><blockquote><p>如果注册中心挂掉了(临时不可用)，可以从缓存文件中找。进一步保证可用性。</p><ul><li>缓存内容<ul><li>注册中心的列表</li><li>服务提供者列表</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo配置详解</title>
      <link href="/Dubbo/config.html"/>
      <url>/Dubbo/config.html</url>
      
        <content type="html"><![CDATA[<h3 id="启动服务检查"><a href="#启动服务检查" class="headerlink" title="启动服务检查"></a>启动服务检查</h3><a id="more"></a><blockquote><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 <code>check=&quot;true&quot;</code>。</p></blockquote><ul><li><code>dubbo:reference</code><ul><li><code>check</code>属性<ul><li>true<ul><li>表示启动的时候检查依赖的服务是否正常</li></ul></li><li>false<ul><li>关闭检查</li><li>当服务出现循环依赖时</li><li>当有些服务不关心时</li></ul></li></ul></li></ul></li></ul><blockquote><p>所有服务的启动时检查提供者</p></blockquote><ul><li><code>dubbo:consumer</code><ul><li><code>check</code>属性<ul><li>true</li><li>false<ul><li>没有服务提供者时报错</li></ul></li></ul></li></ul></li></ul><blockquote><p>所有服务的启动时检查消费者</p></blockquote><ul><li>dubbo:provider<ul><li><code>check</code>属性<ul><li>false<ul><li>没有服务消费者失败报错 </li></ul></li></ul></li></ul></li></ul><blockquote><p>注册中心启动时检查注册订阅是否失败</p></blockquote><ul><li><code>dubbo:registry</code><ul><li><code>check</code>属性<ul><li>false<ul><li>注册订阅失败报错 </li></ul></li></ul></li></ul></li></ul><h3 id="多协议支持"><a href="#多协议支持" class="headerlink" title="多协议支持"></a>多协议支持</h3><ul><li>dobbo支持的协议<ul><li>dubbo://(TCP)<ul><li>介绍<ul><li>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</li><li>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</li><li>缺省协议，使用基于 mina <code>1.1.7</code> 和 hessian <code>3.2.1</code> 的 tbremoting 交互。</li></ul></li><li>约束<ul><li>参数及返回值需实现 <code>Serializable</code> 接口</li><li>参数及返回值不能自定义实现 <code>List</code>, <code>Map</code>, <code>Number</code>, <code>Date</code>, <code>Calendar</code> 等接口，只能用 JDK 自带的实现，因为 hessian 会做特殊处理，自定义实现类中的属性值都会丢失。</li></ul></li><li>常见问题<ul><li>为什么消费者比提供者个数多<ul><li>因dubbo协议采用单一长连接，假设网络为千兆网卡，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡。</li></ul></li><li>为什么不能传大包<ul><li>因dubbo协议采用单一长连接，如果每次请求的数据包大小为500KByte，假设网络为千兆网卡，每条连接最大7MByte(不同环境可能不一样，供参考)，单个服务提供者的TPS(每秒处理事务数)最大为：128MByte/500KByte=262。单个消费者调用单个服务提供的TPS(每秒处理事务数)最大为7MByte/500KByte=14。如果能接受，可以考虑使用，否则网络将成为瓶颈。</li></ul></li><li>为什么采用异步单一长连接<ul><li>因为服务的现状大都是服务提供者少，通常只有机台机器，而服务的消费者多，可能整个网站都在访问该服务，比如Morgan的提供者只有6台，却有上百台消费者，每天有1.5亿次调用，如果采用常规的hessian服务，服务提供者很容易就被压垮，通过单一长连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止<a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">C10K问题</a>(C10K 就是 Client 10000 问题，即「在同时连接到服务器的客户端数量超过 10000 个的环境中，即便硬件性能足够， 依然无法正常提供服务」，简而言之，就是单机1万个并发连接问题。)。</li></ul></li></ul></li></ul></li><li>rmi://(TCP)<ul><li>介绍<ul><li>RMI 协议采用 JDK 标准的 <code>java.rmi.*</code> 实现，采用阻塞式短连接和 JDK 标准序列化方式。</li><li>注意：如果正在使用 RMI 提供服务给外部访问 <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/references/protocol/rmi.html#fn_1" target="_blank" rel="external">1</a>，同时应用里依赖了老的 common-collections 包 <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/references/protocol/rmi.html#fn_2" target="_blank" rel="external">2</a> 的情况下，存在反序列化安全风险 <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/references/protocol/rmi.html#fn_3" target="_blank" rel="external">3</a>。</li></ul></li><li>约束<ul><li>数及返回值需实现<code>Serializable</code>接口</li><li>dubbo配置中的超时事件对RMI无效，需使用java启动参数设置：<code>-Dsun.rmi.transport.tcp.responseTimeout=3000</code></li></ul></li></ul></li><li>hessian://(http)<ul><li>介绍<ul><li>Hessian <a href="https://dubbo.gitbooks.io/dubbo-user-book/content/references/protocol/hessian.html#fn_1" target="_blank" rel="external">1</a> 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。</li><li>Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即：<ul><li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li><li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li></ul></li></ul></li></ul></li><li>webservice://(http)</li><li><a href="http://(http" target="_blank" rel="external">http://(http</a>)</li><li>thrift://</li><li>memcached://</li><li>redis://</li></ul></li><li>改造协议</li><li>支持多协议</li></ul><h3 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h3><table><thead><tr><th style="text-align:center">协议</th><th>连接个数</th><th>连接方式</th><th>传输协议</th><th>传输方式</th><th>序列化</th><th>适用范围</th><th>适用场景</th></tr></thead><tbody><tr><td style="text-align:center">dubbo://</td><td>单连接</td><td>长连接</td><td>TCP</td><td>NIO异步传输</td><td>Hessian二进制序列化</td><td>数据包较小(建议小于100K)，消费者比提供者个数多，单一消费者无法压满提供者，不要传输大文件或超大字符串</td><td>常规远程服务方法调用</td></tr><tr><td style="text-align:center">rmi://</td><td>多连接</td><td>短连接</td><td>TCP</td><td>同步传输</td><td>Java标准二进制序列化</td><td>数据包大小混合，消费者与提供者个数差不多，可传文件</td><td></td></tr><tr><td style="text-align:center">hessian://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>Hessian二进制序列化</td><td>数据包较大，提供者比消费者个数多，提供者压力较大，可传文件</td><td>页面传输，文件传输，或与原生hessian服务互操作</td></tr><tr><td style="text-align:center">webservice://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>SOAP文本序列化</td><td>系统集成，跨语言调用</td><td></td></tr><tr><td style="text-align:center">http://</td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>表单序列化</td><td>数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件</td><td>需同时给应用程序和浏览器JS使用的服务</td></tr></tbody></table><h3 id="代码演示-hessian"><a href="#代码演示-hessian" class="headerlink" title="代码演示(hessian)"></a>代码演示(hessian)</h3><h4 id="提供方增加maven依赖"><a href="#提供方增加maven依赖" class="headerlink" title="提供方增加maven依赖"></a>提供方增加maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.caucho<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hessian<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="提供方修改配置"><a href="#提供方修改配置" class="headerlink" title="提供方修改配置"></a>提供方修改配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"hessian"</span> <span class="attr">port</span>=<span class="string">"8090"</span> <span class="attr">server</span>=<span class="string">"jetty"</span>/&gt;</span></div></pre></td></tr></table></figure><h4 id="提供方运行"><a href="#提供方运行" class="headerlink" title="提供方运行"></a>提供方运行</h4><p>控制台会输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[com.alibaba.dubbo.config.AbstractConfig] -  [DUBBO] Export dubbo service com.bai.dubbo.order.IOrderService to url hessian:<span class="comment">//...</span></div></pre></td></tr></table></figure><h4 id="消费方修改配置"><a href="#消费方修改配置" class="headerlink" title="消费方修改配置"></a>消费方修改配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"hessian"</span>/&gt;</span></div></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">...</span>  <span class="attr">protocol</span>=<span class="string">"hessian"</span>/&gt;</span></div></pre></td></tr></table></figure><h4 id="消费方运行"><a href="#消费方运行" class="headerlink" title="消费方运行"></a>消费方运行</h4><p>会提示成功</p><p>Ps：Maven的SNAPSHOT版本deploy后会直接替换仓库中的版本。release则不会。</p><h3 id="多注册中心"><a href="#多注册中心" class="headerlink" title="多注册中心"></a>多注册中心</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span>  <span class="attr">id</span>=<span class="string">"zkOne"</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">""</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span>  <span class="attr">id</span>=<span class="string">"zkTwo"</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">""</span>/&gt;</span></div></pre></td></tr></table></figure><p>或</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">registry</span>=<span class="string">"zkOne"</span> <span class="attr">...</span> /&gt;</span></div></pre></td></tr></table></figure><p><em>dubbo目前只支持Java</em></p><h3 id="多版本支持"><a href="#多版本支持" class="headerlink" title="多版本支持"></a>多版本支持</h3><p>对接口做版本控制，如一个接口升级后需要兼容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--提供方--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">...</span> /&gt;</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--消费方--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">version</span>=<span class="string">"2.0"</span> <span class="attr">...</span> /&gt;</span></div></pre></td></tr></table></figure><p><em>发布服务时生成的URL中如没有版本号，那就是未采用版本控制。</em></p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--消费方--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">...</span> /&gt;</span></div></pre></td></tr></table></figure><p><strong>hessian协议不支持，支持dubbo协议</strong></p><h4 id="消费方改造"><a href="#消费方改造" class="headerlink" title="消费方改造"></a>消费方改造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent;</div><div class="line">service.doOrder(request);</div><div class="line">Future&lt;DoOrderResponse&gt; response=RpcContext.getContext().getFuture();</div><div class="line">System.out.println(response.get(););<span class="comment">//阻塞</span></div></pre></td></tr></table></figure><h3 id="主机绑定"><a href="#主机绑定" class="headerlink" title="主机绑定"></a>主机绑定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * package com.alibaba.dubbo.config;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 主机绑定的过程（取主机的地址）</span></div><div class="line"><span class="comment"> * 地址只能绑定一个</span></div><div class="line"><span class="comment"> * 1.通过&lt;dubbo:protocol host=""/&gt;配置的地址去找</span></div><div class="line"><span class="comment"> * 2.通过InetAddress.getLocalHost().getHostAddress();</span></div><div class="line"><span class="comment"> * 3.通过socket连接到注册中心的地址。再获取连接以后的本地地址</span></div><div class="line"><span class="comment"> * 4.getLocalHost() 网络接口</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="comment">// 如果没通过环境变量设置bind ip，则继续按优先级查找</span></div><div class="line"><span class="keyword">if</span> (hostToBind == <span class="keyword">null</span> || hostToBind.length() == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">//&lt;dubbo:protocol host=""/&gt;配置的host内容</span></div><div class="line">    hostToBind = protocolConfig.getHost();</div><div class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span> &amp;&amp; (hostToBind == <span class="keyword">null</span> || hostToBind.length() == <span class="number">0</span>)) &#123;</div><div class="line">        hostToBind = provider.getHost();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果是否为合法的host</span></div><div class="line">    <span class="keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;</div><div class="line">        anyhost = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//换种方式拿host</span></div><div class="line">            hostToBind = InetAddress.getLocalHost().getHostAddress();</div><div class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</div><div class="line">            logger.warn(e.getMessage(), e);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//再次判断拿到的host是否合法</span></div><div class="line">        <span class="keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;</div><div class="line">            <span class="comment">//注册中心的URL</span></div><div class="line">            <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; registryURLs.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Socket socket = <span class="keyword">new</span> Socket();</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            <span class="comment">//通过socket去连注册中心的地址</span></div><div class="line">                            SocketAddress addr = <span class="keyword">new</span> InetSocketAddress(registryURL.getHost(), registryURL.getPort());</div><div class="line">                            socket.connect(addr, <span class="number">1000</span>);</div><div class="line">                            <span class="comment">//拿到socket连接的本地地址作为URL</span></div><div class="line">                            hostToBind = socket.getLocalAddress().getHostAddress();</div><div class="line">                            <span class="keyword">break</span>;</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                socket.close();</div><div class="line">                            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        logger.warn(e.getMessage(), e);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//上述操作都没有拿到</span></div><div class="line">            <span class="keyword">if</span> (isInvalidLocalHost(hostToBind)) &#123;</div><div class="line">                hostToBind = getLocalHost();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="dubbo服务只订阅"><a href="#dubbo服务只订阅" class="headerlink" title="dubbo服务只订阅"></a>dubbo服务只订阅</h3><blockquote><p> 所有的服务都只共用一个注册中心，其中一个服务正在开发，有问题，但注册到注册中心了。就会影响消费者不能正常运行。</p><p> 需要连注册中心使用服务，但又不能注册该服务。</p><p> 只订阅服务，不提供服务。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">register</span>=<span class="string">"false"</span> <span class="attr">...</span>/&gt;</span></div></pre></td></tr></table></figure><h3 id="dubbo服务只注册"><a href="#dubbo服务只注册" class="headerlink" title="dubbo服务只注册"></a>dubbo服务只注册</h3><blockquote><p>有两个注册中心，服务只在其中一个注册中心部署，另外一个注册中心没有部署时，两个注册中心的其它服务都要依赖此服务。就需要把服务注册到两个注册中心。</p><p>只提供服务，不订阅服务。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">subscribe</span>=<span class="string">"false"</span> <span class="attr">...</span>/&gt;</span></div></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><blockquote><p>在集群负载均衡时，Dubbo提供了多种均衡策略，缺省为random随机调用。可自行扩展负载均衡策略。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">""</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span>/&gt;</span></div></pre></td></tr></table></figure><h4 id="Random-LoadBalance"><a href="#Random-LoadBalance" class="headerlink" title="Random LoadBalance"></a>Random LoadBalance</h4><ul><li>随机，按权重设置随机概率。</li><li>在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率适用权重后也比较均匀，有利于动态调整提供者权重。</li></ul><h4 id="RoundRobin-LoadBalance"><a href="#RoundRobin-LoadBalance" class="headerlink" title="RoundRobin LoadBalance"></a>RoundRobin LoadBalance</h4><ul><li>轮循，按公约后的权重设置轮循比率。</li><li>存在慢的提供者累积请求的问题。<ul><li>第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li></ul></li></ul><h4 id="LeastActive-LoadBalance"><a href="#LeastActive-LoadBalance" class="headerlink" title="LeastActive LoadBalance"></a>LeastActive LoadBalance</h4><ul><li>最少活跃调用数，相同活跃数的随机。<ul><li>对于响应时间比较短的服务会优先</li><li>活跃数指调用前后计数差</li><li>使慢的提供者收到更少请求<ul><li>越慢的提供者的调用前后计数差会越大</li></ul></li></ul></li></ul><h4 id="ConsistentHash-LoadBalance"><a href="#ConsistentHash-LoadBalance" class="headerlink" title="ConsistentHash LoadBalance"></a>ConsistentHash LoadBalance</h4><ul><li>一致性Hash，相同参数的请求总是发到同一提供者。</li><li>当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li></ul><h3 id="连接超时Timeout"><a href="#连接超时Timeout" class="headerlink" title="连接超时Timeout"></a>连接超时Timeout</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--单位为毫秒(常规5秒左右)--&gt;</span></div><div class="line"><span class="comment">&lt;!--处理时间过长，调用链会出现问题--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dubbo:interface</span> <span class="attr">timeout</span>=<span class="string">"2000"</span>/&gt;</span></div></pre></td></tr></table></figure><p><strong>如果消费方和提供方都配置timeout属性，以消费方优先级最高，其次为提供方</strong></p><h3 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failfast"</span> <span class="attr">...</span>/&gt;</span></div></pre></td></tr></table></figure><h4 id="failover-cluster-默认"><a href="#failover-cluster-默认" class="headerlink" title="failover cluster(默认)"></a>failover cluster(默认)</h4><blockquote><p>失败的时候自动切换并重试其它服务器。</p><p>通过retries=2来设置重试次数</p></blockquote><h4 id="failfast-cluster"><a href="#failfast-cluster" class="headerlink" title="failfast cluster"></a>failfast cluster</h4><blockquote><p>快速失败，只发起一次调用。如果失败了，就失败了，不会重试。</p><p>写操作(例如新增记录等非幂等操作)如果重试会造成数据重复。</p></blockquote><h4 id="failfafe-cluster"><a href="#failfafe-cluster" class="headerlink" title="failfafe cluster"></a>failfafe cluster</h4><blockquote><p>失败安全。出现异常时，直接忽略异常(不会报异常)。</p><p>写日志时。无需保证日志一定写成功，但需保证主程序正常运行。</p></blockquote><h4 id="failback-cluster"><a href="#failback-cluster" class="headerlink" title="failback cluster"></a>failback cluster</h4><blockquote><p>失败自动恢复。后台记录失败请求，定时重发。</p><p>消息通知。</p></blockquote><h4 id="forking-cluster"><a href="#forking-cluster" class="headerlink" title="forking cluster"></a>forking cluster</h4><blockquote><p>并行调用多个服务器，只要一个成功就返回。</p><p>只能应用在读请求。</p><p>浪费服务器资源。</p></blockquote><h4 id="broadcast-cluster"><a href="#broadcast-cluster" class="headerlink" title="broadcast cluster"></a>broadcast cluster</h4><blockquote><p>广播调用所有提供者，逐个调用。其中一台报错就会返回异常。</p></blockquote><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><p>消费方 <code>&gt;</code> 提供方</p><p>reference method <code>&gt;</code> service method <code>&gt;</code> reference <code>&gt;</code> service  <code>&gt;</code> consumer <code>&gt;</code> provider </p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步认识Dubbo</title>
      <link href="/Dubbo/dubbofirst.html"/>
      <url>/Dubbo/dubbofirst.html</url>
      
        <content type="html"><![CDATA[<h3 id="技术演变"><a href="#技术演变" class="headerlink" title="技术演变"></a>技术演变</h3><a id="more"></a><ul><li>程序最早运行在在JVM里面，处于单一系统架构。</li><li>服务做拆分，运行在多个JVM内<ul><li>之间通信技术<ul><li>JMS规范<ul><li>ActiveMQ</li></ul></li><li>远程RPC通信框架<ul><li>RMI</li></ul></li><li>WebService</li><li>Hessian</li><li>Kafka+Zookeeper</li></ul></li><li>集群<ul><li>F5负载均衡</li><li>软负载均衡<ul><li>Nginx</li></ul></li></ul></li></ul></li><li>对节点集群<ul><li>硬负载均衡<ul><li>F5</li></ul></li><li>软负载均衡<ul><li>Nginx+LVS</li><li>Nginx+keepalived</li><li>Apache</li></ul></li></ul></li><li>数据存储<ul><li>关系型数据库<ul><li>SQL Server</li><li>Oracle</li><li>MySQL</li><li>MariDB</li></ul></li><li>非关系型数据库<ul><li>MongoDB</li><li>Redis</li><li>DB2</li></ul></li></ul></li><li>扩容<ul><li>Master-Slave模型<ul><li>Master写</li><li>Slave读</li></ul></li></ul></li><li>服务治理<ul><li>Dubbo+Zookeeper<ul><li>URL维护困难</li><li>监控服务依赖关系及响应时间</li></ul></li></ul></li><li>单进程优化性能<ul><li>多线程</li></ul></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><blockquote><ul><li>各个节点中的URL管理维护很困难、依赖关系很模糊<ul><li>注册中心</li></ul></li><li>每个应用节点的性能、访问量、响应时间无法评估<ul><li>监控中心</li></ul></li></ul></blockquote><h3 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h3><p>​    示例代码网上都有</p><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="dubbo如何加载Spring"><a href="#dubbo如何加载Spring" class="headerlink" title="dubbo如何加载Spring"></a>dubbo如何加载Spring</h4><ul><li><code>com.alibaba.dubbo.container.Main</code>中<ul><li><code>ExtensionLoader&lt;Container&gt; loader</code><ul><li>dubbo中的扩展机制。实现机制类似于SPI。</li></ul></li><li><code>container.start();</code>启动Spring<ul><li><code>Main.main(args)</code>中的<code>args</code>会有一个参数叫<code>spring</code><ul><li><code>spring</code>来自于<code>com.alibaba.dubbo.container</code>的配置文件里<code>dubbo/internal</code>中的<code>spring=com.alibaba.dubbo.container.spring.SpringContainer</code></li></ul></li><li><code>com.alibaba.dubbo.container.spring.SpringContainer#start</code>中读取Spring配置：<code>public static final String DEFAULT_SPRING_CONFIG = &quot;classpath*:META-INF/spring/*.xml&quot;;</code></li><li><code>com.alibaba.dubbo.container.spring.SpringContainer</code>中加载Spring<code>context = new ClassPathXmlApplicationContext(configPath.split(&quot;[,\\s]+&quot;));</code>然后<code>context.start();</code></li></ul></li></ul></li></ul><h4 id="如何让进程不终止"><a href="#如何让进程不终止" class="headerlink" title="如何让进程不终止"></a>如何让进程不终止</h4><ul><li><code>com.alibaba.dubbo.container.Main</code> 中利用<code>await()</code>等待</li></ul><h4 id="日志如何集成"><a href="#日志如何集成" class="headerlink" title="日志如何集成"></a>日志如何集成</h4><ul><li><code>com.alibaba.dubbo.common.logger.LoggerFactory</code><ul><li>log4j</li><li>slf4j</li><li>jcl</li><li>jdk</li></ul></li><li>如不指定，优先级为log4j&gt;slf4j&gt;jcl&gt;jdk</li></ul><h4 id="admin控制台的安装"><a href="#admin控制台的安装" class="headerlink" title="admin控制台的安装"></a>admin控制台的安装</h4><ul><li>源码中dubbo-admin模块打成war</li><li>修改<code>dubbo-admin-src-main-webapp-WEB-INF-dubbo.properties</code>中<code>dubbo.registry.address</code>为zk的集群地址</li><li>浏览器访问地址<ul><li>Run/Debug Configration中的地址</li></ul></li><li>输入用户名及密码<ul><li><code>dubbo.properties</code>中的密码</li><li>用户名：root   密码：root</li></ul></li><li>可以进行服务治理<ul><li>权重</li><li>路由</li><li>…</li></ul></li><li>没有监控功能，有另外的监控中心</li></ul><h4 id="simple监控中心"><a href="#simple监控中心" class="headerlink" title="simple监控中心"></a>simple监控中心</h4><ul><li>provider项目的xml中添加配置<ul><li><code>&lt;duboo:monitor protocol=&quot;registry&quot;/&gt;</code></li></ul></li></ul><ul><li>下载<code>dubbo-monitor-simple</code></li><li>修改配置<ul><li>conf/dubbo.propertties<ul><li>Dubbo.registry.address=zk集群地址</li><li>dubbo.protocol.port<ul><li>monitor也是一个dubbo服务，也有端口和url</li></ul></li></ul></li><li>或修改服务提供者的xml(xxx-provider.xml)<ul><li>建议使用xml</li></ul></li></ul></li><li>运行<ul><li>执行<code>bin</code>文件夹下的<code>start</code>脚本</li></ul></li><li>浏览器访问地址<ul><li>localhost:port<ul><li>port为<code>dubbo.propertties</code>中<code>dubbo.jetty.port</code></li></ul></li></ul></li><li>带图表和监控</li><li>监控服务的监控<ul><li>调用次数</li><li>调用关系</li><li>响应时间</li><li>…</li></ul></li><li>默认五分钟生成一次</li></ul><h4 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a>telnet命令</h4><ul><li>2.0.5后提供</li><li>telnet localhost 20880</li><li>telnet调用接口是不受监控的</li><li>常用命令<ul><li>ls</li><li>cd</li><li>pwd</li><li>clear</li><li>invoke</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZAB协议</title>
      <link href="/zk/ZAB.html"/>
      <url>/zk/ZAB.html</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><a id="more"></a><p>分布式环境中，最难的问题为：<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="external">拜占庭将军问题</a></p><blockquote><p><strong>拜占庭将军问题</strong>（Byzantine Generals Problem），是由<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E6%B3%A2%E7%89%B9" target="_blank" rel="external">莱斯利·兰波特</a>在其同名论文<a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#cite_note-:0-1" target="_blank" rel="external">[1]</a>中提出的<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C" target="_blank" rel="external">分布式对等网络</a>通信容错问题。 在<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%A8%88%E7%AE%97" target="_blank" rel="external">分布式计算</a>中，不同的<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F" target="_blank" rel="external">计算机</a>通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。</p><p>在<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C" target="_blank" rel="external">分布式对等网络</a>中需要按照共同一致策略协作的成员计算机即为问题中的将军，而各成员计算机赖以进行通讯的网络链路即为信使。拜占庭将军问题描述的就是某些成员计算机或网络链路出现错误、甚至被蓄意破坏者控制的情况。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95" target="_blank" rel="external">Paxos</a>主要就是如何保证在分布式网络环境下，各个服务器如何达成一致最终保证数据的一致性问题。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p><code>ZAB</code>协议为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。</p><p>基于<code>Paxos</code>的一个改进。</p><p>Zookeeper并没有完全采用<code>Paxos</code>算法，而是采用<code>ZAB(Zookeeper Atomic Broadcast)</code></p></blockquote><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>在Zookeeper的主备模式下，通过<code>ZAB</code>协议来保证集群中各个副本数据的一致性</li><li>Zookeeper使用的是单一的主进程来接收并处理所有的事务请求，并采用<code>ZAB</code>协议把数据的状态变更以事务请求的形式广播到其它节点</li><li><code>ZAB</code>协议在主备模式架构中，保证了同一时刻只能有一个主进程来广播服务器的状态变更</li><li>所有的事务请求必须由全局唯一的服务器(leader)来协调处理，主要负责把客户端的事务请求转化为一个事务提议(proposal)，并分发给集群中的所有follower节点，再等到所有follower节点的反馈。一旦超过半数服务器进行了正确的反馈，那么leader就会commit这条消息</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>崩溃恢复</li><li>原子广播<ul><li>要么同时成功、要么同时失败（分布式事务）</li></ul></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="什么情况下ZAB协议会进入崩溃恢复模式"><a href="#什么情况下ZAB协议会进入崩溃恢复模式" class="headerlink" title="什么情况下ZAB协议会进入崩溃恢复模式"></a>什么情况下ZAB协议会进入崩溃恢复模式</h4><blockquote><p> <strong>崩溃恢复</strong>：服务器崩溃了，从崩溃到恢复正常中间会丢失消息，恢复时需要同步丢失的消息</p></blockquote><ul><li>当服务器启动时</li><li>当leader服务器出现网络中断、崩溃或者重启的情况</li><li>集群中已经不存在过半的服务器与该leader保持正常通信</li></ul><h4 id="ZAB协议进入崩溃恢复模式会做什么"><a href="#ZAB协议进入崩溃恢复模式会做什么" class="headerlink" title="ZAB协议进入崩溃恢复模式会做什么"></a>ZAB协议进入崩溃恢复模式会做什么</h4><ul><li>当leader出现问题，ZAB协议进入崩溃恢复模式，并且选举出新的leader。当新的leader选举出来以后，如果集群中已经有过半机器完成了leader服务器的状态同步(数据同步)，则退出崩溃模式，进入消息广播模式</li><li>当新的机器加入到集群中的时候，如果已经存在leader服务器，那么新加入的服务器就会自觉进入数据恢复模式，找到leader进行数据同步</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>如果客户端发了一个事务请求给到leader， 而leader发送给各个follower以后，并且收到了ack，leader已经commit。 在准备ack给各个follower节点comit的时候，leader挂了，怎么处理的。 <ul><li>ZAB协议，一定需要保证已经被leader提交的事务也能够被所有follower提交。</li><li>选取新的leader(<code>zxid</code>的最大值)</li><li>同步给其它的follower</li></ul></li></ul><ul><li>假设一个事务在leader服务器提交请求，没有发送到follow之前，leader挂掉了，怎么办？<ul><li>ZAB协议需要保证，在崩溃恢复过程中跳过那些已经被丢弃的事务</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的几个原理分析</title>
      <link href="/zk/analyze.html"/>
      <url>/zk/analyze.html</url>
      
        <content type="html"><![CDATA[<h4 id="Zookeeper的集群角色"><a href="#Zookeeper的集群角色" class="headerlink" title="Zookeeper的集群角色"></a>Zookeeper的集群角色</h4><a id="more"></a><p><strong>leader</strong></p><ul><li>集群的核心</li><li>事务请求的唯一调度者和处理者，保证集群事务处理的顺序性</li><li>集群内部各个服务器的调度者</li></ul><p><strong>follower</strong></p><ul><li>处理客户端非事务请求，以及转发事务请求给leader服务器</li><li>参与事务请求提议(proposal)的投票<ul><li>客户端的一个事务请求，需要半数服务器投票通过以后才能通知leader commit</li><li>leader会发起一个提案，要求follower投票</li></ul></li><li>参与leader选的投票</li></ul><p><strong>observer</strong></p><ul><li>Zookeeper3.3以后新增</li></ul><ul><li>观察集群中最新状态的变化并将这些状态同步到observer服务器上</li><li>增加observer不影响集群中事务处理能力，同时还能提升集群的非事务处理能力</li></ul><h3 id="Zookeeper的集群组成"><a href="#Zookeeper的集群组成" class="headerlink" title="Zookeeper的集群组成"></a>Zookeeper的集群组成</h3><h4 id="服务器集群数量"><a href="#服务器集群数量" class="headerlink" title="服务器集群数量"></a>服务器集群数量</h4><p><strong>一般由<code>2n+1</code>台服务器组成</strong></p><ul><li>1台—standalone</li><li>多台情况下，集群必须要有过半的机器能够正常工作并且能够正常通信，因为投票要过半。<ul><li>5台必须3台存活，6台也必须3台存活</li><li>增加了投票的过程，但对可用性并没有提高</li></ul></li></ul><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><h4 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h4><p><code>org.apache.zookeeper.server.quorum.QuorumPeer#startLeaderElection</code></p><ul><li>leaderElection</li><li>AuthFastLeaderElection</li><li>FastLeaderElection <ul><li>默认(<code>org.apache.zookeeper.server.quorum#electionAlg</code>)</li></ul></li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><a href="https://github.com/apache/zookeeper" target="_blank" rel="external">源码地址</a></p><ul><li>编译条件<ul><li>JDK1.7以上</li><li>Ant</li><li>IDEA</li></ul></li></ul><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><h5 id="serverid"><a href="#serverid" class="headerlink" title="serverid"></a><code>serverid</code></h5><p>在配置server集群的时候，给定服务器的标识id(myid)</p><h5 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a><code>zxid</code></h5><p>服务器在运行时产生的数据ID，<code>zxid</code>越大，表示数据越新</p><h5 id="Epoch"><a href="#Epoch" class="headerlink" title="Epoch"></a><code>Epoch</code></h5><p>选举的轮数</p><h3 id="server的状态"><a href="#server的状态" class="headerlink" title="server的状态"></a>server的状态</h3><ul><li>Looking</li><li>Floowing</li><li>Observering</li><li>Leading</li></ul><h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3><p><strong>第一次初始化启动的时候状态为：<code>LOOKING</code></strong></p><ul><li>所有在集群中的server都会推荐自己为leader，然后把<code>myid</code>、<code>zxid</code>、<code>epoch</code>作为广播信息，广播给集群总的其它server，并等待其它服务器返回</li><li>每个服务器都会接收来自集群中的其它服务器的投票。集群中的每个服务器在接收到投票后，开始判断投票的有效性<ul><li>判断逻辑时钟<code>Epoch</code><ul><li>大于自己当前的<code>Epoch</code>，说明自己保存的是过期的。<ul><li>更新<code>Epoch</code>，同时clear其它服务器发送过来的选举数据。</li><li>判断是否需要更新当前自己的选举情况</li></ul></li><li>小于自己当前的<code>Epoch</code>，说明对方的是过期的，也就意味着对方服务器的选举轮数是过期的。这个时候，只需要将自己的信息发送给对象</li><li>等于自己当前的<code>Epoch</code>，则根据规则来判断是否有资格获得leader<ul><li>接收到来自其它服务器的投票后，针对每一个投票，都需要将别人的投票和自己的投票进行PK，<code>ZXID</code>最大的服务器优先。</li></ul></li></ul></li></ul></li><li>统计投票</li><li>改变服务器状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: 选自己当领导</div><div class="line">broadcase=&gt;operation: 广播投票信息</div><div class="line">looking=&gt;condition: Looking(第一次，第n次)</div><div class="line">first=&gt;inputoutput: 第一次</div><div class="line">n=&gt;inputoutput: 第n次</div><div class="line">resultState=&gt;operation: 投票结果状态</div><div class="line">old=&gt;condition: 投票是否过期?</div><div class="line">clear=&gt;operation: 清空投票信息</div><div class="line">update=&gt;operation: 更新投票信息</div><div class="line">record=&gt;operation: 记录投票信息</div><div class="line">finish=&gt;operation: 判断投票是否完成</div><div class="line">comfirm=&gt;operation: 确认领导</div><div class="line">same=&gt;operation: 是否为同一轮</div><div class="line">recordOld=&gt;operation: 记录已完成投票</div><div class="line">e=&gt;end</div><div class="line"></div><div class="line">st-&gt;broadcase-&gt;looking-&gt;resultState-&gt;old</div><div class="line">looking(yes)-&gt;first-&gt;resultState-&gt;old</div><div class="line">old(yes)-&gt;clear-&gt;update</div><div class="line">old(no)-&gt;update-&gt;record-&gt;comfirm</div><div class="line">looking(no)-&gt;n-&gt;same-&gt;recordOld-&gt;finish-&gt;comfirm</div><div class="line">update-&gt;record-&gt;finish-&gt;comfirm</div></pre></td></tr></table></figure><p><strong>流程图如果无法正常显示，请复制粘贴到支持流程图的编辑器内查看</strong></p>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curator提供应用场景的封装</title>
      <link href="/zk/interface.html"/>
      <url>/zk/interface.html</url>
      
        <content type="html"><![CDATA[<h3 id="针对Zookeeper能够实现的应用封装"><a href="#针对Zookeeper能够实现的应用封装" class="headerlink" title="针对Zookeeper能够实现的应用封装"></a>针对Zookeeper能够实现的应用封装</h3><ul><li>Master/leader选举</li><li>分布式锁（读锁/写锁）</li><li>分布式队列</li><li>…</li></ul><a id="more"></a><h3 id="curator-reciples提供的API"><a href="#curator-reciples提供的API" class="headerlink" title="curator-reciples提供的API"></a>curator-reciples提供的API</h3><ul><li>LeaderLatch<ul><li>阻塞</li><li>都一起去抢，后续没抢到的等待</li></ul></li><li>LeaderSelector<ul><li>自动抢</li><li>带有序节点的选举过程，根据最小节点来获得优先权，用完以后释放，下一个节点继续去用</li></ul></li></ul><h3 id="对于网络抖动的处理"><a href="#对于网络抖动的处理" class="headerlink" title="对于网络抖动的处理"></a>对于网络抖动的处理</h3><ul><li>对于网络抖动，如果本次抢master的节点之前是master，那就继续用本地节点当master.</li><li>客户端和服务端建立一个连接是建立一个session，如果出现网络不稳定或异常情况下，消息传输可能会出现丢包，如果出现丢包，客户端则认为session已经失效，实际上master并没有失效。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.curator.scene;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</div><div class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</div><div class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 30/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSelector</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">""</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String MASTER_PATH=<span class="string">"/curator_master_path"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        CuratorFramework curatorFramework = CuratorFrameworkFactory.builder().connectString(CONNECTSTRING).retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>,<span class="number">3</span>)).build();</div><div class="line">        LeaderSelector leaderSelector=<span class="keyword">new</span> LeaderSelector(curatorFramework, MASTER_PATH, <span class="keyword">new</span> LeaderSelectorListenerAdapter() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework curatorFramework)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                System.out.println(<span class="string">"获得leader成功"</span>);</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//自动争抢</span></div><div class="line">        leaderSelector.autoRequeue();</div><div class="line">        <span class="comment">//开始选举</span></div><div class="line">        leaderSelector.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的实际应用场景</title>
      <link href="/zk/situation.html"/>
      <url>/zk/situation.html</url>
      
        <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><a id="more"></a><ul><li>订阅发布<ul><li>watcher机制</li><li>统一配置管理(disconf)</li></ul></li><li>分布式锁<ul><li>redis</li><li>Zookeeper</li><li>数据库</li></ul></li><li>负载均衡</li><li>ID生成器</li><li>分布式队列</li><li>统一命名服务</li><li>master选举</li></ul><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="数据发布订阅-配置中心"><a href="#数据发布订阅-配置中心" class="headerlink" title="数据发布订阅/配置中心"></a>数据发布订阅/配置中心</h4><blockquote><p>实现配置信息的集中式管理和数据的动态更新。</p><p>把配置信息全部放到Zookeeper上，保存在某个目录节点中，所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到Zookeeper的通知，然后从Zookeeper获取新的配置信息应用到系统中</p></blockquote><ul><li>实现配置中心的两种模式<ul><li><code>push</code>：服务端发生变化主动发送给客户端</li><li><code>pull</code>：客户端主动发起请求获取新的数据<ul><li>长轮训：客户端主动监控服务器端的变化</li></ul></li></ul></li></ul><ul><li>Zookeeper采用推拉相结合的方式<ul><li>客户端向服务器端注册需要关注的节点，一旦节点数据发生变化，那么服务器端就会向客户端发送watcher事件通知。</li><li>客户端收到通知后，主动到服务器端获取更新后的数据</li></ul></li></ul><ul><li>优点<ul><li>数据量比较小</li><li>数据内容在运行时会发生动态变更</li><li>集群中的各个机器共享配置</li></ul></li></ul><h4 id="布式锁"><a href="#布式锁" class="headerlink" title="布式锁"></a>布式锁</h4><ul><li>锁服务的分类<ul><li>保持独占<ul><li>将Zookeeper上的一个zNode看作一把锁，通过createZnode方式来实现，所有客户端创建/distribute_lock节点，最终成功创建的那个客户端拥有了这把锁，用完删掉自己创建的节点就释放出锁</li></ul></li><li>控制时序<ul><li>/distribute_lock已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，编号最小的获得锁，用完删除，依次进行</li></ul></li></ul></li><li>实现分布式锁的方式<ul><li>redis<ul><li>setNX<ul><li>存在则会返回0</li><li>不存在则返回数据</li></ul></li></ul></li><li>数据库<ul><li>创建表<ul><li>通过索引唯一的方式(create table(id,methodname…))methodname增加唯一索引。insert成功则获得锁</li><li>效率低</li><li>delete失败会导致后续进程无法获取锁</li></ul></li></ul></li><li>Zookeeper<ul><li>排他锁（写锁）</li><li>共享锁（读锁）</li></ul></li></ul></li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>通过集群的方式分摊请求/数据到多个计算机单元上</p></blockquote><ul><li>集群的关注点<ul><li>是否有机器退出和加入<ul><li>所有的机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与Zookeeper的连接断开，其所创建的临时目录节点被删除，其它机器都收到该节点被删除的通知。新机器加入也同理。</li></ul></li><li>选举master<ul><li>Zookeeper有选举选法</li></ul></li></ul></li></ul><h4 id="队列管理"><a href="#队列管理" class="headerlink" title="队列管理"></a>队列管理</h4><ul><li>同步队列<ul><li>每一个队列的成功都聚齐时，这个队列才可用，否则一直等待所有成员到达<ul><li>在约定目录下创建临时目录节点，监听节点数据是否时我们要求的树木</li></ul></li></ul></li><li>FIFO队列<ul><li>和分布式锁服务中的控制时许场景基本原理一致，入列有编号，出列按编号</li></ul></li></ul><h4 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h4><blockquote><p>分布式环境下，经常需要对应用/服务进行统一命名，便于识别不同服务。类似于域名与ip之间对应关系，域名容易记住。通过名称来获取资源或服务的地址、提供者等信息按照层次结构组织服务/应用名称可将名称以及地址信息写到Zookeeper上，客户端通过Zookeeper获取可用服务列表类。</p></blockquote><h4 id="master选举"><a href="#master选举" class="headerlink" title="master选举"></a>master选举</h4><blockquote><p> 要保证服务7*24小时可用，通过心跳包来维持正常通信状态 ，如果master挂掉，slave就需要重新选举master。可能会产生脑裂的问题。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="Java-API实现共享锁"><a href="#Java-API实现共享锁" class="headerlink" title="Java API实现共享锁"></a>Java API实现共享锁</h4><p><strong>ZookeeperClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 27/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperClient</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSessionTime</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sessionTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTime=<span class="number">5000</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取连接</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZooKeeper <span class="title">getInstance</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        ZooKeeper zooKeeper=<span class="keyword">new</span> ZooKeeper(CONNECTSTRING, sessionTime, <span class="keyword">new</span> Watcher() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (watchedEvent.getState()==Event.KeeperState.SyncConnected)&#123;</div><div class="line">                    countDownLatch.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        countDownLatch.await();</div><div class="line">        <span class="keyword">return</span> zooKeeper;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>LockWatcher</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 27/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>  CountDownLatch latch;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockWatcher</span><span class="params">(CountDownLatch countDownLatch)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.latch=countDownLatch;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(watchedEvent.getType()== Event.EventType.NodeDeleted)&#123;</div><div class="line">            latch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>DistributeLock</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.lock;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.SortedSet;</div><div class="line"><span class="keyword">import</span> java.util.TreeSet;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 27/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeLock</span> </span>&#123;</div><div class="line">    <span class="comment">//根节点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROOT_LOCKS = <span class="string">"/LOCKS"</span>;</div><div class="line">    <span class="keyword">private</span> ZooKeeper zooKeeper;</div><div class="line">    <span class="comment">//会话超时时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout;</div><div class="line">    <span class="keyword">private</span> String lockID;<span class="comment">//记录锁节点ID</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] data = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">//节点数据</span></div><div class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributeLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">        <span class="keyword">this</span>.zooKeeper = ZookeeperClient.getInstance();</div><div class="line">        <span class="keyword">this</span>.sessionTimeout = ZookeeperClient.getSessionTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取锁</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lockID = zooKeeper.create(ROOT_LOCKS + <span class="string">"/"</span>, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"---"</span> + <span class="string">"成功创建了---"</span> + lockID + <span class="string">"开始去竞争锁"</span>);</div><div class="line"></div><div class="line">            List&lt;String&gt; childrenNodes = zooKeeper.getChildren(ROOT_LOCKS, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">            <span class="comment">//从小到大排序</span></div><div class="line">            SortedSet&lt;String&gt; sortedSet = <span class="keyword">new</span> TreeSet&lt;String&gt;();</div><div class="line">            <span class="keyword">for</span> (String children : childrenNodes) &#123;</div><div class="line">                sortedSet.add(ROOT_LOCKS + <span class="string">"/"</span> + children);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            String first = sortedSet.first();<span class="comment">//拿到最小节点</span></div><div class="line">            <span class="keyword">if</span> (lockID.equals(first)) &#123;</div><div class="line">                <span class="comment">//表示当前节点为最小节点</span></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功获取锁---"</span> + lockID);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            SortedSet&lt;String&gt; lessThanLockId = sortedSet.headSet(lockID);</div><div class="line">            <span class="keyword">if</span> (!lessThanLockId.isEmpty()) &#123;</div><div class="line">                <span class="comment">//拿到比当前lockID更小的上一个节点</span></div><div class="line">                String prevLogID = lessThanLockId.last();</div><div class="line">                zooKeeper.exists(prevLogID, <span class="keyword">new</span> LockWatcher(countDownLatch));</div><div class="line">                countDownLatch.await(sessionTimeout, TimeUnit.MILLISECONDS);</div><div class="line">                <span class="comment">//上面这段代码意味着会话超时或节点被删除就可以获取锁了</span></div><div class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"成功获取锁---"</span> + lockID);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 释放锁</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"---开始释放锁--- "</span> + lockID);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            zooKeeper.delete(lockID, -<span class="number">1</span>);</div><div class="line">            System.out.println(lockID + <span class="string">"---被删除"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">                DistributeLock lock = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock = <span class="keyword">new</span> DistributeLock();</div><div class="line">                    latch.countDown();</div><div class="line">                    latch.await();</div><div class="line">                    lock.lock();</div><div class="line">                    Thread.sleep(random.nextInt(<span class="number">500</span>));</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</div><div class="line">                        lock.unlock();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>需要在Zookeeper服务器上创建<code>/LOCKS</code>根节点后再运行代码</strong></p><h4 id="master选举-1"><a href="#master选举-1" class="headerlink" title="master选举"></a>master选举</h4><p><strong>UserCenter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.master;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 28/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCenter</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mc_id;<span class="comment">//机器信息</span></div><div class="line">    <span class="keyword">private</span> String mc_name;<span class="comment">//机器名称</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMc_id</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mc_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMc_id</span><span class="params">(<span class="keyword">int</span> mc_id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mc_id = mc_id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMc_name</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> mc_name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMc_name</span><span class="params">(String mc_name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mc_name = mc_name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>MasterSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.master;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.exception.ZkNodeExistsException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 28/10/2017.</span></div><div class="line"><span class="comment"> * 选主的服务</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterSelector</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> ZkClient zkClient;</div><div class="line">    <span class="comment">//需要争抢的节点</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String MASTER_PATH = <span class="string">"/master"</span>;</div><div class="line">    <span class="comment">//注册节点内容变化</span></div><div class="line">    <span class="keyword">private</span> IZkDataListener dataListener;</div><div class="line">    <span class="comment">//其它服务器</span></div><div class="line">    <span class="keyword">private</span> UserCenter server;</div><div class="line">    <span class="comment">//主服务器</span></div><div class="line">    <span class="keyword">private</span> UserCenter master;</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MasterSelector</span><span class="params">(UserCenter center,ZkClient client)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.server=center;</div><div class="line">        <span class="keyword">this</span>.zkClient=client;</div><div class="line">        <span class="keyword">this</span>.dataListener = <span class="keyword">new</span> IZkDataListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="comment">//如果节点被删除，发起选主操作</span></div><div class="line">                System.out.println(<span class="string">"触发节点删除事件"</span>+s);</div><div class="line">                chooseMaster();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 开始选举</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"启动操作"</span>);</div><div class="line">        <span class="keyword">if</span> (!isRunning) &#123;</div><div class="line">            isRunning = <span class="keyword">true</span>;</div><div class="line">            zkClient.subscribeDataChanges(MASTER_PATH, dataListener);<span class="comment">//注册节点监听事件</span></div><div class="line">            chooseMaster();</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 停止选举</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (isRunning) &#123;</div><div class="line">            System.out.println(<span class="string">"停止操作"</span>);</div><div class="line">            isRunning = <span class="keyword">false</span>;</div><div class="line">            zkClient.unsubscribeDataChanges(MASTER_PATH,dataListener);</div><div class="line">            releaseMaster();</div><div class="line">            scheduledExecutorService.shutdown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 选主</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">chooseMaster</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isRunning) &#123;</div><div class="line">            System.out.println(<span class="string">"当前服务没有启动"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            zkClient.createEphemeral(MASTER_PATH, server);</div><div class="line">            <span class="comment">//创建成功则代表当前节点就是master节点</span></div><div class="line">            master = server;</div><div class="line">            System.out.println(master.getMc_name() + <span class="string">"---是master"</span>);</div><div class="line"></div><div class="line">            <span class="comment">//定时器</span></div><div class="line">            <span class="comment">//模仿master出现故障,每5秒钟释放一次锁</span></div><div class="line">            scheduledExecutorService.schedule(() -&gt; &#123;</div><div class="line">                <span class="comment">//释放锁</span></div><div class="line">                releaseMaster();</div><div class="line">            &#125;, <span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</div><div class="line">            <span class="comment">//master已经存在，获取master</span></div><div class="line">            UserCenter userCenter = zkClient.readData(MASTER_PATH, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">if</span> (userCenter == <span class="keyword">null</span>) &#123;</div><div class="line">                chooseMaster();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                master = userCenter;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 释放锁</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseMaster</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//释放锁(故障模拟过程)</span></div><div class="line">        <span class="comment">//判断当前是不是master</span></div><div class="line">        <span class="comment">//只有master才需要释放锁</span></div><div class="line">        <span class="keyword">if</span> (checkIsMaster()) &#123;</div><div class="line">            zkClient.delete(MASTER_PATH);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 判断当前的server是不是master</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkIsMaster</span><span class="params">()</span> </span>&#123;</div><div class="line">        UserCenter userCenter = zkClient.readData(MASTER_PATH);</div><div class="line">        <span class="keyword">if</span> (userCenter.getMc_name().equals(server.getMc_name())) &#123;</div><div class="line">            master = userCenter;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>MasterChooseTest</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.master;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.serialize.SerializableSerializer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 29/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterChooseTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//保存所有的zkClient列表</span></div><div class="line">        List&lt;ZkClient&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        List&lt;MasterSelector&gt; selectorList=<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                ZkClient client = <span class="keyword">new</span> ZkClient(CONNECTSTRING, <span class="number">5000</span>, <span class="number">5000</span>, <span class="keyword">new</span> SerializableSerializer());</div><div class="line">                clients.add(client);</div><div class="line"></div><div class="line">                UserCenter center = <span class="keyword">new</span> UserCenter();</div><div class="line">                center.setMc_id(i);</div><div class="line">                center.setMc_name(<span class="string">"客户端"</span> + i);</div><div class="line">                <span class="comment">//不是线程，是10个对象</span></div><div class="line">                <span class="comment">//每个客户端去触发一次</span></div><div class="line">                <span class="comment">//没办法让每个客户端都监听，只能监听其中一个</span></div><div class="line"></div><div class="line">                <span class="comment">//10个客户端去抢master，只有一个会抢到</span></div><div class="line">                MasterSelector selector = <span class="keyword">new</span> MasterSelector(center,client);</div><div class="line">                selectorList.add(selector);</div><div class="line"></div><div class="line">                selector.start();</div><div class="line"></div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">4</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">for</span>(MasterSelector selector :selectorList)&#123;</div><div class="line">                selector.stop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper客户端</title>
      <link href="/zk/client.html"/>
      <url>/zk/client.html</url>
      
        <content type="html"><![CDATA[<h3 id="ZkClient"><a href="#ZkClient" class="headerlink" title="ZkClient"></a>ZkClient</h3><blockquote><p>永久监听的封装</p></blockquote><h5 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h5><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//建立连接</span></div><div class="line">ZkClient zkClient=<span class="keyword">new</span> ZkClient(CONNECTSTRING,<span class="number">4000</span>);</div><div class="line">System.out.println(zkClient+<span class="string">"---success"</span>);</div></pre></td></tr></table></figure><h5 id="创建子节点"><a href="#创建子节点" class="headerlink" title="创建子节点"></a>创建子节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//递归创建节点</span></div><div class="line"><span class="comment">//内部实现：当父节点不存在时，会报异常，在catch里判断第二个参数(是否创建父节点)</span></div><div class="line"><span class="comment">//如果为false：则直接将异常抛出</span></div><div class="line"><span class="comment">//如果为true：截取节点路径，获取父节点，先创建父节点，再创建子节点</span></div><div class="line">       client.createPersistent(<span class="string">"/zkClientParent/zkClientSon"</span>,<span class="keyword">true</span>);</div></pre></td></tr></table></figure><h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除节点</span></div><div class="line"><span class="comment">//如果存在子节点，则递归删除子节点</span></div><div class="line">client.deleteRecursive(<span class="string">"/zkRootNode"</span>);</div></pre></td></tr></table></figure><h5 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取子节点</span></div><div class="line">List&lt;String&gt; children= client.getChildren(<span class="string">"/zkParent"</span>);</div><div class="line">System.out.println(children);</div></pre></td></tr></table></figure><h5 id="修改节点"><a href="#修改节点" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">client.writeData(<span class="string">"/zkParent"</span>, <span class="string">"123"</span>);</div></pre></td></tr></table></figure><h5 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//watch</span></div><div class="line">client.subscribeDataChanges(<span class="string">"/zkParent"</span>, <span class="keyword">new</span> IZkDataListener() &#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    System.out.println(<span class="string">"change:"</span> + s + <span class="string">"---"</span> + o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    System.out.println(<span class="string">"delete:"</span> + s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h5 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.zkclient;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</div><div class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 25/10/2017.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClientApiOperatorDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">""</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZkClient <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZkClient(CONNECTSTRING, <span class="number">5000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        ZkClient client = getInstance();</div><div class="line">      </div><div class="line">        <span class="comment">//递归创建节点</span></div><div class="line">        <span class="comment">//内部实现：当父节点不存在时，会报异常，在catch里判断第二个参数(是否创建父节点)</span></div><div class="line">        <span class="comment">//如果为false：则直接将异常抛出</span></div><div class="line">        <span class="comment">//如果为true：截取节点路径，获取父节点，先创建父节点，再创建子节点</span></div><div class="line">        client.createPersistent(<span class="string">"/zkParent/zkSon/zksuperson"</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">//获取子节点</span></div><div class="line">        List&lt;String&gt; children = client.getChildren(<span class="string">"/zkParent"</span>);</div><div class="line">        System.out.println(children);</div><div class="line"></div><div class="line">        <span class="comment">//watch</span></div><div class="line">        client.subscribeDataChanges(<span class="string">"/zkParent"</span>, <span class="keyword">new</span> IZkDataListener() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                System.out.println(<span class="string">"change:"</span> + s + <span class="string">"---"</span> + o);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                System.out.println(<span class="string">"delete:"</span> + s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//修改节点</span></div><div class="line">        client.writeData(<span class="string">"/zkParent"</span>, <span class="string">"123"</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="comment">//删除节点</span></div><div class="line">        <span class="keyword">boolean</span> result = client.deleteRecursive(<span class="string">"/zkParent"</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>Curator本身是Netflix公司开源的zookeeper客户端；</p><p>curator提供了各种应用场景的实现封装</p><p>curator-framework  提供了fluent风格api</p><p>curator-replice     提供了实现封装</p></blockquote><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul><li>和Zookeeper原生客户端相比<ul><li>接口和API的层次更加抽象化，简化Zookeeper原生客户端的开发量</li></ul></li><li>和ZkClient相比<ul><li>处理更加优美</li><li>异常处理比较好<ul><li>比如节点不存在可以通过exists判断，但是ZkClient直接在catch中处理了。</li></ul></li></ul></li></ul><h5 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建会话的两种方式</span></div><div class="line"></div><div class="line"><span class="comment">//1.正常的方式</span></div><div class="line">CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(CONNECTSTRING, <span class="number">5000</span>,</div><div class="line">                <span class="number">5000</span>, <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</div><div class="line"><span class="comment">//启动连接</span></div><div class="line">curatorFramework.start();</div><div class="line"></div><div class="line"><span class="comment">//2.flunt风格</span></div><div class="line"><span class="comment">//namespace指定所有会话均在此节点下创建，可省略</span></div><div class="line">CuratorFramework curatorFrameworkFlunt=CuratorFrameworkFactory.builder().connectString(CONNECTSTRING).sessionTimeoutMs(<span class="number">5000</span>).</div><div class="line">retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>)).namespace(<span class="string">"/curator"</span>).build();</div><div class="line"><span class="comment">//启动连接</span></div><div class="line">curatorFrameworkFlunt.start();</div><div class="line">System.out.println(<span class="string">"success"</span>);</div></pre></td></tr></table></figure><h5 id="curator连接的重试策略"><a href="#curator连接的重试策略" class="headerlink" title="curator连接的重试策略"></a>curator连接的重试策略</h5><ul><li><code>ExponentialBackoffRetry()</code>  衰减重试 </li><li><code>RetryNTimes</code> 指定最大重试次数</li><li><code>RetryOneTime</code> 仅重试一次</li><li><code>RetryUnitilElapsed</code> 一直重试直到规定的时间</li></ul><h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">String result=curatorFramework.create().creatingParentContainersIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/curator/curator1/curator11"</span>,<span class="string">"123"</span>.getBytes());</div><div class="line">System.out.println(result);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Stat stat=<span class="keyword">new</span> Stat();</div><div class="line">    <span class="comment">//节点的状态信息</span></div><div class="line">    <span class="comment">//storingStatIn把节点的状态信息存在一个变量里最终返回</span></div><div class="line"><span class="comment">//状态信息对应的名称可以去Stat源码里看</span></div><div class="line">    <span class="keyword">byte</span>[] data=curatorFramework.getData().storingStatIn(stat).forPath(<span class="string">"/curator"</span>);</div><div class="line">System.out.println(<span class="keyword">new</span> String(data)+<span class="string">"---stat---"</span>+stat);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="修改节点-1"><a href="#修改节点-1" class="headerlink" title="修改节点"></a>修改节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//修改数据</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">Stat stat=curatorFramework.setData().forPath(<span class="string">"/curator"</span>,<span class="string">"123"</span>.getBytes());</div><div class="line">System.out.println(stat);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;   </div><div class="line">  <span class="comment">//只写根节点，递归删除子节点</span></div><div class="line">  <span class="comment">//默认情况下，version为-1</span></div><div class="line">  curatorFramework.delete().deletingChildrenIfNeeded().forPath(<span class="string">"/curator"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//异步操作</span></div><div class="line"><span class="comment">//有时候操作可能消耗时间较长，会处于阻塞，无法执行后续流程，可以使用异步操作</span></div><div class="line"></div><div class="line"><span class="comment">//Java5以后</span></div><div class="line">ExecutorService service= Executors.newFixedThreadPool(<span class="number">1</span>);</div><div class="line"><span class="keyword">final</span> CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="comment">//PS:创建节点的事件是由线程池去处理的，而不是当前线程</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> String result=curatorFramework.create().creatingParentContainersIfNeeded().withMode(CreateMode.PERSISTENT).inBackground(<span class="keyword">new</span> BackgroundCallback() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processResult</span><span class="params">(CuratorFramework curatorFramework, CuratorEvent curatorEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="comment">//操作完成后的回调</span></div><div class="line">            <span class="comment">//当前线程名---响应后的结果码---当前操作类型</span></div><div class="line">            <span class="comment">//main-EventThread----0---CREATE</span></div><div class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"----"</span>+curatorEvent.getResultCode()+<span class="string">"---"</span>+curatorEvent.getType());</div><div class="line">            countDownLatch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;).forPath(<span class="string">"/curatorTest/curator1/curator11"</span>,<span class="string">"777"</span>.getBytes());</div><div class="line">    System.out.println(<span class="string">"result:"</span>+result);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div><div class="line"></div><div class="line">countDownLatch.await();</div><div class="line">service.shutdown();</div></pre></td></tr></table></figure><h5 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//import org.apache.curator.framework.api.transaction.CuratorTransactionResult;</span></div><div class="line"><span class="comment">//事务操作</span></div><div class="line"><span class="comment">//curator独有</span></div><div class="line"><span class="comment">//提供一个封装的操作可以允许事务性操作</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//创建和修改是绑定在一个事务里，执行完成后再提交事务</span></div><div class="line">    <span class="comment">//修改的节点并不存在,会报错org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode，并且trans节点不会被创建</span></div><div class="line">    <span class="comment">//修改的节点存在，则会成功输出结果</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    Collection&lt;CuratorTransactionResult&gt; resultCollection=curatorFramework.inTransaction().create()</div><div class="line">            .forPath(<span class="string">"/trans"</span>,<span class="string">"111"</span>.getBytes()).and().setData().forPath(<span class="string">"/curatorTest"</span>,<span class="string">"111"</span>.getBytes()).and().commit();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (CuratorTransactionResult result:resultCollection)&#123;</div><div class="line">        System.out.println(result.getForPath()+<span class="string">"---"</span>+result.getType());</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h5 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h5><ul><li>封装了三种watch来做节点的监听<ul><li><code>PathChildrenCache</code>：监视一个路径下子节点的创建、删除、以及节点数据更新</li><li><code>NodeCache</code>：监视一个节点的创建、更新、删除并且会将节点的数据缓存到本地</li><li><code>treecache</code>：pathcache和nodecache的合体（监视路径下的创建、更新、删除事件并且还会缓存路径下的所有子节点的数据）</li></ul></li></ul><p><strong>NodeCache</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">CuratorFramework curatorFramework=CuratorClientUtil.getInstance();</div><div class="line"></div><div class="line">curatorFramework.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/curator"</span>,<span class="string">"111"</span>.getBytes());</div><div class="line"></div><div class="line"><span class="keyword">final</span> NodeCache nodeCache=<span class="keyword">new</span> NodeCache(curatorFramework,<span class="string">"/curator"</span>,<span class="keyword">false</span>);</div><div class="line">nodeCache.start(<span class="keyword">true</span>);<span class="comment">//启动时把初始操作做了构造</span></div><div class="line"></div><div class="line">nodeCache.getListenable().addListener(()-&gt; System.out.println(<span class="string">"节点数据发生变化，结果---"</span>+<span class="keyword">new</span> String(nodeCache.getCurrentData().getData())));</div><div class="line"></div><div class="line">curatorFramework.setData().forPath(<span class="string">"/curator"</span>,<span class="string">"123"</span>.getBytes());</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div></pre></td></tr></table></figure><p><strong>PathChildrenCache</strong></p><ul><li><code>PathChildrenCache.StartMode</code><ul><li><code>NORMAL</code>：初始化时为空</li><li><code>BUILD_INITIAL_CACHE</code>：在这个方法返回之前调用rebuild操作</li><li><code>POST_INITIALIZED_EVENT</code>：当cache初始化数据后发送一个PathChildrenCache事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">pathChildrenCache.getListenable().addListener((curatorFramework1, pathChildrenCacheEvent) -&gt; &#123;</div><div class="line">    <span class="keyword">switch</span> (pathChildrenCacheEvent.getType()) &#123;</div><div class="line">        <span class="keyword">case</span> INITIALIZED:</div><div class="line">            System.out.println(<span class="string">"INITIALIZED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CHILD_ADDED:</div><div class="line">            System.out.println(<span class="string">"CHILD_ADDED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CHILD_REMOVED:</div><div class="line">            System.out.println(<span class="string">"CHILD_REMOVED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CHILD_UPDATED:</div><div class="line">            System.out.println(<span class="string">"CHILD_UPDATED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CONNECTION_LOST:</div><div class="line">            System.out.println(<span class="string">"CONNECTION_LOST"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CONNECTION_SUSPENDED:</div><div class="line">            System.out.println(<span class="string">"CONNECTION_SUSPENDED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> CONNECTION_RECONNECTED:</div><div class="line">            System.out.println(<span class="string">"CONNECTION_RECONNECTED"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/event"</span>, <span class="string">"event"</span>.getBytes());</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line">System.out.println(<span class="string">"create event"</span>);</div><div class="line"></div><div class="line">curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/event/event1"</span>, <span class="string">"event"</span>.getBytes());</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">curatorFramework.setData().forPath(<span class="string">"/event/event1"</span>, <span class="string">"222"</span>.getBytes());</div><div class="line">TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">curatorFramework.delete().forPath(<span class="string">"/event/event1"</span>);</div><div class="line">curatorFramework.delete().forPath(<span class="string">"/event"</span>);</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper节点权限示例代码</title>
      <link href="/zk/node.html"/>
      <url>/zk/node.html</url>
      
        <content type="html"><![CDATA[<p>通过权限控制节点操作</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.javaapi;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.ACL;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Id;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 25/10/2017.</span></div><div class="line"><span class="comment"> * 权限控制</span></div><div class="line"><span class="comment"> * 主要用于一些比较隐私的数据节点，不能随意变化的数据，通过权限去控制节点</span></div><div class="line"><span class="comment"> * ACL：CREATE/DELETE/ADMIN/READ/WRITE</span></div><div class="line"><span class="comment"> * &lt;p&gt;</span></div><div class="line"><span class="comment"> * 权限模式</span></div><div class="line"><span class="comment"> * 可以通过几种方式去控制节点的读写操作</span></div><div class="line"><span class="comment"> * schema：授权对象/ip/digest(账号密码)/world(开放权限)/super</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthControlDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">""</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stat stat = <span class="keyword">new</span> Stat();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</div><div class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(CONNECTSTRING, <span class="number">5000</span>, <span class="keyword">new</span> AuthControlDemo());</div><div class="line">        countDownLatch.await();</div><div class="line"></div><div class="line">        ACL digestAcl = <span class="keyword">new</span> ACL(ZooDefs.Perms.CREATE, <span class="keyword">new</span> Id(<span class="string">"digest"</span>, <span class="string">"root:root"</span>));</div><div class="line">        List&lt;ACL&gt; acls = <span class="keyword">new</span> ArrayList&lt;ACL&gt;();</div><div class="line">        acls.add(digestAcl);</div><div class="line"></div><div class="line"></div><div class="line">        zooKeeper.create(<span class="string">"/auth1"</span>, <span class="string">"123"</span>.getBytes(), acls, CreateMode.PERSISTENT);</div><div class="line">        zooKeeper.addAuthInfo(<span class="string">"digest"</span>, <span class="string">"root:root"</span>.getBytes());</div><div class="line"></div><div class="line">        <span class="comment">//ZooDefs.Ids.OPEN_ACL_UNSAFE, 则可以删除成功</span></div><div class="line">        zooKeeper.create(<span class="string">"/auth"</span>, <span class="string">"123"</span>.getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);</div><div class="line">        zooKeeper.create(<span class="string">"/auth/auth1-1"</span>, <span class="string">"456"</span>.getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);</div><div class="line"></div><div class="line">        <span class="comment">//新创建客户端对象去删除</span></div><div class="line">        ZooKeeper zooKeeper1 = <span class="keyword">new</span> ZooKeeper(CONNECTSTRING, <span class="number">5000</span>, <span class="keyword">new</span> AuthControlDemo());</div><div class="line">        countDownLatch2.await();</div><div class="line">        <span class="comment">//添加权限信息</span></div><div class="line">        zooKeeper1.addAuthInfo(<span class="string">"digest"</span>, <span class="string">"root:root"</span>.getBytes());</div><div class="line">        zooKeeper1.delete(<span class="string">"/auth/auth1-1"</span>, -<span class="number">1</span>);</div><div class="line">        zooKeeper1.delete(<span class="string">"/auth"</span>, -<span class="number">1</span>);</div><div class="line">        zooKeeper1.delete(<span class="string">"/auth1"</span>, -<span class="number">1</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提供两种监听</span></div><div class="line"><span class="comment">     * 1.连接状态；2.事件监听</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> watchedEvent</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 如果当前的连接状态是连接成功，那么就通过计数器去控制</span></div><div class="line">        <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected) &#123;</div><div class="line">            <span class="keyword">if</span> (Event.EventType.None == watchedEvent.getType() &amp;&amp; <span class="keyword">null</span> == watchedEvent.getPath()) &#123;</div><div class="line">                countDownLatch.countDown();</div><div class="line">                countDownLatch2.countDown();</div><div class="line">                System.out.println(watchedEvent.getState() + <span class="string">"---&gt;"</span> + watchedEvent.getType());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper Java API 使用</title>
      <link href="/zk/api.html"/>
      <url>/zk/api.html</url>
      
        <content type="html"><![CDATA[<h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bai.javaapi;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.*;</div><div class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Created by 2bai on 24/10/2017.</span></div><div class="line"><span class="comment"> * 一般情况下，不需要客户端手动注册监听事件</span></div><div class="line"><span class="comment"> * 此处只为演示原生API使用</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiOperatorDemo</span> <span class="keyword">implements</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONNECTSTRING = <span class="string">"123.57.3.144:2184"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ZooKeeper zooKeeper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stat stat = <span class="keyword">new</span> Stat();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</div><div class="line">        zooKeeper = <span class="keyword">new</span> ZooKeeper(CONNECTSTRING, <span class="number">5000</span>, <span class="keyword">new</span> ApiOperatorDemo());</div><div class="line">        countDownLatch.await();</div><div class="line">        System.out.println(zooKeeper.getState());</div><div class="line">        <span class="comment">// 创建结果</span></div><div class="line">        String result = zooKeeper.create(<span class="string">"/test"</span>, <span class="string">"123"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);</div><div class="line">        <span class="comment">// 增加一个watch</span></div><div class="line">        zooKeeper.getData(<span class="string">"/test"</span>, <span class="keyword">new</span> ApiOperatorDemo(), stat);</div><div class="line">        System.out.println(<span class="string">"创建结果："</span> + result);</div><div class="line"></div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 修改数据</span></div><div class="line">        <span class="comment">// -1表示忽略版本号</span></div><div class="line">        zooKeeper.setData(<span class="string">"/test"</span>, <span class="string">"456"</span>.getBytes(), -<span class="number">1</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 再次修改，测试watch事件是一次性的</span></div><div class="line">        zooKeeper.setData(<span class="string">"/test"</span>, <span class="string">"789"</span>.getBytes(), -<span class="number">1</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 数据删除</span></div><div class="line">        zooKeeper.delete(<span class="string">"/test"</span>, -<span class="number">1</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</div><div class="line"></div><div class="line"></div><div class="line">        String re = <span class="string">""</span>;</div><div class="line">        <span class="comment">//创建节点和子节点</span></div><div class="line">        String fatherNodePath = <span class="string">"/testChild"</span>;</div><div class="line">        String sonNodePath=<span class="string">"/test"</span>;</div><div class="line"></div><div class="line">        stat = zooKeeper.exists(fatherNodePath+sonNodePath, <span class="keyword">true</span>);</div><div class="line">        <span class="comment">//节点不存在</span></div><div class="line">        System.out.println(stat);</div><div class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//先删除子节点</span></div><div class="line">            zooKeeper.delete(fatherNodePath + sonNodePath, -<span class="number">1</span>);</div><div class="line">            <span class="comment">//再删除父节点</span></div><div class="line">            zooKeeper.delete(fatherNodePath, -<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//临时节点下面不能挂载子节点</span></div><div class="line">        <span class="comment">//要挂载子节点必须创建持久化节点</span></div><div class="line">        re = zooKeeper.create(fatherNodePath, <span class="string">"123"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">        System.out.println(<span class="string">"创建/testChild节点成功---"</span> + re);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line">        re = zooKeeper.create(fatherNodePath + <span class="string">"/test"</span>, <span class="string">"456"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</div><div class="line">        System.out.println(<span class="string">"创建/testChild/test节点成功---"</span> + re);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//修改子路径</span></div><div class="line">        zooKeeper.setData(fatherNodePath + sonNodePath, <span class="string">"789"</span>.getBytes(), -<span class="number">1</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">//获取指定节点下的子节点</span></div><div class="line">        List&lt;String&gt; children=zooKeeper.getChildren(fatherNodePath+sonNodePath,<span class="keyword">true</span>);</div><div class="line">        System.out.println(children);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</div><div class="line">        <span class="comment">// 如果当前的连接状态是连接成功，那么就通过计数器去控制</span></div><div class="line">        <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected) &#123;</div><div class="line">            <span class="keyword">if</span> (Event.EventType.None == watchedEvent.getType() &amp;&amp; <span class="keyword">null</span> == watchedEvent.getPath()) &#123;</div><div class="line">                countDownLatch.countDown();</div><div class="line">                System.out.println(watchedEvent.getState() + <span class="string">"---&gt;"</span> + watchedEvent.getType());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">switch</span> (watchedEvent.getType()) &#123;</div><div class="line">                    <span class="keyword">case</span> None:</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> NodeCreated:<span class="comment">// 创建节点</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            System.out.println(<span class="string">"NodeCreated---路径:"</span> + watchedEvent.getPath() + <span class="string">"---值："</span> + zooKeeper.getData(watchedEvent.getPath(), <span class="keyword">true</span>, stat));</div><div class="line">                        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> NodeDeleted:<span class="comment">// 删除节点</span></div><div class="line">                        System.out.println(<span class="string">"NodeDeleted---路径:"</span> + watchedEvent.getPath());</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> NodeDataChanged:<span class="comment">// 修改节点</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            System.out.println(<span class="string">"NodeDataChanged---路径:"</span> + watchedEvent.getPath() + <span class="string">"---值："</span> + zooKeeper.getData(watchedEvent.getPath(), <span class="keyword">true</span>, stat));</div><div class="line">                        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> NodeChildrenChanged: <span class="comment">// 修改子节点</span></div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            System.out.println(<span class="string">"NodeChildrenChanged---路径:"</span> + watchedEvent.getPath() + <span class="string">"---值："</span> + zooKeeper.getData(watchedEvent.getPath(), <span class="keyword">true</span>, stat));</div><div class="line">                        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper的命令操作</title>
      <link href="/zk/command.html"/>
      <url>/zk/command.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><a id="more"></a><p><code>create [-s] [-e] path data acl</code></p><p><code>-s</code>：表示节点是否有序</p><p><code>-e</code>：表示是否为临时节点。默认是持久化节点</p><ul><li>临时节点不能创建子节点</li></ul><h3 id="获取指定path信息"><a href="#获取指定path信息" class="headerlink" title="获取指定path信息"></a>获取指定path信息</h3><p><code>get path [watch]</code></p><ul><li>path必须以<code>/</code>开始</li></ul><h3 id="修改节点path对应的data"><a href="#修改节点path对应的data" class="headerlink" title="修改节点path对应的data"></a>修改节点path对应的data</h3><p><code>set path data [version]</code></p><ul><li>version<ul><li>数据初次创建好，version为0</li><li>每次修改后，version会增加1</li><li>采用<a href="https://zh.wikipedia.org/wiki/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="external">乐观锁</a>的概念</li><li>数据库里面有一个version字段去控制数据行的版本号</li></ul></li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><code>delete path [version]</code></p><ul><li>删除节点必须从最底层的子节点逐层向上删除</li></ul><p><code>rmr</code></p><ul><li>rmr是一个递归删除命令, 如果发生指定节点拥有子节点时, rmr命令会首先删除子节点</li></ul><h3 id="stat信息"><a href="#stat信息" class="headerlink" title="stat信息"></a>stat信息</h3><p>表示节点状态信息</p><p><code>cversion = 0</code>       子节点的版本号</p><p><code>aclVersion = 0</code>     表示ACL的版本号，修改节点权限</p><p><code>dataVersion = 1</code>    表示的是当前节点数据的版本号</p><p> 版本只能加，不能回退。</p><p><code>czxid</code>    节点被创建时的事务ID</p><p><code>mzxid</code>   节点最后一次被更新的事务ID</p><p><code>pzxid</code>    当前节点下的子节点最后一次被修改时的事务ID</p><p><code>ctime = Sat Aug 05 20:48:26 CST 2017</code> 创建时间</p><p><code>mtime = Sat Aug 05 20:48:50 CST 2017</code> 修改事件</p><p><code>ephemeralOwner = 0x0</code>   创建临时节点的时候，会有一个sessionId 。 该值存储的就是这个sessionid</p><p><code>dataLength = 3</code>    数据值长度</p><p><code>numChildren = 0</code>  子节点数</p>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper中的一些概念</title>
      <link href="/zk/concept.html"/>
      <url>/zk/concept.html</url>
      
        <content type="html"><![CDATA[<p>Zookeeper序列化使用的是<code>Jute</code>。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>Zookeeper的数据模型和文件系统类似，每一个节点称为<code>znode</code>.是Zookeeper中的最小数据单元。每一个<code>znode</code>上都可以保存数据和挂载子节点。从而构成一个层次话的属性结构。默认存储大小为<code>3M</code>。</p><a id="more"></a><h3 id="zNode"><a href="#zNode" class="headerlink" title="zNode"></a>zNode</h3><ul><li>节点特性<ul><li>持久化节点<ul><li>节点创建后会一致存在zookeeper服务器上，直到主动删除</li></ul></li><li>持久化有序节点<ul><li>节点创建后会一直存在zookeeper服务器上，直到主动删除</li></ul></li><li>临时节点<ul><li>临时节点的声明周期和客户端的会话保持一致。</li><li>当客户端会话失效，该节点自动清理。<ul><li>会话失效后，会有一个重连机制，短时间内此节点存在，过了重连时间后，该节点自动清理</li></ul></li></ul></li><li>临时有序节点<ul><li>在临时节点上多了一个顺序性特性</li></ul></li></ul></li><li>节点名称区分大小写</li><li>子节点<ul><li>创建子节点操作要点<ul><li>先创建父节点<ul><li>直接创建父和子节点，会报错：<code>Node does not exist</code></li></ul></li><li>一定要输入完整的路径(包含父路径)</li><li>删除节点一定要从子节点逐层向上删除</li></ul></li><li>没有命令可以显示节点数<ul><li>想要知道节点数，可以自己递归计算</li></ul></li></ul></li></ul><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ul><li>Zookeeper中数据的两种类型<ul><li>内存数据</li><li>磁盘数据</li></ul></li></ul><p>Zookeeper会把节点信息存到内存里(<code>org.apache.zookeeper.server.DataTree</code>类中的<code>private final ConcurrentHashMap&lt;String, DataNode&gt; nodes = new ConcurrentHashMap&lt;String, DataNode&gt;();</code>),Zookeeper会定时把数据存储在磁盘上。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p> 客户端和zookeeper建立一个连接(无所谓哪个节点)</p><ul><li>会话状态</li></ul><p><code>NOT CONNECTED</code>-&gt;<code>CONNECTING</code>-&gt;<code>CONNECTED</code>-&gt;<code>CLOSED</code></p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li>Zookeeper提供了分布式数据发布/订阅，Zookeeper允许客户端向服务器注册一个watcher监听。</li><li>当服务器端的节点触发指定事件的时候会触发watcher，服务端会向客户端发送一个事件通知</li><li>watcher的通知是<strong>一次性</strong>，一旦触发一次通知后，该watcher就失效。如果需要永久监听，则需要反复注册</li><li>不关心客户端是否收到，只关心发出去了。</li><li>监听类型<ul><li>连接状态监听<ul><li><code>Event.KeeperState.Expired</code><ul><li>客户端和服务器之间在一个tickTime事件周期之内，客户端没有收到服务器端的通知，则认为当前会话已过期 ，客户端会废弃当前连接，并重建连接</li></ul></li><li><code>Event.KeeperState.Disconnected</code><ul><li>客户端主动断开</li></ul></li><li><code>Event.KeeperState.SyncConnected</code><ul><li>客户端和服务器端在某一个节点上建立连接，并完成了<code>version</code>和<code>zxid</code>的同步</li></ul></li><li><code>Event.KeeperState.AuthFailed</code><ul><li>授权失败</li></ul></li></ul></li><li>事件监听<ul><li>None<ul><li>客户端和服务器连接状态发生变化，没有触发事件</li></ul></li><li>NodeCreated<ul><li>节点被创建</li></ul></li><li>NodeDeleted<ul><li>节点被删除</li></ul></li><li>NodeDataChanged<ul><li>节点数据发生变化</li></ul></li><li>NodeChildrenChanged<ul><li>子节点被创建、删除或子节点数据发生变化</li><li>只有一级子节点会触发</li></ul></li></ul></li></ul></li></ul><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p><a href="http://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html#sc_ZooKeeperAccessControl" target="_blank" rel="external">官方介绍文档</a></p><ul><li>Zookeeper提供控制节点访问权限的功能，用于有效的保证Zookeeper中数据的安全性。避免误操作而导致系统出现重大事故</li><li>权限角色<ul><li>CREATE</li><li>READ</li><li>WRITE</li><li>DELETE</li><li>ADMIN</li></ul></li><li>Builtin ACL Schemes<ul><li>ip<ul><li>指定ip授权</li></ul></li><li>digest(常用)<ul><li>username:password组成字符串，通过API转换为加密内容设置到权限内</li></ul></li><li>world<ul><li>开放式的权限控制模式。所有人。</li></ul></li><li>auth(super)<ul><li>超级用户，可以对zookeeper上的数据节点进行操作。</li></ul></li><li>x509<ul><li>将客户端X500 Principal作为ACL ID身份。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zoo.cfg配置文件分析</title>
      <link href="/zk/config.html"/>
      <url>/zk/config.html</url>
      
        <content type="html"><![CDATA[<h3 id="zoo-cfg配置文件分析"><a href="#zoo-cfg配置文件分析" class="headerlink" title="zoo.cfg配置文件分析"></a>zoo.cfg配置文件分析</h3><a id="more"></a><p><strong>tickTime=2000</strong></p><p>zookeeper中最小的时间单位长度(ms)</p><p><strong>initLimit=10</strong></p><p>follower节点启动后与leader节点完成数据同步的时间</p><p><strong>syncLimit=5</strong></p><p>leader节点与folloew节点进行心跳检测的最大延迟时间</p><p><strong>dataDir=/tmp/zookeeper</strong></p><p>表示zookeeper服务器存储快照文件的目录。</p><p>快照：存储某以时刻全量的内存数据内容。</p><p>Zookeeper会定时把内存数据存储在磁盘上。</p><p>第一条写入事务的<code>zxid</code>结尾。    </p><p>查看日志命令：<code>java -cp :/dir/zookeeper-3.4.9/lib/slf4j-api-1.6.1.jar:/dir/zookeeper-3.4.9/zookeeper-3.4.9.jar org.apache.zookeeper.server.LogFormatter log.zxid</code></p><p><strong>dataLogDir=/tmp/zookeeper</strong></p><p>表示zookeeper事务日志的存储路径，默认指定在dataDir目录下</p><p><strong>clientPort=2181</strong></p><p>表示客户端与服务器建立连接的端口号</p>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建Zookeeper集群</title>
      <link href="/zk/zoos.html"/>
      <url>/zk/zoos.html</url>
      
        <content type="html"><![CDATA[<h3 id="集群的角色"><a href="#集群的角色" class="headerlink" title="集群的角色"></a>集群的角色</h3><a id="more"></a><ul><li>leader</li><li>follower</li><li>observer</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="external">Apache ZooKeeper™ Releases</a></p><h3 id="修改zoo-cfg"><a href="#修改zoo-cfg" class="headerlink" title="修改zoo.cfg"></a>修改zoo.cfg</h3><p><strong>添加集群服务器列表</strong></p><p><code>server.id=ip:changeInfoPort:leaderElectionPort</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#第一台服务器</div><div class="line">server.1=192.168.11.129:2888:3181   </div><div class="line">#第二台服务器</div><div class="line">server.2=192.168.11.135:2888:3181   </div><div class="line">#第三台服务器</div><div class="line">server.3=192.168.111.136:2888:3181</div></pre></td></tr></table></figure><p>2888表示follower节点与leader节点交换信息的端口号</p><p> 3181  如果leader节点挂掉了, 需要一个端口来重新选举。</p><p><strong>添加并配置文件夹</strong></p><ul><li>zoo.cfg中配置</li></ul><p><code>dataDir = /opt/zookeeper/data</code></p><ul><li>创建文件夹</li></ul><p><code>mkdir /opt/zookeeper/data</code></p><h3 id="创建myid文件"><a href="#创建myid文件" class="headerlink" title="创建myid文件"></a>创建myid文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /opt/zookeeper/data</div><div class="line">vi myid</div></pre></td></tr></table></figure><p>文件中的内容为<code>zoo.cfg</code>中对应<code>ip</code>前的<code>server.id</code>中的<code>id</code>号，例如：1`</p><p>每台服务器都需要如上配置，区别在于myid中的内容。</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>./zkServer.sh start</code></p><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>添加observer节点</strong></p><p><code>zoo.cfg</code>中 增加 ：<code>peerType=observer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.1=192.168.11.129:2888:3181  </div><div class="line"></div><div class="line">server.2=192.168.11.135:2888:3181   </div><div class="line"></div><div class="line">server.3=192.168.111.136:2888:3181:observer</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步认识zookeeper</title>
      <link href="/zk/start.html"/>
      <url>/zk/start.html</url>
      
        <content type="html"><![CDATA[<p><strong>初步认识zookeeper</strong></p><a id="more"></a><blockquote><p>zookeeper是一个开源的分布式协调服务，是由雅虎创建的，基于google chubby。</p></blockquote><p><strong>zookeeper是什么</strong></p><blockquote><p>分布式数据一致性的解决方案</p></blockquote><p><strong>zookeeper能做什么</strong></p><ul><li>数据的发布/订阅<ul><li>配置中心：disconf</li></ul></li><li>负载均衡<ul><li>dubbo利用zookeeper机制实现负载均衡</li></ul></li><li>命名服务</li><li>master选举<ul><li>kafka</li><li>Hadoop</li><li>hbase</li></ul></li><li>分布式队列</li><li>分布式锁</li></ul><p><strong>zookeeper特性</strong></p><ul><li>顺序一致性<ul><li>从同一个客户端发起的事务请求，最终都会严格按照顺序被应用到zookeeper中</li></ul></li><li>原子性<ul><li>所有的事务请求的处理结果在整个集群中的所有机器上的应用情况是一致的，也就是说，要么整个集群中的所有机器都成功应用了某以事务、要么全都不应用</li></ul></li><li>实时性<ul><li>一旦一个事务被成功应用，客户端就能够立即从服务端读取到事务变更后的最新数据状态<ul><li>zookeeper仅仅保证在一定时间内，近实时</li></ul></li></ul></li><li>单一视图<ul><li>无论客户端连接到哪个服务器，所看到的模型都是一样</li></ul></li><li>可靠性<ul><li>一旦服务器端提交了一个事务并且获得了服务器端返回成功的标识，那么这个事务所引起的服务器端的变更会一直保留</li></ul></li></ul><blockquote><p>Zookeeper并不是用来存储数据的，而是通过监控数据状态的变化，达到基于数据的集群管理</p></blockquote><p><strong>zookeeper安装</strong></p><ul><li>单机环境<ul><li><a href="https://zookeeper.apache.org/releases.html#download" target="_blank" rel="external">下载zookeeper的安装包</a></li><li>解压<ul><li><code>tar -zxvf zookeeper-xx.tar.gz</code></li></ul></li><li>生成zoo.cfg<ul><li><code>cd ZK_HOME/conf</code></li><li><code>cp zoo_sample.cfg zoo.cfg</code></li></ul></li><li>运行<ul><li><code>sh zkServer.sh start-foreground</code><ul><li>start</li><li>start-foreground</li><li>stop</li><li>restart</li><li>status</li><li>upgrade</li><li>print-cmd</li></ul></li></ul></li><li>客户端连接<ul><li><code>sh zkCli.sh -server ip:port</code></li></ul></li></ul></li><li>集群环境<ul><li>集群角色<ul><li>leader</li><li>follower</li><li>observer<ul><li><code>server.id=ip:zkPort:leaderElectionPort:observer</code></li><li>不参数投票，只接收投票结果</li><li>不属于zookeeper的关键部位</li><li>特殊的zookeeper节点</li><li>帮助解决zookeeper的扩展性<ul><li>如果大量客户端访问zookeeper集群，需要增加zookeeper集群机器数量。从而增加zookeeper集群性能。导致zookeeper集群写性能下降，zookeeper的数据变更需要半数以上服务器投票通过，造成网络小号增加投票成本</li></ul></li></ul></li></ul></li><li>修改配置文件<ul><li><code>server.id=ip:zkPort:leaderElectionPort</code><ul><li><code>id</code>：1~255，标识该机器在集群中的机器序号</li><li>有几台机器就写几行</li></ul></li></ul></li><li>创建 <code>myid</code>文件<ul><li>在每一台服务器的dataDir目录下创建</li><li>数据内容是没太机器对应的serverId的数字</li></ul></li><li>启动zookeeper</li></ul></li></ul><blockquote><ul><li>客户端的写请求一定会发送到leader节点上</li><li>客户端的读请求，会根据算法分配到不同节点</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> zk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式基础知识</title>
      <link href="/distributed/basic.html"/>
      <url>/distributed/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="分布式环境的特点"><a href="#分布式环境的特点" class="headerlink" title="分布式环境的特点"></a>分布式环境的特点</h3><a id="more"></a><p><strong>分布性</strong></p><p><strong>并发性</strong></p><p>程序运行过程中，并发性操作是很常见的。比如同一个分布式系统中的多个节点，同时访问一个共享资源。数据库、分布式存储</p><p><strong>无序性</strong></p><p>进程之间的消息通信，会出现顺序不一致问题</p><h3 id="分布式环境下面临的问题"><a href="#分布式环境下面临的问题" class="headerlink" title="分布式环境下面临的问题"></a>分布式环境下面临的问题</h3><p><strong>网络通信</strong></p><p>网络本身的不可靠性，因此会设计到一些网络通信问题</p><p><strong>网络分区(脑裂)</strong></p><blockquote><p>当网络发生异常导致分布式系统中部分节点之间的网络延时不断增加，最终导致组成分布式架构的所有节点中是有部分节点能够正常通信。</p></blockquote><p>一个master，多个slave组成的正常集群，假设其中两台服务器网络通信不正常，可能会重新选举出一个master，导致两个独立的集群，这两个集群本身是完整的。会产生数据重复等问题。</p><p>###分布式三态</p><ul><li>成功</li><li>失败</li><li>超时<ul><li>出现网络问题，消息没有发送到客户端，或客户端没有收到</li></ul></li></ul><p>单机环境</p><ul><li>成功</li><li>失败</li></ul><p>###分布式事务</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><p>###中心化和去中心化</p><ul><li><p>中心化    </p><ul><li>角色<ul><li>领导</li><li>下属</li></ul></li></ul></li></ul><ul><li>解决<ul><li>热备<ul><li>人才储备，领导不行了，直接激活人才</li></ul></li><li>冷备<ul><li>两个领导都存活，一个干活，一个就绪</li></ul></li></ul></li></ul><ul><li>去中心化<ul><li>所有人都是水平的，没有谁领导谁</li><li>全国网络节点</li><li>解决脑裂问题</li></ul></li></ul><blockquote><p>分布式架构里面，很多的架构思想采用的是：当集群发生故障的时候，集群中的人群会自动选举出一个新的领导。最典型的是：zookeeper/etcd</p></blockquote><p>###经典的CAP/BASE理论</p><ul><li>CAP<ul><li>C<ul><li>Consistency一致性</li><li>所有节点上的数据，时刻保持一致</li><li>同步会有延迟(网络)</li></ul></li><li>A<ul><li>Availability可用性</li><li>每个请求都能收到一个响应，无论响应成功或者失败</li></ul></li><li>P<ul><li>Partition-tolerance分区容错</li><li>表示系统出现脑裂以后，可能导致某些server与集群中的其它机器失去联系</li></ul></li></ul></li></ul><blockquote><p>一般只能满足两个条件，常见是：CP/AP。</p><p>CAP理论仅适用于原子读写的NoSQL场景，不适用于数据库系统。因为数据出现问题是没办法恢复的，更新一些错误的数据而导致数据出现紊乱，无论什么样的数据库高可用方案都是徒劳。虽然XA事务(分布式事务解决方案)可以保证数据库在分布式系统下的ACID特性，但是会带来性能方面的影响。</p></blockquote><ul><li>BASE<ul><li>Basically Available<ul><li>数据库采用分片模式，把100W的用户数据分布在5个实例。如果破坏了其中一个实例，仍然可以保证80%的用户可用</li></ul></li><li>soft-state<ul><li>在基于client-server模式的系统中，serveer端是否有状态，决定了系统是否具备良好的水平扩展、负载均衡、故障恢复等特性</li><li>server端承诺会维护client端状态数据，这个状态仅仅维持一小段时间，这段时间以后，server端就会丢弃这个状态，恢复正常</li></ul></li><li>Eventually Consistent<ul><li>数据的最终一致性</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> distributed </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-framework</title>
      <link href="/Spring/framework.html"/>
      <url>/Spring/framework.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、什么是IOC-DI"><a href="#一、什么是IOC-DI" class="headerlink" title="一、什么是IOC/DI"></a>一、什么是IOC/DI</h3><a id="more"></a><p><strong>IOC Inversion of Control  控制反转</strong><br>就是把代码里面需要实现的对象创建、依赖的代码，反转给容器来实现<br>那么必然需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系<br>这个描述最具体表现就是可配置的文件</p><p><strong>DI Dependency Injection  依赖注入</strong><br>就是指对象是被动接收依赖类而不是自己主动去找<br>换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化的时候主动将它依赖的类注入给它</p><p><strong>对象和对象关系怎么表示:</strong></p><ul><li>XML</li><li>properties文件</li><li>等语义化配置文件表示</li></ul><p><strong>描述对象关系的文件存放在:</strong></p><ul><li>classpath</li><li>filesystem</li><li>URL网络资源</li><li>servletContext等</li></ul><h3 id="二、Spring-IOC体系结构"><a href="#二、Spring-IOC体系结构" class="headerlink" title="二、Spring IOC体系结构"></a>二、Spring IOC体系结构</h3><p><strong>BeanFactory</strong></p><ul><li>只对IOC容器的基本行为作了定义，不关心如何加载</li><li>Spring Bean的创建是典型的工厂模式，这一些列的Bean工厂</li><li>也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务</li><li>BeanFactory作为最顶层的一个接口类,它定义了IOC容器的基本功能规范，子类有：<ul><li>ListableBeanFactory(可列表)</li><li>HierarchicalBeanFactory(有继承关系)</li><li>AutowaireCapableBeanFactory(定义Bean的自动装配规则)</li><li>最终实现是DefaultListableBeanFactory</li></ul></li><li>这四个接口共同定义了Bean的集合、之间的关系和行为</li><li>如何生产对象，要看IOC容器的实现<ul><li>XmlBeanFactory<ul><li>最基本的IOC容器的实现</li><li>读取XML文件定义的BeanDefinition</li></ul></li><li>ClasspathXmlApplicationContext<ul><li>高级的IOC容器</li><li>提供IOC容器的基本功能</li><li>附加服务<ul><li>支持信息源，可以实现国际化</li><li>访问资源</li><li>支持应用事件</li></ul></li></ul></li></ul></li></ul><p><strong>BeanDefinition</strong></p><ul><li>Bean对象在Spring实现中是以BeanDefinition来描述的</li><li><p>Bean的解析主要就是对Spring配置见的解析</p><p>  ​</p><h3 id="三、IoC容器的初始化"><a href="#三、IoC容器的初始化" class="headerlink" title="三、IoC容器的初始化"></a>三、IoC容器的初始化</h3><p><strong>IOC容器的初始化</strong></p></li><li>BeanDefinition的Resource<ul><li>定位</li><li>载入</li><li>注册<blockquote><p>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。</p></blockquote></li></ul></li></ul><p><strong>IOC容器的创建过程</strong></p><ul><li>XmlBeanFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息</span></div><div class="line">ClassPathResource resource =<span class="keyword">new</span> ClassPathResource(<span class="string">"application-context.xml"</span>);</div><div class="line"></div><div class="line"><span class="comment">//创建DefaultListableBeanFactory</span></div><div class="line">DefaultListableBeanFactory factory =<span class="keyword">new</span> DefaultListableBeanFactory();</div><div class="line"></div><div class="line"><span class="comment">//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。</span></div><div class="line"><span class="comment">//之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory</span></div><div class="line"></div><div class="line">XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</div><div class="line"></div><div class="line"><span class="comment">//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。</span></div><div class="line"><span class="comment">//完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得 Bean来使用</span></div><div class="line">reader.loadBeanDefinitions(resource);</div></pre></td></tr></table></figure><ul><li>FileSystemXmlApplicationContext    <ul><li>通过调用父类AbstractApplicationContext的refresh()启动整个IoC容器对Bean定义的载入过程</li><li>AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions()</li><li>AbstractBeanDefinitionReader读取Bean定义资源 loadBeanDefinitions()<ul><li>调用资源加载器的获取资源方法resourceLoader.getResource(location),获取到要加载的资源</li><li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinition()</li></ul></li><li>资源加载器获取要读取的资源<ul><li>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源    </li><li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions()</li></ul></li><li>XmlBeanDefinitionReader加载bean资源<ul><li>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现</li></ul></li><li>DocumentLoader将Bean定义资源转换成Document对象<ul><li>DefaultDocumentLoader的loadDocument方法</li><li>该解析过程调用JavaEE标准的JAXP标准进行处理</li></ul></li></ul></li></ul><blockquote><p>至此，Sping IOC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。<br>接下来要继续分析Spring IOC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IOC管理的Bean对象并将其注册到容器中的</p></blockquote><p><strong>XmlBeanDefinitionReader解析载入Bean定义资源文件</strong></p><ul><li>doLoadBeanDefinitions</li><li>Bean定义资源的载入解析<ul><li>通过调用XML解析器将Bean定义资源文件转换得到Document对象，这一步是载入<ul><li>这些Document对象并没有按照Spring的Bean规则进行解析</li></ul></li><li>在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析<ul><li>接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader实现的</li></ul></li></ul></li></ul><p><strong>DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析</strong></p><ul><li>BeanDefinitionDocumentReader 接口通过 registerBeanDefinitions 方法调用其实现类 DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析<ul><li><import>—DefaultBeanDefinitionDocumentReader</import></li><li><alias>—DefaultBeanDefinitionDocumentReader</alias></li><li><bean>—BeanDefinitionParserDelegate—parseBeanDefinitionElement</bean></li></ul></li></ul><p><strong>BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的<bean>元素</bean></strong></p><ul><li>BeanDefinitionParserDelegate<ul><li>配置文件中<bean>元素中配置的属性就是通过该方法解析和设置到bean中的</bean></li><li>解析<bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition<ul><li>将<bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象</bean></li></ul></bean></li></ul></li></ul><p><strong>BeanDefinitionParserDelegate 解析<property>元素</property></strong></p><ul><li>BeanDefinitionParserDelegate—parsePropertyElements<ul><li>ref被封装为指向依赖对象的一个引用</li><li>value配置都会封装为一个字符串类型的对象</li><li>ref和value都通过”解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来</li><li>该方法的最后对于<property>元素的子元素通过parsePropertySubElement方法解析</property></li></ul></li></ul><p><strong>解析property元素的子元素</strong></p><ul><li>BeanDefinitionParserDelegate—BeanDefinitionParserDelegate<ul><li>Spring配置文件中，对<property>元素中配置的Array、List、Set、Map、Prop等各种集合子元素都通过上述方法解析，生成对应的数据对象<ul><li>如果ManagedList、ManagedSet等，这些Managed类是Spring对象BeanDefinition的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范。</li></ul></property></li></ul></li></ul><p><strong>解析list元素的子元素</strong></p><ul><li>BeanDefinitionParserDelegate—parseListElement</li></ul><blockquote><p>经过对Spring Bean定义资源文件转换的Document对象中的元素层层解析，Spring IoC现在已经将XML性质定义的Bean定义资源文件转换为Spring IoC所识别的数据结构—BeanDefinition，它是Bean定义资源文件中配置POJO对象在Spring IoC容器中的映射，可以通过AbstractBeanDefinition为入口，看到了IoC容器进行索引、查询和操作.</p><p>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向同期注册Bean定义信息才能全部完成IoC容器的初始化过程。</p><p>继续跟踪程序的执行顺序，接下来会到分析DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的流程中，在其parseDefaultElement方法中完成对Document对象的解析后得到BeanDefinition的BeanDefinitionHolder对象，然后在processBeanDefinition方法里调用BeanDefinitionReaderUtils的registerBeanDefinition向IoC容器注册解析的Bean。</p></blockquote><p><strong>解析过后的BeanDefinition在IoC容器中的注册</strong></p><ul><li>BeanDefinitionReaderUtils—registerBeanDefinition<ul><li>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory</li></ul></li></ul><p><strong>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition</strong></p><ul><li>使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinitio，向容器注册的主要源码</li><li>registerBeanDefinition方法向IoC容器注册</li></ul><blockquote><p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p></blockquote><hr><p><strong>总结</strong></p><p><strong>IoC容器初始化</strong></p><ul><li>初始化的入口在容器实现中的refresh()调用完成</li><li><p>对bean定义载入IoC容器使用的方法是loadBeanDefinition</p><blockquote><p>其中大致过程如下：通过ResourceLoader来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了ResourceLoader的实现，可以从类路径、文件系统、URL等方式来定位资源位置。如果是XmlBeanFactory作为IoC容器，那么需要为它指定bean定义的资源，也就是说bean定义文件时通过抽象成Resource来被IoC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册，往往使用的是XmlBeanDefinitionReader来解析bean的xml定义文件，实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，这些信息在Spring中使用BeanDefinition对象来表示，这个名字可以联想到loadBeanDefinition，RegisterBeanDefinition这些相关方法。都是为处理BeanDefinition服务的，容器解析得到BeanDefinition IoC以后，需要把它在IoC容器中注册，这由IoC实现BeanDefinitionRegistry接口来实现。注册过程就是在IoC容器内部维护一个HashMap来保存得到BeanDefinnition的过程。这个HashMap是IoC容器持有bean信息的场所，以后对bean的操作都是围绕这个HashMap来实现的</p></blockquote></li><li><p>然后就可以通过BeanFactory和ApplicationContext来享受Spring IoC的服务了。在使用IoC容器的时候，除了少量的粘合代码，绝大多数以正确IoC风格标写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring本身提供了对声明式载入web应用程序用法的应用程序上下文，并将其存储在ServletContext中的框架实现。</p></li></ul><p><strong>在使用SpringIoC容器的时候还需要区别两个概念</strong></p><ul><li>BeanFactory<ul><li>IoC容器的编程抽象<ul><li>比如ApplicationContext、XmlBeanFactory等，这些都是容器的具体表现，需要使用什么的容器由用户决定，但Spring提供了丰富的选择。</li></ul></li></ul></li><li>FactoryBean<ul><li>只是一个可以在IoC容器中被管理的一个bean，是对各种处理裹层和资源使用的抽象，而不返回FactoryBean本身，可以把它堪称是一个抽象工厂，对它的调用返回的是工厂生产的产品，当使用容器中的FactoryBean的时候，该容器不会返回FactoryBean本身，而是返回其生成的对象。Spring包括了大部分的通用资源和服务访问抽象的FactoryBean的实现（下方列出），这些都可以看成是具体的工厂，堪称是Spring建立好的工厂。也就是说Spring通过使用抽象工厂模式准备了一系列工厂来生产一些特定的对象，免除手工重复的工作，要使用时只需要在IoC容器里配置好就能很方便的使用了<ul><li>对JNDI查询的处理</li><li>对代理对象的处理</li><li>对事务性代理的处理</li><li>对RMI代理的处理</li><li>…</li></ul></li></ul></li></ul><h3 id="四、IoC容器的依赖注入"><a href="#四、IoC容器的依赖注入" class="headerlink" title="四、IoC容器的依赖注入"></a>四、IoC容器的依赖注入</h3><p><strong>依赖注入发生的时间</strong><br>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况发生：</p><ul><li>用户第一次通过getBean方法向IoC容器获取Bean时，IoC容器触发依赖注入</li><li>当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Beean定义时进行预实例化，触发依赖注入。<blockquote><p>BeanFactory接口定义了Spring IoC容器的基本功能规范。BeanFactory接口定义了几个getBean方法，就是用户向IoC容器索取管理的Bean的方法。具体实现在AbstractBeanFactory中。</p></blockquote></bean></li></ul><p><strong>AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean</strong></p><ul><li>AbstractBeanFactory—doGetBean</li></ul><p>根据Bean定义方式不同，采取不同的创建Bean实例对象的策略</p><ul><li>单例(Singleton)<ul><li>则容器在创建之前先从缓存中查找<ul><li>确保整个容器中只存在一个实例对象</li></ul></li></ul></li><li>原型(Prototype)<ul><li>则容器每次都会创建一个新的实例对象</li></ul></li><li>其他<ul><li>扩展为指定其生命周期范围</li></ul></li></ul><blockquote><p>具体的Bean实例对象的创建过程由实现了ObjectFactory接口的匿名内部类的createBean方法完成。ObjectFactory使用了委派模式，具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成。</p></blockquote><p><strong>AbstractAutowireCapableBeanFactory创建Bean实例对象</strong></p><p>AbstractAutowireCapableBeanFactory类实现了ObjectFactoryj接口，创建容器指定的的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理。</p><ul><li>AbstractAutowireCapableBeanFactory—createBean<br>具体的依赖注入实现在：</li><li>.createBeanInstance<ul><li>生成Bean所包含的java实例对象</li></ul></li><li>.populateBean<ul><li>对Bean属性的依赖注入进行管理</li></ul></li></ul><p><strong>createBeanInstance方法创建Bean的java实例对象</strong></p><p>容器初始化生成Bean所包含的Java实例对象</p><ul><li>AbstractAutowireCapableBeanFactory—createBeanInstance</li><li>对使用工厂方法和自动装配特性的Bean的实例化比较清除，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK的反射机制或者CGLIB)来进行初始化了，在方法getInstantiationStrategy().instantiate中就具体实现类使用初始策略实例化对象。</li></ul><p><strong>SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象</strong></p><p>容器初始化生成Bean所包含的Java实例对象</p><ul><li>SimpleInstantiationStrategy—instantiate</li><li>Bean的方法是否被覆盖<ul><li>被覆盖<ul><li>使用JDK的反射机制进行实例化</li></ul></li><li>无<ul><li>CGLIB进行实例化</li></ul></li></ul></li><li>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB.</li></ul><p><strong>populateBean方法对Bean属性的依赖注入</strong></p><p>生成对象后，Spring IoC容器是如何将Bean的属性依赖关系注入Bean实例对象中并设置好。</p><ul><li>AbstractAutowireCapableBeanFactory—populateBean</li><li>AbstractAutowireCapableBeanFactory—applyPropertyValues</li><li>对属性的注入过程分以下两种情况<ul><li>属性值不需要类型转换时，不需要解析属性值，直接准备进行依赖注入</li><li>属性值需要进行类型转换时，如对其他对象的引用等<ul><li>首先需要解析属性值</li><li>然后对解析后的属性值进行依赖注入<br>对属性值的解析是在BeanDefinitionValueResolver类的resolveValueIfNecessary方法中进行的，对属性值的依赖注入是通过bw.setPropertyValues方法实现的，在分析属性值的依赖注入之前，分析以下对属性值的解析过程。</li></ul></li></ul></li></ul><p><strong>BeanDefinitionValueResolver解析属性值</strong></p><blockquote><p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所医用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现</p></blockquote><ul><li>BeanDefinitionValueResolver—resolveValueIfNecessary</li><li>BeanDefinitionValueResolver—resolveReference</li><li>BeanDefinitionValueResolver—resolveManagedArray</li><li>BeanDefinitionValueResolver—resolveManagedList</li><li>BeanDefinitionValueResolver—resolveManagedSet</li><li>BeanDefinitionValueResolver—resolveManagedMap<blockquote><p>通过上面的代码分析，明白了Spring是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是Bean对象实例设置到它所依赖的Bean对象舒心上去，依赖注入是通过bw.setPropertyValues方法实现的，该方法也使用了委托模式，在BeanWrapper接口中至少定义了方法声明，依赖注入的具体实现交由其实现类BeanWrapperImpl来完成。</p></blockquote></li></ul><p><strong>BeanWrapperImpl对Bean属性的依赖注入</strong></p><p>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去。</p><ul><li>AbstractNestablePropertyAccessor—setPropertyValue</li><li>Spring IoC容器是如何将属性的值注入到Bean实例对象中<ul><li>集合类型的属性<ul><li>将其属性值解析为目标类型的集合后直接赋值给属性</li></ul></li><li>非集合类型的属性<ul><li>大量使用了JDk的反射和内省机制，通过属性的getter方法获取指定属性注入以前的值</li><li>调用属性的setter方法为属性设置注入后的值</li></ul></li></ul></li></ul><p>至此Spring IoC容器对Bean定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在使用的时候自动创建，并且注入好相关的依赖，这就是Spring核心功能的控制反转和依赖注入的相关功能</p><h3 id="五、IoC容器的高级特性"><a href="#五、IoC容器的高级特性" class="headerlink" title="五、IoC容器的高级特性"></a>五、IoC容器的高级特性</h3><p><strong>介绍</strong></p><p>之前介绍了Spring Ioc容器对Bean资源的定位，读取和解析过程，同时也清楚了当用户通过getBean方向向IoC容器获取被管理的Bean时，IoC容器对Bean进行的初始化和依赖注入的过程，这些是Spring IoC容器的基本功能特性。</p><p>Spring IoC还有一些高级特性，如使用lazy-init属性对Bean预初始化、FactoryBean产生或者修饰Bean对象的生成、IoC容器初始化Bean过程中使用BeanPostProcessor后置处理器对Bean生命周期事件管理和IoC容器的autowiring自动装配功能等。</p><p><strong>Spring IoC容器的lazy-init属性实现预实例化</strong></p><blockquote><p>通过前面对IoC容器的实现和工作原理分析，知道了IoC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取Bean时，通过getBean方法的调用完成。当Bean定义资源的 Bean元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候已经完成。这样，当应用程序第一次向容器索取被管理的Bean时，就不用再初始化和对Bean进行依赖注入了，直接从容器中获取已经完成依赖注入的现成的Bean，可以提高应用第一次向容器获取Bean的性能。</p><ul><li>refresh<ul><li>AbstractApplicationContext—refresh()</li><li>先从IoC容器的初始化过程开始，通过之前的分析，知道IoC容器读入已经定位的Bean定义资源是从refresh方法开始的。</li></ul></li><li>finishBeanFactoryInitialization处理预实例化Bean<ul><li>AbstractApplicationContext—finishBeanFactoryInitialization</li></ul></li><li>DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化<ul><li>DefaultListableBeanFactory—preInstantiateSingletons</li><li>如果设置了lazy-init属性，则容器在完成Bean定义的注册之后，会通过getBean方法，触发对指定Bean的初始化和依赖注入过程，这样当应用第一次向容器索取所需的Bean时，ring 起不再需要对Bean进行初始化和依赖注入，直接从已经完成实例化和依赖注入的Bean中取一个现成的Bean，这样就提高了第一次获取Bean的性能。</li></ul></li></ul></blockquote><p><strong>FactoryBean的实现</strong></p><ul><li>背景知识<ul><li>BeanFactory<ul><li>Bean工厂，是一个工厂</li><li>Spring IoC容器的最顶层接口</li><li>管理Bean<ul><li>实例化、定位、配置应用程序中的对象及建立这些对象见的依赖</li></ul></li></ul></li><li>FactoryBean<ul><li>工厂Bean，是一个Bean</li><li>产生其他Bean实例</li><li>通常情况下，这种bean没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他bean实例</li><li>通常情况下，bean无需自己实现工厂模式，Spring容器担任工厂角色</li><li>少数情况下，容器中的bean本身就是工厂，其作用是产生其他bean实例<br>当用户使用容器本身时，可以使用转义字符“&amp;”来得到Factory本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身。<br>如果myJndiObject是一个FactoryBean，使用&amp;myJndiObject得到的是myJndiObject对象，而不是myJndiObject产生出来的对象。 </li></ul></li></ul></li><li>FactoryBean</li><li>AbstractBeanFactory—doGetBean<ul><li>调用FactoryBean            </li><li>AbstractBeanFactory—getObjectForBeanInstance<ul><li>Dereference（解引用）</li><li>在C/C++中应用比较多的术语，”*”是解引用符号，而”&amp;”是引用符号</li><li>解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址</li></ul></li></ul></li><li>AbstractBeanFactory生产Bean实例对象<ul><li>FactoryBeanRegistrySupport—getObjectFromFactoryBean</li><li>FactoryBeanRegistrySupport—doGetObjectFromFactoryBean<br>   BeanFactory接口调用其实现类的getObject方法来实现创建Bean实例对象的功能    </li></ul></li><li>工厂Bean的实现类getObject方法创建Bean实例对象<ul><li>FactoryBean的实现类非常多<ul><li>Proxy</li><li>RMI</li><li>JNDI</li><li>ServletContextFactoryBean</li><li>…</li></ul></li><li>FactoryBean接口为Spring容器提供了一个很好的封装机制，具体的getObject有不同的实现类根据不同的实现政策来具体技工，分析一个最简单的AnnotationTestBeanFactory<ul><li>AnnotationTestBeanFactory</li><li>其他的Proxy、RMI、JNDI等等，都是根据相应的策略提供getObject的实现</li></ul></li></ul></li></ul><p><strong>BeanPostProcessor后置处理器的实现</strong></p><blockquote><p>BeanPostProcessor后置处理器是Spring IoC容器经常使用到的一个特性，这个Bean后置处理器是一个监听器，可以监听容器触发的Bean生命周期事件。后置处理器向容器注册以后，容器中管理的Bean就具备了接收IoC容器事件回调的能力。</p><p>BeanPostProcessor的使用非常简单，只需要提供一个实现接口BeanPostProcessor的实现类，然后在Bean的配置文件中设置即可。</p></blockquote><ul><li>BeanPostProcessor<ul><li>这两个回调的入口都是和容器管理的Bean的生命周期事件紧密相关，可以为用户提供在Spring IoC容器初始化Bean过程中自定义的处理操作</li></ul></li><li>AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器<ul><li>AbstractAutowireCapableBeanFactory—doCreateBean<ul><li>BeanPostProcessor后置处理器的调用发生在Spring IoC容器完成对Bean实例对象的创建和属性的依赖注入完成之后，当应用程序第一次调用getBean方法（lazy-init预实例化除外）向Spring IoC容器索取指定Bean时触发Spring IoC容器创建Bean实例对象并进行依赖注入的过程，其中真正实现创建Bean对象并进行依赖注入的方法是AbstractAutowireCapableBeanFactory类的doCreateBean</li></ul></li></ul></li><li>AbstractAutowireCapableBeanFactory—initializeBean<ul><li>为容器产生的Bean实例对象添加BeanPostProcessor后置处理器的入口</li><li>AbstractAutowireCapableBeanFactory—applyBeanPostProcessorsAfterInitialization<ul><li>BeanPostProcessor是一个接口，其初始化前的操作方法和初始化后的操作放啊均委托其实现子类来实现<ul><li>AOP面向切面编程的注册通知适配器</li><li>Bean对象的数据校验</li><li>Bean继承属性/方法的合并</li></ul></li></ul></li></ul></li><li>AdvisorAdapterRegistrationManager <ul><li>其他的BeanPostProcessor接口实现类也类似，都是对Bean对象使用到的一些特性进行处理，或者向IoC容器中注册，为创建的Bean实例对象做一些自定义的功能增加，这些操作是容器初始化Bean时自动触发的，不需要人为的干预</li></ul></li></ul><p><strong>Spring IoC容器autowiring实现原理</strong></p><ul><li>Spring IoC容器提供了两种管理Bean依赖关系的方式<ul><li>显式管理<ul><li>通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理</li></ul></li><li>autowiring<ul><li>Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动装配容器中管理的Bean，从而自动的完成依赖注入</li></ul></li></ul></li><li>AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入<ul><li>AbstractAutoWireCapableBeanFactory—populateBean</li></ul></li><li>Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入<ul><li>AbstractAutoWireCapableBeanFactory—autowireByName</li><li>AbstractAutoWireCapableBeanFactory—autowireByType</li><li>可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是DefaultSingletonBeanRegistry类的registerDependentBean</li></ul></li><li>DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入<ul><li>DefaultSingletonBeanRegistry—registerDependentBean</li></ul></li></ul><p>通过对autowire的源码分析，可以看出，autowire的实现过程：</p><ul><li>对Bean的属性调用getBean方法，完成依赖Bean的初始化和依赖注入</li><li>将依赖Bean的属性引用设置到被依赖的Bean上</li><li>将依赖Bean的名称和被依赖Bean的名称存储在IoC容器的集合中</li></ul><p>Spring IoC容器的autowire属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但也存在不足：</p><ul><li>Bean的依赖关系在配置文件中无法很清楚的看出来，对于维护造成一定困难</li><li><p>由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑</p><p>  ​    </p></li></ul><h3 id="六、Spring-AOP设计原理及具体实践"><a href="#六、Spring-AOP设计原理及具体实践" class="headerlink" title="六、Spring AOP设计原理及具体实践"></a>六、Spring AOP设计原理及具体实践</h3><p><strong>SpringAOP应用示例</strong></p><ul><li><p>AOP(Aspect Oriented Programming)面向切面编程</p><ul><li>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术</li><li>AOP设计模式追求的是调用者和被调用者之间的解耦</li></ul></li><li><p>相关概念</p><ul><li>Aspect切面<ul><li>官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”</li><li>“切面“在ApplicationContext中<aop:aspect>来配置</aop:aspect></li></ul></li><li>Joinpoint连接点<ul><li>程序执行过程中的某一行为<ul><li>某个方法的调用</li><li>某个方法抛出异常等行为</li></ul></li></ul></li><li>Advice通知<ul><li>“切面”对于某个“连接点”所产生的动作</li><li>一个“切面”可以包含多个“Advice”</li></ul></li><li>Pointcut切入点<ul><li>匹配连接点的断言</li><li>在AOP中通知和一个切入点表达式关联</li><li>切面中的所有通知所关注的连接点，都由切入点表达式来决定</li></ul></li><li>Target Object目标对象<ul><li>被一个或多个切面所通知的对象</li><li>在实际运行时，Spring AOP采用代理实现，实际AOP操作的是TargetObject的代理对象</li></ul></li><li>AOP Proxy AOP代理<ul><li>在Spring AOP中由两种代理方式<ul><li>JDK动态代理</li><li>CGLIB代理</li></ul></li><li>默认情况下，TargetObject实现了接口时，则采用JDK动态代理，反之，采用CGLIB代理</li><li>强制使用CGLIB大力需要将<aop:config>的proxy-target-class属性设置为true</aop:config></li></ul></li></ul></li><li><p>Advice通知 类型</p><ul><li>Before advice 前置通知<ul><li>在某连接点JointPoint之前执行的通知，但这个通知不能阻止连接点前的执行</li><li>ApplicationContext中在<aop:aspect>里面使用<aop:before></aop:before></aop:aspect></li></ul></li><li>After advice 后置通知<ul><li>在某连接点退出的时候执行的通知(不论是正常返回还是异常退出)</li><li>ApplicationContext中在<aop:aspect>里面使用<aop:after></aop:after></aop:aspect></li></ul></li><li>After return advice 返回后通知<ul><li>在某连接点正常完成后执行的通知，不包括抛出异常的情况</li><li>ApplicationContext中在<aop:aspect>里面使用<after-returning></after-returning></aop:aspect></li></ul></li><li>Around advice环绕通知<ul><li>包围一个连接点的通知</li><li>类似Web中Servlet规范中的Filter的doFilter方法</li><li>可以在方法的调用前后完成自定义的行为，也可以选择不执行</li><li>ApplicationContext中在<aop:aspect>里面使用<aop:around></aop:around></aop:aspect></li></ul></li><li>After throwing advice 抛出异常后通知<ul><li>在方法抛出异常退出时执行的通知</li><li>ApplicationContext中在<aop:aspect>里面使用<aop:after-throwing><br>注：可以将多个通知应用到一个目标对象上，即可以将多个切面织入到同一目标对象</aop:after-throwing></aop:aspect></li></ul></li></ul></li><li><p>使用Spring AOP</p><ul><li>注解<ul><li>XML文件中声明激活自动扫描组件功能，同时激活自动代理功能（来测试AOP的注解功能）</li><li>为Aspect切面类添加注解</li></ul></li><li>XML</li></ul></li><li><p>Srping AOP难点</p><ul><li>理解AOP的理念和相关概念</li><li>灵活掌握和使用切入点表达式</li></ul></li><li><p>execution</p><ul><li>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?<ul><li>modifiers-pattenr<ul><li>方法的操作权限</li></ul></li><li>ret-type-pattern<ul><li>返回值</li><li>必选</li></ul></li><li>declaring-type-pattern<ul><li>方法所在的包</li></ul></li><li>name-pattern<ul><li>方法名</li><li>必选</li></ul></li><li>parm-pattern<ul><li>参数名</li></ul></li><li>throws-pattern<br>  异常</li></ul></li></ul></li><li><p>访问当前的连接点</p><ul><li>每个通知方法第一个参数都是JoinPoint。其实，在Spring中，任何通知方法都可以将第一个参数定义为org.aspect.lang.JoinPoint类型用以接受当前连接点对象。</li><li>JoinPoint接口提供了一系列有用的方法<ul><li>getArgs()<ul><li>返回方法参数</li></ul></li><li>getThis()<ul><li>返回代理对象</li></ul></li><li>getTarget()<ul><li>返回目标</li></ul></li><li>getSignature()<ul><li>返回正在被通知的方法相关信息</li></ul></li><li>toString()<ul><li>打印出正在被通知的方法的有用信息</li></ul></li></ul></li></ul></li></ul><p><strong>SpringAOP设计原理及源码分析</strong></p><ul><li><p>Spring生成代理对象</p><ul><li>JDkProxy(如果是接口)</li><li>Cglib(不是接口)<br>具体使用哪种方式由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDkProxy，否则使用Cglib。</li></ul></li><li><p>织入代理对象<br>InvocationHandler是JDk动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法而通过JdkDynamicAopProxy的签名可以看到这个类其实也实现了InvocationHandler</p><pre><code>* JdkDynamicAopProxy---invoke    * 主入口* AdvisedSupport---getInterceptorsAndDynamicInterceptionAdvice    * 获取通知链* AdvisorChainFactory---getInterceptorsAndDynamicInterceptionAdvice    * 获取通知链* DefaultAdvisorChainFactory---getInterceptorsAndDynamicInterceptionAdvice    * 获取通知链实现* ReflectiveMethodInvocation---proceed()    * 触发拦截器链执行</code></pre></li></ul><h3 id="七、Spring-JDBC设计原理及二次开发"><a href="#七、Spring-JDBC设计原理及二次开发" class="headerlink" title="七、Spring JDBC设计原理及二次开发"></a>七、Spring JDBC设计原理及二次开发</h3><ul><li>使用Spring进行基本的JDBC访问数据库有多种选择<ul><li>JdbcTmplate<ul><li>经典的也是最常用的Spring对于JDBC访问的方案</li><li>最低级别的封装</li><li>其他的工作模式底层的实现基础</li><li>JDK1.4以上</li><li>NamedParameterJdbcTemplate<ul><li>封装JdbcTemplate</li><li>提供了更加编辑的基于命名参数的使用方式而不是传统的JDBC所使用的?作为参数的占位符</li></ul></li></ul></li><li>Spring2.5中新提供的SimpleJdbc类能够更好的处理数据库元数据<ul><li>SimpleJdbcTemplate<ul><li>结合了JdbcTemplate和NamedParameterJdbcTemplate最常用的功能</li><li>利用了Java5的特性所带来的优势<ul><li>泛型</li><li>varargs</li><li>autoboxing</li></ul></li></ul></li><li>SimpleJdbcInsert &amp; SimpleJdbcCall<ul><li>这两个类可以充分利用数据库元数据的特性来简化配置</li><li>可以仅仅提供数据库表明或者存储过程的名称以及一个Map作为参数<ul><li>Map的key需要与数据库表中的字段保持一致</li></ul></li><li>通常和SimpleJdbcTemplate配合使用</li><li>JDK5</li><li>需要数据库提供足够的元数据信息</li></ul></li></ul></li><li>RDBMS Object风格的面向对象封装方式，类似于JDo的查询设计<ul><li>MappingSqlQuery</li><li>SqlUpdate and StoreProcedure</li><li>这种方式允许在初始化数据访问层时创建可重用并且线程安全的对象<ul><li>该对象在定义了查询语句，声明查询参数并编译相应的Query之后被模型化</li><li>一旦模型化完成，任何执行函数就可以掺入不同的参数进行多次调用</li></ul></li><li>JDK4<br>所有的工作模式都必须邀请JDBC2.0以上的数据库驱动的支持，其中一些高级的功能可能需要JDBC3.0以上的数据库驱动支持</li></ul></li></ul></li></ul><p><strong>异常处理</strong></p><ul><li><p>SQLExceptionTranslator</p><ul><li>接口</li><li>在SQLException和org.springframework.dao.DataAccessException之间作转换，必须实现该接口</li><li>转换器类的实现可以采用一般通用的做法<ul><li>JDBC—SQLState code</li><li>定制(精准)<ul><li>Oracle—error code</li></ul></li></ul></li><li>默认实现为SQLErrorCodeSQLExceptionTranslator<ul><li>使用指定数据库厂商的error code，比SQLState梗精准</li><li>转换过程基于一个JavaBean（类型为SQLErrorCodes）中的error code<ul><li>JavaBean由SQLErrorCodesFactory工厂类创建<ul><li>其中的内容来自于”sql-error-codes.xml”配置文件</li><li>该文件中的数据库厂商代码基于Database MetaData信息中的DatabaseProductName，从而配合当前数据库的使用</li></ul></li></ul></li></ul></li></ul></li><li><p>SQLErrorCodeSQLExceptionTranslator匹配规则</p><ul><li>首先检查是否存在完成定制转换的子类实现<ul><li>通常此类可以作为一个具体类使用，不需要进行定制，那么这个规则将不适用</li></ul></li><li>接着将SQLException的error code与错误代码集中的error code进行匹配<ul><li>默认情况下错误代码集将从SQLErrorCodesFactory取得</li><li>错误代码集来自classpath下的sql-error-codes.xml文件</li><li>他们将与数据库metadata信息中的database name进行映射，使用fallback翻译器<ul><li>SQLStateSQLExceptionTranslator类是缺省的fallback翻译器</li></ul></li></ul></li></ul></li></ul><p><strong>config模块</strong></p><ul><li>NamespaceHandler接口<ul><li>DefalutBeanDefinitionDocumentReader使用该接口来处理在spring.xml配置文件中自定义的命名空间</li><li>在jdbc模块，使用JdbcNamespaceHandler来处理jdbc配置的命名空间 </li></ul></li><li>org.w3c.dom软件包(JdbcNamespaceHandler引用）<pre><code>* 为文档对象模型(DOM)提供接口* 该模型是Java API for XMl Processing的组件API* 该Document Object Model Level 2 Core API允许程序动态访问和更新文档的内容和结构* 包下的类    * 自行查阅相关文档</code></pre></li></ul><p><strong>core模块</strong></p><ul><li><p>JdbcTemplate</p><ul><li>core包的核心类</li><li>完成了资源的创建以及释放工作，从而简化了JDBC的使用</li><li>避免一些常见的错误(忘记关闭数据库连接)</li><li>完成JDBC核心处理流程<ul><li>SQL语句的创建、执行，而把SQL语句的生成以及查询结果的提取工作留给应用代码</li><li>完成SQl查询、更新以及调用存储过程，可以对ResultSet进行遍历并加以提取</li><li>捕获JDBC异常并将其转换为org.springframework.dao包中定义的通用、信息丰富的异常</li></ul></li><li>使用JdbcTemplate进行编码只需要根据明确定义的一组契约来实现回调接口<ul><li>PreparedStatementCreator回调接口通过给定的Connection创建一个PreparedStatement，包含SQL和任何相关的参数</li><li>CallableStatementCreator实现同样的处理，创建CallableStatement</li><li>RowCallbackHandler接口则从数据集的每一行中提取值</li></ul></li><li>实例化<ul><li>DAO实现类中通过传递一个DataSource引用来完成<ul><li>DataSource bean将传递给service</li></ul></li><li>在Spring的IoC容器中配置一个JdbcTemplate的bean并赋予DAO实现类作为一个实例<ul><li>DataSource bean将传递给JdbcTemplate bean</li><li>需要注意的是DataSource在Spring的IoC容器中总是配置成一个bean</li></ul></li></ul></li></ul></li><li><p>元数据metaData</p><ul><li>CallMetaDataProviderFactory创建 CallMetaDataProvider 的工厂类</li><li>TableMetaDataProviderFactory 创建 TableMetaDataProvider 工厂类</li></ul></li><li>使用SqlParameterSource提供参数值<ul><li>BeanPropertySqlParameterSource</li></ul></li><li><p>DataSource</p><ul><li>获取数据库的连接</li><li>jdbc规范的一部分，通过ConnectionFactory获取</li><li>当使用Spring的jdbc层，可以通过JNDI来获取DataSource，也可以配置第三方连接池实现来获取<ul><li>第三方实现<ul><li>apache Jakarta Commons dbcp</li><li>c3p0</li></ul></li></ul></li><li>TransactionAwareDataSourceProxy<ul><li>作为目标DataSource的一个代理，在对目标DataSource包装的同时，还增加了Spring的事务管理能力</li><li>该类几乎很少被用到，除非现有代码在被调用的时候需要一个标准的JDBC DataSource接口实现作为参数。在这种情况下，这个类可以使现有代码参与Spring的事务管理。通常最好的做法是使用更高层的抽象来对数据源进行管理，比如JdbcTemplate和DataSourceUtils等</li></ul></li></ul></li><li><p>Object 模块</p></li></ul><h3 id="八、Spring-MVC框架设计原理"><a href="#八、Spring-MVC框架设计原理" class="headerlink" title="八、Spring MVC框架设计原理"></a>八、Spring MVC框架设计原理</h3><p><strong>DispatcherServlet</strong></p><ul><li>是 springmvc 中的前端控制器(front controller),负责接收 request 并将 request 转发给对应的处理组件.</li><li>扩展了同一个包中的抽象类FrameworkServlet,包含一些解析器的私有静态字段<ul><li>用于本地化、视图、异常或上传文件</li><li>映射处理器HandlerMapping<ul><li>是springmvc中完成url到controller映射的组件.DispatcherServlet接收request, 然后从HandlerMapping查找处理request的controller</li></ul></li><li>处理适配器hanlderAdapter</li></ul></li><li>为web应用程序提供了一个中心入口点。该集中入口点将系统组件的共同特征进行重新组合。可以在那里找到安全资源、语言切换、会话管理、缓存或输入过滤的处理程序。<ul><li>好处是共同的入口点有助于避免代码重复</li></ul></li><li>对以下询问做出最佳响应<ul><li>如何集中授权和认证</li><li>如何处理正确的视图渲染</li><li>如何使用URL重写映射将请求发送到适当的控制器</li></ul></li><li>这个前台控制器模式包含的参与者<ul><li>客户端：发送请求</li><li>控制器：应用程序的中心点，捕获所有请求<ul><li>Controller<ul><li>处理 request,并返回 ModelAndView 对象,Controller 是 springmvc 中负责处理 request 的组件(类似于 struts2 中的 Action),ModelAndView 是封装结果视图的组件.<br>  度员：管理视图的选择，以呈现给客户端            </li></ul></li></ul></li><li>视图：表示呈现给客户端的内容<ul><li>ModelAndView &amp; ViewResolver &amp; View<ul><li>视图解析器解析 ModelAndView 对象并返回对应的视图给客户端</li></ul></li></ul></li><li>帮助：帮助查看和/或控制器完成请求处理</li></ul></li><li>前端控制器模式有自己的执行链。这意味着它有自己的逻辑来处理请求并将视图返回给客户端<ul><li>请求由客户端发送。它到达作为Spring的默认前端控制器的DispatcherServlet类</li><li>DispatcherServlet使用请求处理程序映射来发现将分析请求的控制器(controller)。接口org.springframework.web.servlet.HandlerMappingd的实现返回一个包含 org.springframework.web.servlet.HandlerExecutionChain类的实例。此实例包含可在控制器调用之前或之后调用的处理器程序拦截器数组。<ul><li>如果在所有定义的处理程序映射中找不到HandlerExecutionChain,这意味着Spring无法将URL与对应的控制器进行匹配。这样的话会抛出一个错误</li></ul></li><li>现在系统进行拦截器预处理并调用由映射处理器找到的相应的controller(其实就是在找到controller之前进行一波拦截处理)。在controller处理请求后，DispatcherServlet开始拦截器的后置处理。在此步骤结束时，它从controller接收ModelAndView实例（整个过程其实就是request请求-&gt;进入interceptors-&gt;controller-&gt;从interceptors出来-&gt;ModelAndView接收）</li><li>DispatcherServlet现在将使用的该视图的名称发送到视图解析器。这个解析器将决定前台的展现内容。接着，它将此视图返回给DispatcherServlet，其实也就是一个“视图成成后可调用”的拦截器。</li><li>最后一个操作是视图的渲染并作为客户端request请求的响应</li></ul></li><li><p>执行步骤</p><ul><li>策略初始化<ul><li>核心点<ul><li>DispatcherServlet—initStrategies<ul><li>onRefresh()时调用</li><li>FrameworkServlet中initServletBean—initWebApplicationContext—onRefresh(wac)<ul><li>通过所提供的这些策略生成所需要的应用程序上下文，其每个策略都会产生一类在DispatcherServlet中用来处理传入请求的对象</li></ul></li></ul></li></ul></li></ul></li><li>请求预处理<ul><li>FrameworkServlet—processRequest</li></ul></li><li>请求处理<ul><li>DispatcherServlet—doService</li><li>DispatcherServlet—doDispatch</li></ul></li><li>视图解析<ul><li>DispatcherServlet—applyDefaultViewName</li></ul></li><li>处理调度请求-视图渲染<ul><li>DispatcherServlet—processDispatchResult</li><li>在这部分，需要记住的是定义了两个上下文<ul><li>用于应用程序<ul><li>应用程序上下文包含所有通用配置，比如service定义，数据库配置</li></ul></li><li>用于Web应用程序<ul><li>定义所有与Web相关的组件，比如controllers或视图解析器<br><strong>handler</strong></li></ul></li></ul></li></ul></li></ul></li><li><p>Spring中存在两种handler</p><ul><li><p>handler mappings处理程序映射</p><ul><li>它们的角色定位与前面所描述的功能完全相同</li><li>它们尝试当前请求与相应的controller以及其中的方法相匹配</li><li><p>最基本的org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping类</p><ul><li>将URL与相应的bean进行匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;/friends&quot; class&quot;com.2bai.controller.FriendsController&quot; /&gt;</div></pre></td></tr></table></figure></li></ul></li><li><p>更灵活的处理映射器org.springframework.web.servlet.handler.SimpleUrlHandleMapping</p><ul><li><p>可以创建一个映射文件，其中包含URl作为键和controller作为值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;simpleUrlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandleMapping&quot;&gt;</div><div class="line">&lt;property name=&quot;mappings&quot;&gt;</div><div class="line">&lt;props&gt;</div><div class="line">&lt;prop key=&quot;/friends.html&quot;&gt;FriendsControler&lt;/props&gt;</div><div class="line">&lt;/props&gt;</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></li><li><p>处理稍微复杂URL也是一个头疼的问题</p></li></ul></li><li>DefaultAnnotationHandlerMapping或者在Spring5中使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<ul><li>映射检测是基于注解<ul><li>@Controller</li><li>@RequestMapping</li></ul></li><li>配置文件中定义<mvc:annotation-driven>，此处理程序将被激活</mvc:annotation-driven></li><li>更细粒度的处理cotroller注解<ul><li><context:annotation-config></context:annotation-config></li><li><context:component-scan base-package="path.with.my.services.and.controllers"></context:component-scan></li></ul></li></ul></li></ul></li><li>handler adapter处理器适配器<ul><li>handler adapter从handler mappings中获取映射的controllers和方法并调用它们。</li><li>这种类型的适配器必须实现org.springframework.web.servlet.HandlerAdapter接口，它只有三种方法<ul><li>supports方法：检查传入参数的对象是否可以由此适配器处理</li><li>handle方法：将请求翻译称视图</li><li>getLastModified：返回给定HttpServletRequest的最后修改日期，以毫秒为单位</li></ul></li></ul></li></ul></li><li><p>版本变化</p><ul><li>3.2废弃,4.x里还可以看到，5已经废弃<ul><li>DefaultAnnotationHandlerMapping</li><li>AnnotationMethodHandlerAdapter</li><li>AnnotationMethodHandlerExceptionResolver</li></ul></li><li>替代品<ul><li>RequestMappingHandlerMapping</li><li>RequestMappingHandlerAdapter</li><li>ExceptionHandlerExceptionResolver</li></ul></li><li>通过这些新类以便于自定义映射。</li><li>通过在Spring3.1版本中org.framework.web.mehthod.HandlerMethod类中引入，来将所处理的对象转换为其方法表示。可以通过这个方法来判断对象返回的类型或者哪些参数是所期望的。</li></ul></li><li><p>处理程序拦截器</p><ul><li>HTTP请求的执行链<ul><li>DispatcherServlet捕获每个请求。调度员做的第一件事就是将接收到的URl和相应的controller进行映射。在到达对应的controller之前，请求可以被拦截器处理。这些拦截器就像过滤器。只有当URL找到对应于它们的映射时才调用他们。在通过拦截器进行前置处理后，请求最终到达哦controller。之后，发送请求生成视图。但是在这之前，拦截器还是有可能来再次处理它（拦截器后置处理）。只有在最后一次操作之后，视图解析器才能捕获数据并输出视图。</li></ul></li><li>处理程序映射拦截器基于org.springframework.web.servlet.HandlerInterceptor接口<ul><li>方法前使用preHandle<ul><li>返回false，则可以在执行链中执行终端请求处理</li><li>afterCompletion<ul><li>返回true时才会在渲染视图后调用它(完成请求处理后的回调，即渲染视图后)</li></ul></li></ul></li><li>方法后使用postHandle</li></ul></li><li>在新线程中启动<ul><li>实现org.framework.web.servlet.AsyncHandlerInterceptor接口，它结成HandlerInterceptor并提供一个方法afterConcurrentHandlingStarted<ul><li>每次处理程序得到正确执行时，都会调用此方法而不是调用postHandler()和afterCompletion().</li><li>它也可以对发送请求进行异步处理。</li></ul></li></ul></li><li>默认的Springl拦截器<ul><li>Spring主要将拦截器用于切换动作。<ul><li>区域设置更改<ul><li>org.springframework.web.servlet.i18n.LocalChangeInterceptor</li><li>可以通过所定义的语言环境解析器来对HTTP请求进行分析来实现</li><li>所有区域设置解析器都会分析请求元素(headers,Cookie)，以确定向用户提供哪种本地化语言设置</li></ul></li><li>更改视图的主题<ul><li>org.springframework.web.servlet.theme.ThemehangeInterceptor</li><li>也基于请求分析<ul><li>cookie</li><li>会话</li><li>参数</li></ul></li></ul></li></ul></li></ul></li><li>拦截器和过滤器之间的区别</li></ul></li></ul><table><thead><tr><th></th><th>过滤器</th><th>拦截器</th></tr></thead><tbody><tr><td>作用域</td><td>servlet容器下使用</td><td>Spring容器中调用</td></tr><tr><td>粒度</td><td>只能在将响应返回给最终用户之前使用</td><td>在controller对请求处理之前或之后被调用,也可以在将渲染视图呈现给用户之后被调用</td></tr><tr><td>中断链执行的难易程度</td><td>必须处理请求和响应对象来引发中断,需要一些额外的动作，比如将用户重定向到错误页面</td><td>通过在preHandler方法那返回false来简单实现</td></tr></tbody></table><p><strong>工作机制</strong></p><p>在容器初始化时会创建所有url和controller的对应关系，保存到Map<url,controller>中<br>tomcat启动时会通知Spring初始化容器(加载bean的定义信息和初始化所有单例bean)<br>然后SpringMVC会遍历容器中的bean，获取每一个controller中的所有方法访问的url<br>然后将url和controller保存到一个map中。</url,controller></p><p>这样就可以根据request快速定位到controller,因为最终处理request的是controller中的方法,Map中只保留了url和controller中的对应关系,所以要根据request的 url进一步确认controller中的method, 这一步工作的原理就是拼接controller的url(controller 上@RequestMapping的值)和方法的url(method 上 @RequestMapping 的值),与request的url进行匹配,找到匹配的那个方法;</p><p>确定处理请求的method后,接下来的任务就是参数绑定,把request中参数绑定到方法的形式参数上, 这一步是整个请求处理过程中最复杂的一个步骤。springmvc 提供了两种 request参数与方法形参的绑定方法:1.通过注解进行绑定,@RequestParam；2.通过参数名称进行绑定.</p><p>使用注解进行绑定,我们只要在方法参数前面声明@RequestParam(“a”),就可以将request中参数a的值绑定到方法的该参数上.使用参数名称进行绑定的前提是必须要获取方法中参数的名称,Java反射只提供了获取方法的参数的类型,并没有提供获取参数名称的方法.springmvc解决这个问题的方法是用asm框架读取字节码文件,来获取方法的参数名称.asm框架是一个字节码操作框架,关于 asm 更多介绍可以参考它的官网.个人建议,使用注解来完成参数绑定,这样就可以省去asm框架的读取字节码的操作.</p><p><strong>源码分析</strong></p><ul><li><p>源码分析分为三部分</p><ul><li>ApplicationContext初始化时建立所有url和controller类的对应关系(用map保存)</li><li>根据请求url找到对应的controller，并从controller中找到处理请求的方法</li><li>request参数绑定到方法的形参，执行方法处理请求，并返回结果视图</li></ul></li><li><p>建立Map<urls,controller>的关系</urls,controller></p><ul><li>ApplicationObjectSupport—setApplicationContext<ul><li>核心为初始化容器initApplicationContext(context)<ul><li>子类AbstractDetectingUrlHandlerMapping实现了该方法<ul><li>BeanNameUrlHandlerMapping—determineUrlsForHandler<br>到这里HandlerMapping组件就建立起所有url和contrller的对应关系</li></ul></li></ul></li></ul></li></ul></li><li><p>根据访问url找到对应controller中处理的方法<br>是由请求触发的，所以入口为DispatcherServlet的核心方法为doService(),doService()中的核心逻辑由doDispatch()实现的</p><ul><li>DispatcherServlet—doService</li><li>DispatcherServlet—doDispatch</li></ul></li><li><p>反射调用处理请求的方法，返回结果视图</p><ul><li>RequestMappingHandlerAdapter—invokeHandlerMethod</li></ul></li></ul><p><strong>SpringMVC优化</strong></p><ul><li>controller如果能保持单例，尽量使用单例模式<ul><li>这样就减少了创建对象和回收对象的开销<ul><li>也就是说，如果controller的类变量和实例变量可以以方法形参声明就尽量以方法的形参声明，不要以类变量和实例变量声明，这样可以避免线程安全问题</li></ul></li></ul></li><li>处理request的方法中的形参务必加上@RequestParam注解，这样可以避免SpringMVC使用asm框架读取class文件获取方法参数名的过程。即便SpringMVC对读取出的方法参数名进行了缓存，如果不要读取class文件当然是更加好</li><li>SpringMVC并没有对处理url的方法进行缓存，也就是说每次都要根据请求url去匹配controller中的方法url。如果把url和method的关系缓存起来，会不会带来性能上的提升呢？但是！负责解析url和method对应关系的ServletHandlerMethodResolver是一个private的内部类，不能直接继承该类增强代码，必须要改代码后重新编译。当然，如果缓存起来，必须要考虑缓存的线程安全问题。</li></ul><h3 id="九、Spring事务原理详解"><a href="#九、Spring事务原理详解" class="headerlink" title="九、Spring事务原理详解"></a>九、Spring事务原理详解</h3><p><strong>什么是事务Transaction</strong></p><ul><li>是访问并可能更新数据库中各种数据项的一个程序执行单元。</li><li>是恢复和并发控制的基本单元</li><li>属性ACID<ul><li>原子性atomicity<ul><li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li></ul></li><li>一致性consistency<ul><li>事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li></ul></li><li>隔离性isolation<ul><li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li></ul></li><li>持久性durability<ul><li>持久性也称永久性(permanence)，指一个事务一旦提交，它对数据库中数据 的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</li></ul></li></ul></li></ul><p><strong>事务的基本原理</strong></p><ul><li>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。</li><li><p>纯JDBC操作数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.获取连接</span></div><div class="line">Connection con = DriverManager.getConnection()</div><div class="line"><span class="comment">//2. 开启事务</span></div><div class="line">con.setAutoCommit(<span class="keyword">true</span>/<span class="keyword">false</span>);</div><div class="line"><span class="comment">//3. 执行 CRUD</span></div><div class="line"><span class="comment">//4. 提交事务/回滚事务 </span></div><div class="line">con.commit() / con.rollback();</div><div class="line"><span class="comment">//5. 关闭连接 </span></div><div class="line">conn.close();</div></pre></td></tr></table></figure></li><li><p>使用Spring的事务管理功能后，我们可以不再写步骤2和4的代码，而是由Spirng自动完成。那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢?解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。下面简单地介绍下，注解方式为例子:</p><ul><li><ol><li>配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。</li></ol></li><li><ol><li>spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方法，并且 为这些类和方法生成代理，并根据@Transaction 的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了(开启正常提交事务，异常回滚事务)。</li></ol></li><li><ol><li>真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。</li></ol></li></ul></li></ul><p><strong>Spring事务的传播属性</strong></p><p>所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如何处理这些事 务的行为。这些属性在 TransactionDefinition 中定义，具体常量的解释见下表</p><table><thead><tr><th>常量名称</th><th>常量解释</th></tr></thead><tbody><tr><td><code>PROPAGATION_REQUIRED</code></td><td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。</td></tr><tr><td><code>PROPAGATION_REQUIRES_NEW</code></td><td><code>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</code></td></tr><tr><td><code>PROPAGATION_SUPPORTS</code></td><td><code>支持当前事务，如果当前没有事务，就以非事务方式执行。</code></td></tr><tr><td><code>PROPAGATION_MANDATORY</code></td><td><code>支持当前事务，如果当前没有事务，就抛出异常。</code></td></tr><tr><td><code>PROPAGATION_NOT_SUPPORTED</code></td><td><code>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</code></td></tr><tr><td><code>PROPAGATION_NEVER</code></td><td><code>以非事务方式执行，如果当前存在事务，则抛出异常。</code></td></tr><tr><td><code>PROPAGATION_NESTED</code></td><td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按 REQUIRED 属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager 事务管理器起效。</td></tr></tbody></table><p><strong>数据库隔离级别</strong></p><table><thead><tr><th>隔离级别</th><th>隔离级别的值</th><th>导致的问题</th></tr></thead><tbody><tr><td><code>Read-Uncommitted</code></td><td>0</td><td>导致脏读</td></tr><tr><td><code>Read-Committed</code></td><td>1</td><td><code>避免脏读，允许不可重复读和幻读</code></td></tr><tr><td><code>Repeatable-Read</code></td><td>2</td><td><code>避免脏读，不可重复读，允许幻读</code></td></tr><tr><td><code>Serializable</code></td><td>3</td><td><code>串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</code></td></tr></tbody></table><ul><li>脏读<ul><li>一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这<br>时候回滚了，那么第二个事务就读到了脏数据。</li></ul></li><li>不可重复读<ul><li>一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进<br>行了修改，这时候两次读取的数据是不一致的。</li></ul></li><li>幻读<ul><li>第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一<br>个事务就会丢失对新增数据的修改。</li></ul></li></ul><blockquote><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。<br>大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle 少数数据库默认隔离级别为:Repeatable Read 比如: MySQL InnoDB</p></blockquote><p><strong>Spring中的隔离级别</strong></p><table><thead><tr><th>常量</th><th>解释</th></tr></thead><tbody><tr><td><code>ISOLATION_DEFAULT</code></td><td>这 是 个 PlatfromTransactionManager 默 认 的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</td></tr><tr><td><code>ISOLATION_READ_UNCOMMITTED</code></td><td><code>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</code></td></tr><tr><td><code>ISOLATION_READ_COMMITTED</code></td><td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td></tr><tr><td><code>ISOLATION_REPEATABLE_READ</code></td><td><code>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</code></td></tr><tr><td><code>ISOLATION_SERIALIZABLE</code></td><td><code>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</code></td></tr></tbody></table><p><strong>事务的嵌套</strong></p><p>通过上面的理论知识的铺垫，我们大致知道了数据库事务和spring事务的一些属性和特点，接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。</p><p>假设外层事务 Service A 的 Method A() 调用 内层 Service B 的 Method B()</p><p><code>PROPAGATION_REQUIRED(spring 默认)</code></p><ul><li>如果 ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候 spring 已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运 行在 ServiceA.methodA() 的事务内部，就不再起新的事务。</li><li>假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。</li></ul><p><code>PROPAGATION_REQUIRES_NEW</code></p><ul><li>比如我们设计ServiceA.methodA()的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为PROPAGATION_REQUIRES_NEW。<br>那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起， ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。</li><li>它与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。<ul><li>如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。</li><li>如果 ServiceB.methodB() 失败回滚，如果他抛出的 异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看 B 抛出的异常是不 是 A 会回滚的异常)。</li></ul></li></ul><p><code>PROPAGATION_SUPPORTS</code></p><ul><li>假设 ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到 ServiceB.methodB() 时<ul><li>如果发现 ServiceA.methodA()已经开启了一个事务，则加入当前的事务</li><li>如果发现 ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。</li></ul></li></ul><p><code>PROPAGATION_NESTED</code></p><ul><li>现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时 两者之间又将如何协作呢?<ul><li>ServiceB#methodB如果rollback,那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下 两种处理方式:<ul><li>捕获异常，执行异常分支逻辑<ul><li>这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不 会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。</li></ul></li><li>外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB#methodB) rollback, 那么 首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback</li></ul></li></ul></li></ul><p>另外三种事务传播属性基本用不到，在此不做分析。</p><h3 id="十、Spring事务源码分析"><a href="#十、Spring事务源码分析" class="headerlink" title="十、Spring事务源码分析"></a>十、Spring事务源码分析</h3><ul><li>TransactionDefinition</li><li>PlatformTransactionManager<ul><li>DataSourceTransactionManager<ul><li>JDBC</li></ul></li><li>HibernateTransactionManager<ul><li>Hibernate</li></ul></li><li>JpaTransactionManager<ul><li>JPA</li></ul></li><li>JtaTransactionManager<ul><li>JTA</li></ul></li></ul></li><li>TransactionStatus</li></ul><p><code>TransactionDefinition</code>–传参到getTransation–&gt;<code>PlatformTransactionManager</code>–getTransaction得到–&gt;<code>TransactionStatus</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github=blog</title>
      <link href="/GHPages/blog.html"/>
      <url>/GHPages/blog.html</url>
      
        <content type="html"><![CDATA[<h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>操作参考github手册，仓库名称为：<code>username.github.io</code></p><a id="more"></a><h3 id="创建hexo"><a href="#创建hexo" class="headerlink" title="创建hexo"></a>创建hexo</h3><ul><li><code>mkdir blog</code></li><li><code>cd blog</code></li><li><code>npm install hexo-cli -g</code></li><li><code>hexo init</code></li></ul><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><ul><li><code>git clone git@github.com:USERNAME/USERNAME.github.io.git</code></li><li>把blog文件夹下的内容全部复制到仓库文件夹内</li></ul><h3 id="生成静态页面-amp-运行"><a href="#生成静态页面-amp-运行" class="headerlink" title="生成静态页面&amp;运行"></a>生成静态页面&amp;运行</h3><ul><li><code>hexo generate</code></li><li><code>hexo server</code></li></ul><h3 id="配置-config-yml"><a href="#配置-config-yml" class="headerlink" title="配置__config.yml"></a>配置<code>__config.yml</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy: </div><div class="line">  type: git</div><div class="line">  repo: git@github.com:USERNAME/USERNAME.github.io.git</div></pre></td></tr></table></figure><h3 id="安装部署插件"><a href="#安装部署插件" class="headerlink" title="安装部署插件"></a>安装部署插件</h3><ul><li><code>npm install hexo-deployer-git -save</code></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li><code>hexo deploy</code></li></ul><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><ul><li><a href="https://USERNAME.github.io" target="_blank" rel="external">https://USERNAME.github.io</a></li></ul><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><ul><li><a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a></li><li>下载后放到项目中<code>theme</code>文件夹下</li><li>修改文件夹名字<ul><li><code>hexo-theme-Nlvi</code>-&gt;<code>Nlvi</code></li></ul></li><li>修改项目中的配置文件<code>__config.yml</code><ul><li><code>theme: Nlvi</code></li></ul></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><code>_config.yml</code>冒号后要有一个空格</li></ul>]]></content>
      
      
      <categories>
          
          <category> GHPages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GHPages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/GHPages/hello.html"/>
      <url>/GHPages/hello.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> GHPages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GHPages </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
