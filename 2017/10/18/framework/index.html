<!DOCTYPE html>
<html lang="">
<head>
    <title> spring-framework · super2bai </title>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="super2bai">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />
<meta name="keywords" content="nlvi, Nlvi" />





    <meta name="keywords" content="Spring, Nlvi" />

<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "super2bai",
        author: "super2bai",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">







  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-116557847-1', 'auto');
  ga('send', 'pageview');
</script>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/GitHub-Pages/" style="font-size: 14px;">GitHub Pages</a> <a href="/tags/IO/" style="font-size: 14px;">IO</a> <a href="/tags/JVM/" style="font-size: 14px;">JVM</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 14px;">Zookeeper</a> <a href="/tags/walkup/" style="font-size: 14px;">walkup</a> <a href="/tags/分布式/" style="font-size: 14px;">分布式</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">super2bai</a></span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        
        
            <li class="menu-item">
                <a href="/">
                    <span>Article</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>Tags</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
</header>
<div class="mobile-header">
    <div class="mobile-header-body">
        <div class="mobile-header-list">
            
            
                <div class="mobile-nav-item">
                    <a href="/">
                        <span>Article</span>
                        
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/archives">
                        <span>Archives</span>
                        
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item inner-cloud">
                    <div class="mobile-nav-tag">
                        <a href="javascript:;" id="mobile-tags">
                            <span>Tags</span>
                            
                            
                        </a>
                    </div>
                    <div class="mobile-nav-tagcloud">
                        <div class="mobile-tagcloud-inner">
                            <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/GitHub-Pages/" style="font-size: 14px;">GitHub Pages</a> <a href="/tags/IO/" style="font-size: 14px;">IO</a> <a href="/tags/JVM/" style="font-size: 14px;">JVM</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 14px;">Zookeeper</a> <a href="/tags/walkup/" style="font-size: 14px;">walkup</a> <a href="/tags/分布式/" style="font-size: 14px;">分布式</a>
                        </div>
                    </div>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/about">
                        <span>About</span>
                        
                        
                    </a>
                </div>
            
            
        </div>
    </div>
    <div class="mobile-header-nav">
        <div class="mobile-header-item" id="mobile-left">
            <div class="header-menu-item">
                <span class="header-menu-line"></span>
            </div>
        </div>
        <h1 class="mobile-header-title">
            <a href="/">super2bai</a>
        </h1>
        <div class="mobile-header-item"></div>
    </div>
</div>

    <div class="container">
        <main class="main" id="main">
            
    
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>October 18, 2017</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                spring-framework
            
            </h1>
            
                
                    <div class="post-tags syuanpi riseIn-light back-3">
                    
                        <a href="/tags/Spring/">Spring</a>
                    
                    </div>
                
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                <h3 id="一、什么是IOC-DI"><a href="#一、什么是IOC-DI" class="headerlink" title="一、什么是IOC/DI"></a>一、什么是IOC/DI</h3><a id="more"></a>
<p><strong>IOC Inversion of Control  控制反转</strong><br>就是把代码里面需要实现的对象创建、依赖的代码，反转给容器来实现<br>那么必然需要创建一个容器，同时需要一种描述来让容器知道需要创建的对象与对象的关系<br>这个描述最具体表现就是可配置的文件</p>
<p><strong>DI Dependency Injection  依赖注入</strong><br>就是指对象是被动接收依赖类而不是自己主动去找<br>换句话说就是指对象不是从容器中查找它依赖的类，而是在容器实例化的时候主动将它依赖的类注入给它</p>
<p><strong>对象和对象关系怎么表示:</strong></p>
<ul>
<li>XML</li>
<li>properties文件</li>
<li>等语义化配置文件表示</li>
</ul>
<p><strong>描述对象关系的文件存放在:</strong></p>
<ul>
<li>classpath</li>
<li>filesystem</li>
<li>URL网络资源</li>
<li>servletContext等</li>
</ul>
<h3 id="二、Spring-IOC体系结构"><a href="#二、Spring-IOC体系结构" class="headerlink" title="二、Spring IOC体系结构"></a>二、Spring IOC体系结构</h3><p><strong>BeanFactory</strong></p>
<ul>
<li>只对IOC容器的基本行为作了定义，不关心如何加载</li>
<li>Spring Bean的创建是典型的工厂模式，这一些列的Bean工厂</li>
<li>也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务</li>
<li>BeanFactory作为最顶层的一个接口类,它定义了IOC容器的基本功能规范，子类有：<ul>
<li>ListableBeanFactory(可列表)</li>
<li>HierarchicalBeanFactory(有继承关系)</li>
<li>AutowaireCapableBeanFactory(定义Bean的自动装配规则)</li>
<li>最终实现是DefaultListableBeanFactory</li>
</ul>
</li>
<li>这四个接口共同定义了Bean的集合、之间的关系和行为</li>
<li>如何生产对象，要看IOC容器的实现<ul>
<li>XmlBeanFactory<ul>
<li>最基本的IOC容器的实现</li>
<li>读取XML文件定义的BeanDefinition</li>
</ul>
</li>
<li>ClasspathXmlApplicationContext<ul>
<li>高级的IOC容器</li>
<li>提供IOC容器的基本功能</li>
<li>附加服务<ul>
<li>支持信息源，可以实现国际化</li>
<li>访问资源</li>
<li>支持应用事件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BeanDefinition</strong></p>
<ul>
<li>Bean对象在Spring实现中是以BeanDefinition来描述的</li>
<li><p>Bean的解析主要就是对Spring配置见的解析</p>
<p>  ​</p>
<h3 id="三、IoC容器的初始化"><a href="#三、IoC容器的初始化" class="headerlink" title="三、IoC容器的初始化"></a>三、IoC容器的初始化</h3><p><strong>IOC容器的初始化</strong></p>
</li>
<li>BeanDefinition的Resource<ul>
<li>定位</li>
<li>载入</li>
<li>注册<blockquote>
<p>ApplicationContext允许上下文嵌套，通过保持父上下文可以维持一个上下文体系。对于bean的查找可以在这个上下文体系中发生，首先检查当前上下文，其次是父上下文，逐级向上，这样为不同的Spring应用提供了一个共享的bean定义环境。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>IOC容器的创建过程</strong></p>
<ul>
<li>XmlBeanFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息</span></div><div class="line">ClassPathResource resource =<span class="keyword">new</span> ClassPathResource(<span class="string">"application-context.xml"</span>);</div><div class="line"></div><div class="line"><span class="comment">//创建DefaultListableBeanFactory</span></div><div class="line">DefaultListableBeanFactory factory =<span class="keyword">new</span> DefaultListableBeanFactory();</div><div class="line"></div><div class="line"><span class="comment">//创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。</span></div><div class="line"><span class="comment">//之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory</span></div><div class="line"></div><div class="line">XmlBeanDefinitionReader reader =<span class="keyword">new</span> XmlBeanDefinitionReader(factory);</div><div class="line"></div><div class="line"><span class="comment">//XmlBeanDefinitionReader执行载入BeanDefinition的方法，最后会完成Bean的载入和注册。</span></div><div class="line"><span class="comment">//完成后Bean就成功的放置到IOC容器当中，以后我们就可以从中取得 Bean来使用</span></div><div class="line">reader.loadBeanDefinitions(resource);</div></pre></td></tr></table></figure>
<ul>
<li>FileSystemXmlApplicationContext    <ul>
<li>通过调用父类AbstractApplicationContext的refresh()启动整个IoC容器对Bean定义的载入过程</li>
<li>AbstractRefreshableApplicationContext 子类的 loadBeanDefinitions()</li>
<li>AbstractBeanDefinitionReader读取Bean定义资源 loadBeanDefinitions()<ul>
<li>调用资源加载器的获取资源方法resourceLoader.getResource(location),获取到要加载的资源</li>
<li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinition()</li>
</ul>
</li>
<li>资源加载器获取要读取的资源<ul>
<li>XmlBeanDefinitionReader通过调用其父类DefaultResourceLoader的getResource方法获取要加载的资源    </li>
<li>真正执行加载功能是其子类XmlBeanDefinitionReader的loadBeanDefinitions()</li>
</ul>
</li>
<li>XmlBeanDefinitionReader加载bean资源<ul>
<li>通过源码分析，载入Bean定义资源文件的最后一步是将Bean定义资源转换为Document对象，该过程由documentLoader实现</li>
</ul>
</li>
<li>DocumentLoader将Bean定义资源转换成Document对象<ul>
<li>DefaultDocumentLoader的loadDocument方法</li>
<li>该解析过程调用JavaEE标准的JAXP标准进行处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>至此，Sping IOC容器根据定位的Bean定义资源文件，将其加载读入并转换成为Document对象过程完成。<br>接下来要继续分析Spring IOC容器将载入的Bean定义资源文件转换为Document对象之后，是如何将其解析为Spring IOC管理的Bean对象并将其注册到容器中的</p>
</blockquote>
<p><strong>XmlBeanDefinitionReader解析载入Bean定义资源文件</strong></p>
<ul>
<li>doLoadBeanDefinitions</li>
<li>Bean定义资源的载入解析<ul>
<li>通过调用XML解析器将Bean定义资源文件转换得到Document对象，这一步是载入<ul>
<li>这些Document对象并没有按照Spring的Bean规则进行解析</li>
</ul>
</li>
<li>在完成通用的XML解析之后，按照Spring的Bean规则对Document对象进行解析<ul>
<li>接口BeanDefinitionDocumentReader的实现类DefaultBeanDefinitionDocumentReader实现的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>DefaultBeanDefinitionDocumentReader对Bean定义的Document对象解析</strong></p>
<ul>
<li>BeanDefinitionDocumentReader 接口通过 registerBeanDefinitions 方法调用其实现类 DefaultBeanDefinitionDocumentReader 对 Document 对象进行解析<ul>
<li><import>—DefaultBeanDefinitionDocumentReader</import></li>
<li><alias>—DefaultBeanDefinitionDocumentReader</alias></li>
<li><bean>—BeanDefinitionParserDelegate—parseBeanDefinitionElement</bean></li>
</ul>
</li>
</ul>
<p><strong>BeanDefinitionParserDelegate 解析 Bean 定义资源文件中的<bean>元素</bean></strong></p>
<ul>
<li>BeanDefinitionParserDelegate<ul>
<li>配置文件中<bean>元素中配置的属性就是通过该方法解析和设置到bean中的</bean></li>
<li>解析<bean>元素过程中没有创建和实例化Bean对象，只是创建了Bean对象的定义类BeanDefinition<ul>
<li>将<bean>元素中的配置信息设置到BeanDefinition中作为记录，当依赖注入时才使用这些记录信息创建和实例化具体的Bean对象</bean></li>
</ul>
</bean></li>
</ul>
</li>
</ul>
<p><strong>BeanDefinitionParserDelegate 解析<property>元素</property></strong></p>
<ul>
<li>BeanDefinitionParserDelegate—parsePropertyElements<ul>
<li>ref被封装为指向依赖对象的一个引用</li>
<li>value配置都会封装为一个字符串类型的对象</li>
<li>ref和value都通过”解析的数据类型属性值.setSource(extractSource(ele));”方法将属性值/引用与所引用的属性关联起来</li>
<li>该方法的最后对于<property>元素的子元素通过parsePropertySubElement方法解析</property></li>
</ul>
</li>
</ul>
<p><strong>解析property元素的子元素</strong></p>
<ul>
<li>BeanDefinitionParserDelegate—BeanDefinitionParserDelegate<ul>
<li>Spring配置文件中，对<property>元素中配置的Array、List、Set、Map、Prop等各种集合子元素都通过上述方法解析，生成对应的数据对象<ul>
<li>如果ManagedList、ManagedSet等，这些Managed类是Spring对象BeanDefinition的数据封装，对集合数据类型的具体解析有各自的解析方法实现，解析方法的命名非常规范。</li>
</ul>
</property></li>
</ul>
</li>
</ul>
<p><strong>解析list元素的子元素</strong></p>
<ul>
<li>BeanDefinitionParserDelegate—parseListElement</li>
</ul>
<blockquote>
<p>经过对Spring Bean定义资源文件转换的Document对象中的元素层层解析，Spring IoC现在已经将XML性质定义的Bean定义资源文件转换为Spring IoC所识别的数据结构—BeanDefinition，它是Bean定义资源文件中配置POJO对象在Spring IoC容器中的映射，可以通过AbstractBeanDefinition为入口，看到了IoC容器进行索引、查询和操作.</p>
<p>通过Spring IoC容器对Bean定义资源的解析后，IoC容器大致完成了管理Bean对象的准备工作，即初始化过程，但是最为重要的依赖注入还没有发生，现在在IoC容器中BeanDefinition存储的只是一些静态信息，接下来需要向同期注册Bean定义信息才能全部完成IoC容器的初始化过程。</p>
<p>继续跟踪程序的执行顺序，接下来会到分析DefaultBeanDefinitionDocumentReader对Bean定义转换的Document对象解析的流程中，在其parseDefaultElement方法中完成对Document对象的解析后得到BeanDefinition的BeanDefinitionHolder对象，然后在processBeanDefinition方法里调用BeanDefinitionReaderUtils的registerBeanDefinition向IoC容器注册解析的Bean。</p>
</blockquote>
<p><strong>解析过后的BeanDefinition在IoC容器中的注册</strong></p>
<ul>
<li>BeanDefinitionReaderUtils—registerBeanDefinition<ul>
<li>当调用BeanDefinitionReaderUtils向IoC容器注册解析的BeanDefinition时，真正完成注册功能的是DefaultListableBeanFactory</li>
</ul>
</li>
</ul>
<p><strong>DefaultListableBeanFactory 向 IOC 容器注册解析后的 BeanDefinition</strong></p>
<ul>
<li>使用一个HashMap的集合对象存放IoC容器中注册解析的BeanDefinitio，向容器注册的主要源码</li>
<li>registerBeanDefinition方法向IoC容器注册</li>
</ul>
<blockquote>
<p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
</blockquote>
<hr>

<p><strong>总结</strong></p>
<p><strong>IoC容器初始化</strong></p>
<ul>
<li>初始化的入口在容器实现中的refresh()调用完成</li>
<li><p>对bean定义载入IoC容器使用的方法是loadBeanDefinition</p>
<blockquote>
<p>其中大致过程如下：通过ResourceLoader来完成资源文件位置的定位，DefaultResourceLoader是默认的实现，同时上下文本身就给出了ResourceLoader的实现，可以从类路径、文件系统、URL等方式来定位资源位置。如果是XmlBeanFactory作为IoC容器，那么需要为它指定bean定义的资源，也就是说bean定义文件时通过抽象成Resource来被IoC容器处理的，容器通过BeanDefinitionReader来完成定义信息的解析和Bean信息的注册，往往使用的是XmlBeanDefinitionReader来解析bean的xml定义文件，实际的处理过程是委托给BeanDefinitionParserDelegate来完成的，从而得到bean的定义信息，这些信息在Spring中使用BeanDefinition对象来表示，这个名字可以联想到loadBeanDefinition，RegisterBeanDefinition这些相关方法。都是为处理BeanDefinition服务的，容器解析得到BeanDefinition IoC以后，需要把它在IoC容器中注册，这由IoC实现BeanDefinitionRegistry接口来实现。注册过程就是在IoC容器内部维护一个HashMap来保存得到BeanDefinnition的过程。这个HashMap是IoC容器持有bean信息的场所，以后对bean的操作都是围绕这个HashMap来实现的</p>
</blockquote>
</li>
<li><p>然后就可以通过BeanFactory和ApplicationContext来享受Spring IoC的服务了。在使用IoC容器的时候，除了少量的粘合代码，绝大多数以正确IoC风格标写的应用程序代码完全不用关心如何到达工厂，因为容器将把这些对象与容器管理的其他对象钩在一起。基本的策略是把工厂放到已知的地方，最好是放在对预期使用的上下文有意义的地方，以及代码将实际需要访问工厂的地方。Spring本身提供了对声明式载入web应用程序用法的应用程序上下文，并将其存储在ServletContext中的框架实现。</p>
</li>
</ul>
<p><strong>在使用SpringIoC容器的时候还需要区别两个概念</strong></p>
<ul>
<li>BeanFactory<ul>
<li>IoC容器的编程抽象<ul>
<li>比如ApplicationContext、XmlBeanFactory等，这些都是容器的具体表现，需要使用什么的容器由用户决定，但Spring提供了丰富的选择。</li>
</ul>
</li>
</ul>
</li>
<li>FactoryBean<ul>
<li>只是一个可以在IoC容器中被管理的一个bean，是对各种处理裹层和资源使用的抽象，而不返回FactoryBean本身，可以把它堪称是一个抽象工厂，对它的调用返回的是工厂生产的产品，当使用容器中的FactoryBean的时候，该容器不会返回FactoryBean本身，而是返回其生成的对象。Spring包括了大部分的通用资源和服务访问抽象的FactoryBean的实现（下方列出），这些都可以看成是具体的工厂，堪称是Spring建立好的工厂。也就是说Spring通过使用抽象工厂模式准备了一系列工厂来生产一些特定的对象，免除手工重复的工作，要使用时只需要在IoC容器里配置好就能很方便的使用了<ul>
<li>对JNDI查询的处理</li>
<li>对代理对象的处理</li>
<li>对事务性代理的处理</li>
<li>对RMI代理的处理</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、IoC容器的依赖注入"><a href="#四、IoC容器的依赖注入" class="headerlink" title="四、IoC容器的依赖注入"></a>四、IoC容器的依赖注入</h3><p><strong>依赖注入发生的时间</strong><br>当Spring IoC容器完成了Bean定义资源的定位、载入和解析注册以后，IoC容器中已经管理类Bean定义的相关数据，但是此时IoC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况发生：</p>
<ul>
<li>用户第一次通过getBean方法向IoC容器获取Bean时，IoC容器触发依赖注入</li>
<li>当用户在Bean定义资源中为<bean>元素配置了lazy-init属性，即让容器在解析注册Beean定义时进行预实例化，触发依赖注入。<blockquote>
<p>BeanFactory接口定义了Spring IoC容器的基本功能规范。BeanFactory接口定义了几个getBean方法，就是用户向IoC容器索取管理的Bean的方法。具体实现在AbstractBeanFactory中。</p>
</blockquote>
</bean></li>
</ul>
<p><strong>AbstractBeanFactory通过getBean向IoC容器获取被管理的Bean</strong></p>
<ul>
<li>AbstractBeanFactory—doGetBean</li>
</ul>
<p>根据Bean定义方式不同，采取不同的创建Bean实例对象的策略</p>
<ul>
<li>单例(Singleton)<ul>
<li>则容器在创建之前先从缓存中查找<ul>
<li>确保整个容器中只存在一个实例对象</li>
</ul>
</li>
</ul>
</li>
<li>原型(Prototype)<ul>
<li>则容器每次都会创建一个新的实例对象</li>
</ul>
</li>
<li>其他<ul>
<li>扩展为指定其生命周期范围</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体的Bean实例对象的创建过程由实现了ObjectFactory接口的匿名内部类的createBean方法完成。ObjectFactory使用了委派模式，具体的Bean实例创建过程交由其实现类AbstractAutowireCapableBeanFactory完成。</p>
</blockquote>
<p><strong>AbstractAutowireCapableBeanFactory创建Bean实例对象</strong></p>
<p>AbstractAutowireCapableBeanFactory类实现了ObjectFactoryj接口，创建容器指定的的Bean实例对象，同时还对创建的Bean实例对象进行初始化处理。</p>
<ul>
<li>AbstractAutowireCapableBeanFactory—createBean<br>具体的依赖注入实现在：</li>
<li>.createBeanInstance<ul>
<li>生成Bean所包含的java实例对象</li>
</ul>
</li>
<li>.populateBean<ul>
<li>对Bean属性的依赖注入进行管理</li>
</ul>
</li>
</ul>
<p><strong>createBeanInstance方法创建Bean的java实例对象</strong></p>
<p>容器初始化生成Bean所包含的Java实例对象</p>
<ul>
<li>AbstractAutowireCapableBeanFactory—createBeanInstance</li>
<li>对使用工厂方法和自动装配特性的Bean的实例化比较清除，调用相应的工厂方法或者参数匹配的构造方法即可完成实例化对象的工作，但是对于最常使用的默认无参构造方法就需要使用相应的初始化策略(JDK的反射机制或者CGLIB)来进行初始化了，在方法getInstantiationStrategy().instantiate中就具体实现类使用初始策略实例化对象。</li>
</ul>
<p><strong>SimpleInstantiationStrategy 类使用默认的无参构造方法创建 Bean 实例化对象</strong></p>
<p>容器初始化生成Bean所包含的Java实例对象</p>
<ul>
<li>SimpleInstantiationStrategy—instantiate</li>
<li>Bean的方法是否被覆盖<ul>
<li>被覆盖<ul>
<li>使用JDK的反射机制进行实例化</li>
</ul>
</li>
<li>无<ul>
<li>CGLIB进行实例化</li>
</ul>
</li>
</ul>
</li>
<li>CGLIB是一个常用的字节码生成器的类库，它提供了一系列API实现java字节码的生成和转换功能。JDK的动态代理只能针对接口，如果一个类没有实现任何接口，要对其进行动态代理只能使用CGLIB.</li>
</ul>
<p><strong>populateBean方法对Bean属性的依赖注入</strong></p>
<p>生成对象后，Spring IoC容器是如何将Bean的属性依赖关系注入Bean实例对象中并设置好。</p>
<ul>
<li>AbstractAutowireCapableBeanFactory—populateBean</li>
<li>AbstractAutowireCapableBeanFactory—applyPropertyValues</li>
<li>对属性的注入过程分以下两种情况<ul>
<li>属性值不需要类型转换时，不需要解析属性值，直接准备进行依赖注入</li>
<li>属性值需要进行类型转换时，如对其他对象的引用等<ul>
<li>首先需要解析属性值</li>
<li>然后对解析后的属性值进行依赖注入<br>对属性值的解析是在BeanDefinitionValueResolver类的resolveValueIfNecessary方法中进行的，对属性值的依赖注入是通过bw.setPropertyValues方法实现的，在分析属性值的依赖注入之前，分析以下对属性值的解析过程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BeanDefinitionValueResolver解析属性值</strong></p>
<blockquote>
<p>当容器在对属性进行依赖注入时，如果发现属性值需要进行类型转换，如属性值是容器中另一个Bean实例对象的引用，则容器首先需要根据属性值解析出所医用的对象，然后才能将该引用对象注入到目标实例对象的属性上去，对属性进行解析的由resolveValueIfNecessary方法实现</p>
</blockquote>
<ul>
<li>BeanDefinitionValueResolver—resolveValueIfNecessary</li>
<li>BeanDefinitionValueResolver—resolveReference</li>
<li>BeanDefinitionValueResolver—resolveManagedArray</li>
<li>BeanDefinitionValueResolver—resolveManagedList</li>
<li>BeanDefinitionValueResolver—resolveManagedSet</li>
<li>BeanDefinitionValueResolver—resolveManagedMap<blockquote>
<p>通过上面的代码分析，明白了Spring是如何将引用类型，内部类以及集合类型等属性进行解析的，属性值解析完成后就可以进行依赖注入了，依赖注入的过程就是Bean对象实例设置到它所依赖的Bean对象舒心上去，依赖注入是通过bw.setPropertyValues方法实现的，该方法也使用了委托模式，在BeanWrapper接口中至少定义了方法声明，依赖注入的具体实现交由其实现类BeanWrapperImpl来完成。</p>
</blockquote>
</li>
</ul>
<p><strong>BeanWrapperImpl对Bean属性的依赖注入</strong></p>
<p>BeanWrapperImpl类主要是对容器中完成初始化的Bean实例对象进行属性的依赖注入，即把Bean对象设置到它所依赖的另一个Bean的属性中去。</p>
<ul>
<li>AbstractNestablePropertyAccessor—setPropertyValue</li>
<li>Spring IoC容器是如何将属性的值注入到Bean实例对象中<ul>
<li>集合类型的属性<ul>
<li>将其属性值解析为目标类型的集合后直接赋值给属性</li>
</ul>
</li>
<li>非集合类型的属性<ul>
<li>大量使用了JDk的反射和内省机制，通过属性的getter方法获取指定属性注入以前的值</li>
<li>调用属性的setter方法为属性设置注入后的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>至此Spring IoC容器对Bean定义资源文件的定位，载入、解析和依赖注入已经全部分析完毕，现在Spring IoC容器中管理了一系列靠依赖关系联系起来的Bean，程序不需要应用自己手动创建所需的对象，Spring IoC容器会在使用的时候自动创建，并且注入好相关的依赖，这就是Spring核心功能的控制反转和依赖注入的相关功能</p>
<h3 id="五、IoC容器的高级特性"><a href="#五、IoC容器的高级特性" class="headerlink" title="五、IoC容器的高级特性"></a>五、IoC容器的高级特性</h3><p><strong>介绍</strong></p>
<p>之前介绍了Spring Ioc容器对Bean资源的定位，读取和解析过程，同时也清楚了当用户通过getBean方向向IoC容器获取被管理的Bean时，IoC容器对Bean进行的初始化和依赖注入的过程，这些是Spring IoC容器的基本功能特性。</p>
<p>Spring IoC还有一些高级特性，如使用lazy-init属性对Bean预初始化、FactoryBean产生或者修饰Bean对象的生成、IoC容器初始化Bean过程中使用BeanPostProcessor后置处理器对Bean生命周期事件管理和IoC容器的autowiring自动装配功能等。</p>
<p><strong>Spring IoC容器的lazy-init属性实现预实例化</strong></p>
<blockquote>
<p>通过前面对IoC容器的实现和工作原理分析，知道了IoC容器的初始化过程就是对Bean定义资源的定位、载入和注册，此时容器对Bean的依赖注入并没有发生，依赖注入主要是在应用程序第一次向容器索取Bean时，通过getBean方法的调用完成。当Bean定义资源的 Bean元素中配置了lazy-init属性时，容器将会在初始化的时候对所配置的Bean进行预实例化，Bean的依赖注入在容器初始化的时候已经完成。这样，当应用程序第一次向容器索取被管理的Bean时，就不用再初始化和对Bean进行依赖注入了，直接从容器中获取已经完成依赖注入的现成的Bean，可以提高应用第一次向容器获取Bean的性能。</p>
<ul>
<li>refresh<ul>
<li>AbstractApplicationContext—refresh()</li>
<li>先从IoC容器的初始化过程开始，通过之前的分析，知道IoC容器读入已经定位的Bean定义资源是从refresh方法开始的。</li>
</ul>
</li>
<li>finishBeanFactoryInitialization处理预实例化Bean<ul>
<li>AbstractApplicationContext—finishBeanFactoryInitialization</li>
</ul>
</li>
<li>DefaultListableBeanFactory 对配置 lazy-init 属性单态 Bean 的预实例化<ul>
<li>DefaultListableBeanFactory—preInstantiateSingletons</li>
<li>如果设置了lazy-init属性，则容器在完成Bean定义的注册之后，会通过getBean方法，触发对指定Bean的初始化和依赖注入过程，这样当应用第一次向容器索取所需的Bean时，ring 起不再需要对Bean进行初始化和依赖注入，直接从已经完成实例化和依赖注入的Bean中取一个现成的Bean，这样就提高了第一次获取Bean的性能。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>FactoryBean的实现</strong></p>
<ul>
<li>背景知识<ul>
<li>BeanFactory<ul>
<li>Bean工厂，是一个工厂</li>
<li>Spring IoC容器的最顶层接口</li>
<li>管理Bean<ul>
<li>实例化、定位、配置应用程序中的对象及建立这些对象见的依赖</li>
</ul>
</li>
</ul>
</li>
<li>FactoryBean<ul>
<li>工厂Bean，是一个Bean</li>
<li>产生其他Bean实例</li>
<li>通常情况下，这种bean没有什么特别的要求，仅需要提供一个工厂方法，该方法用来返回其他bean实例</li>
<li>通常情况下，bean无需自己实现工厂模式，Spring容器担任工厂角色</li>
<li>少数情况下，容器中的bean本身就是工厂，其作用是产生其他bean实例<br>当用户使用容器本身时，可以使用转义字符“&amp;”来得到Factory本身，以区别通过FactoryBean产生的实例对象和FactoryBean对象本身。<br>如果myJndiObject是一个FactoryBean，使用&amp;myJndiObject得到的是myJndiObject对象，而不是myJndiObject产生出来的对象。 </li>
</ul>
</li>
</ul>
</li>
<li>FactoryBean</li>
<li>AbstractBeanFactory—doGetBean<ul>
<li>调用FactoryBean            </li>
<li>AbstractBeanFactory—getObjectForBeanInstance<ul>
<li>Dereference（解引用）</li>
<li>在C/C++中应用比较多的术语，”*”是解引用符号，而”&amp;”是引用符号</li>
<li>解引用是指变量指向的是所引用对象的本身数据，而不是引用对象的内存地址</li>
</ul>
</li>
</ul>
</li>
<li>AbstractBeanFactory生产Bean实例对象<ul>
<li>FactoryBeanRegistrySupport—getObjectFromFactoryBean</li>
<li>FactoryBeanRegistrySupport—doGetObjectFromFactoryBean<br>   BeanFactory接口调用其实现类的getObject方法来实现创建Bean实例对象的功能    </li>
</ul>
</li>
<li>工厂Bean的实现类getObject方法创建Bean实例对象<ul>
<li>FactoryBean的实现类非常多<ul>
<li>Proxy</li>
<li>RMI</li>
<li>JNDI</li>
<li>ServletContextFactoryBean</li>
<li>…</li>
</ul>
</li>
<li>FactoryBean接口为Spring容器提供了一个很好的封装机制，具体的getObject有不同的实现类根据不同的实现政策来具体技工，分析一个最简单的AnnotationTestBeanFactory<ul>
<li>AnnotationTestBeanFactory</li>
<li>其他的Proxy、RMI、JNDI等等，都是根据相应的策略提供getObject的实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>BeanPostProcessor后置处理器的实现</strong></p>
<blockquote>
<p>BeanPostProcessor后置处理器是Spring IoC容器经常使用到的一个特性，这个Bean后置处理器是一个监听器，可以监听容器触发的Bean生命周期事件。后置处理器向容器注册以后，容器中管理的Bean就具备了接收IoC容器事件回调的能力。</p>
<p>BeanPostProcessor的使用非常简单，只需要提供一个实现接口BeanPostProcessor的实现类，然后在Bean的配置文件中设置即可。</p>
</blockquote>
<ul>
<li>BeanPostProcessor<ul>
<li>这两个回调的入口都是和容器管理的Bean的生命周期事件紧密相关，可以为用户提供在Spring IoC容器初始化Bean过程中自定义的处理操作</li>
</ul>
</li>
<li>AbstractAutowireCapableBeanFactory类对容器生成的Bean添加后置处理器<ul>
<li>AbstractAutowireCapableBeanFactory—doCreateBean<ul>
<li>BeanPostProcessor后置处理器的调用发生在Spring IoC容器完成对Bean实例对象的创建和属性的依赖注入完成之后，当应用程序第一次调用getBean方法（lazy-init预实例化除外）向Spring IoC容器索取指定Bean时触发Spring IoC容器创建Bean实例对象并进行依赖注入的过程，其中真正实现创建Bean对象并进行依赖注入的方法是AbstractAutowireCapableBeanFactory类的doCreateBean</li>
</ul>
</li>
</ul>
</li>
<li>AbstractAutowireCapableBeanFactory—initializeBean<ul>
<li>为容器产生的Bean实例对象添加BeanPostProcessor后置处理器的入口</li>
<li>AbstractAutowireCapableBeanFactory—applyBeanPostProcessorsAfterInitialization<ul>
<li>BeanPostProcessor是一个接口，其初始化前的操作方法和初始化后的操作放啊均委托其实现子类来实现<ul>
<li>AOP面向切面编程的注册通知适配器</li>
<li>Bean对象的数据校验</li>
<li>Bean继承属性/方法的合并</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>AdvisorAdapterRegistrationManager <ul>
<li>其他的BeanPostProcessor接口实现类也类似，都是对Bean对象使用到的一些特性进行处理，或者向IoC容器中注册，为创建的Bean实例对象做一些自定义的功能增加，这些操作是容器初始化Bean时自动触发的，不需要人为的干预</li>
</ul>
</li>
</ul>
<p><strong>Spring IoC容器autowiring实现原理</strong></p>
<ul>
<li>Spring IoC容器提供了两种管理Bean依赖关系的方式<ul>
<li>显式管理<ul>
<li>通过BeanDefinition的属性值和构造方法实现Bean依赖关系管理</li>
</ul>
</li>
<li>autowiring<ul>
<li>Spring IoC容器的依赖自动装配功能，不需要对Bean属性的依赖关系做显式的声明，只需要在配置好autowiring属性，IoC容器会自动使用反射查找属性的类型和名称，然后基于属性的类型或者名称来自动装配容器中管理的Bean，从而自动的完成依赖注入</li>
</ul>
</li>
</ul>
</li>
<li>AbstractAutoWireCapableBeanFactory对Bean实例进行属性依赖注入<ul>
<li>AbstractAutoWireCapableBeanFactory—populateBean</li>
</ul>
</li>
<li>Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入<ul>
<li>AbstractAutoWireCapableBeanFactory—autowireByName</li>
<li>AbstractAutoWireCapableBeanFactory—autowireByType</li>
<li>可以看出来通过属性名进行自动依赖注入的相对比通过属性类型进行自动依赖注入要稍微简单一些，但是真正实现属性注入的是DefaultSingletonBeanRegistry类的registerDependentBean</li>
</ul>
</li>
<li>DefaultSingletonBeanRegistry的registerDependentBean方法对属性注入<ul>
<li>DefaultSingletonBeanRegistry—registerDependentBean</li>
</ul>
</li>
</ul>
<p>通过对autowire的源码分析，可以看出，autowire的实现过程：</p>
<ul>
<li>对Bean的属性调用getBean方法，完成依赖Bean的初始化和依赖注入</li>
<li>将依赖Bean的属性引用设置到被依赖的Bean上</li>
<li>将依赖Bean的名称和被依赖Bean的名称存储在IoC容器的集合中</li>
</ul>
<p>Spring IoC容器的autowire属性自动依赖注入是一个很方便的特性，可以简化开发时的配置，但也存在不足：</p>
<ul>
<li>Bean的依赖关系在配置文件中无法很清楚的看出来，对于维护造成一定困难</li>
<li><p>由于自动依赖注入是Spring容器自动执行的，容器是不会智能判断的，如果配置不当，将带来无法预料的后果，所以自动依赖注入特性在使用时还是综合考虑</p>
<p>  ​    </p>
</li>
</ul>
<h3 id="六、Spring-AOP设计原理及具体实践"><a href="#六、Spring-AOP设计原理及具体实践" class="headerlink" title="六、Spring AOP设计原理及具体实践"></a>六、Spring AOP设计原理及具体实践</h3><p><strong>SpringAOP应用示例</strong></p>
<ul>
<li><p>AOP(Aspect Oriented Programming)面向切面编程</p>
<ul>
<li>可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术</li>
<li>AOP设计模式追求的是调用者和被调用者之间的解耦</li>
</ul>
</li>
<li><p>相关概念</p>
<ul>
<li>Aspect切面<ul>
<li>官方的抽象定义为“一个关注点的模块化，这个关注点可能会横切多个对象”</li>
<li>“切面“在ApplicationContext中<aop:aspect>来配置</aop:aspect></li>
</ul>
</li>
<li>Joinpoint连接点<ul>
<li>程序执行过程中的某一行为<ul>
<li>某个方法的调用</li>
<li>某个方法抛出异常等行为</li>
</ul>
</li>
</ul>
</li>
<li>Advice通知<ul>
<li>“切面”对于某个“连接点”所产生的动作</li>
<li>一个“切面”可以包含多个“Advice”</li>
</ul>
</li>
<li>Pointcut切入点<ul>
<li>匹配连接点的断言</li>
<li>在AOP中通知和一个切入点表达式关联</li>
<li>切面中的所有通知所关注的连接点，都由切入点表达式来决定</li>
</ul>
</li>
<li>Target Object目标对象<ul>
<li>被一个或多个切面所通知的对象</li>
<li>在实际运行时，Spring AOP采用代理实现，实际AOP操作的是TargetObject的代理对象</li>
</ul>
</li>
<li>AOP Proxy AOP代理<ul>
<li>在Spring AOP中由两种代理方式<ul>
<li>JDK动态代理</li>
<li>CGLIB代理</li>
</ul>
</li>
<li>默认情况下，TargetObject实现了接口时，则采用JDK动态代理，反之，采用CGLIB代理</li>
<li>强制使用CGLIB大力需要将<aop:config>的proxy-target-class属性设置为true</aop:config></li>
</ul>
</li>
</ul>
</li>
<li><p>Advice通知 类型</p>
<ul>
<li>Before advice 前置通知<ul>
<li>在某连接点JointPoint之前执行的通知，但这个通知不能阻止连接点前的执行</li>
<li>ApplicationContext中在<aop:aspect>里面使用<aop:before></aop:before></aop:aspect></li>
</ul>
</li>
<li>After advice 后置通知<ul>
<li>在某连接点退出的时候执行的通知(不论是正常返回还是异常退出)</li>
<li>ApplicationContext中在<aop:aspect>里面使用<aop:after></aop:after></aop:aspect></li>
</ul>
</li>
<li>After return advice 返回后通知<ul>
<li>在某连接点正常完成后执行的通知，不包括抛出异常的情况</li>
<li>ApplicationContext中在<aop:aspect>里面使用<after-returning></after-returning></aop:aspect></li>
</ul>
</li>
<li>Around advice环绕通知<ul>
<li>包围一个连接点的通知</li>
<li>类似Web中Servlet规范中的Filter的doFilter方法</li>
<li>可以在方法的调用前后完成自定义的行为，也可以选择不执行</li>
<li>ApplicationContext中在<aop:aspect>里面使用<aop:around></aop:around></aop:aspect></li>
</ul>
</li>
<li>After throwing advice 抛出异常后通知<ul>
<li>在方法抛出异常退出时执行的通知</li>
<li>ApplicationContext中在<aop:aspect>里面使用<aop:after-throwing><br>注：可以将多个通知应用到一个目标对象上，即可以将多个切面织入到同一目标对象</aop:after-throwing></aop:aspect></li>
</ul>
</li>
</ul>
</li>
<li><p>使用Spring AOP</p>
<ul>
<li>注解<ul>
<li>XML文件中声明激活自动扫描组件功能，同时激活自动代理功能（来测试AOP的注解功能）</li>
<li>为Aspect切面类添加注解</li>
</ul>
</li>
<li>XML</li>
</ul>
</li>
<li><p>Srping AOP难点</p>
<ul>
<li>理解AOP的理念和相关概念</li>
<li>灵活掌握和使用切入点表达式</li>
</ul>
</li>
<li><p>execution</p>
<ul>
<li>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?<ul>
<li>modifiers-pattenr<ul>
<li>方法的操作权限</li>
</ul>
</li>
<li>ret-type-pattern<ul>
<li>返回值</li>
<li>必选</li>
</ul>
</li>
<li>declaring-type-pattern<ul>
<li>方法所在的包</li>
</ul>
</li>
<li>name-pattern<ul>
<li>方法名</li>
<li>必选</li>
</ul>
</li>
<li>parm-pattern<ul>
<li>参数名</li>
</ul>
</li>
<li>throws-pattern<br>  异常</li>
</ul>
</li>
</ul>
</li>
<li><p>访问当前的连接点</p>
<ul>
<li>每个通知方法第一个参数都是JoinPoint。其实，在Spring中，任何通知方法都可以将第一个参数定义为org.aspect.lang.JoinPoint类型用以接受当前连接点对象。</li>
<li>JoinPoint接口提供了一系列有用的方法<ul>
<li>getArgs()<ul>
<li>返回方法参数</li>
</ul>
</li>
<li>getThis()<ul>
<li>返回代理对象</li>
</ul>
</li>
<li>getTarget()<ul>
<li>返回目标</li>
</ul>
</li>
<li>getSignature()<ul>
<li>返回正在被通知的方法相关信息</li>
</ul>
</li>
<li>toString()<ul>
<li>打印出正在被通知的方法的有用信息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>SpringAOP设计原理及源码分析</strong></p>
<ul>
<li><p>Spring生成代理对象</p>
<ul>
<li>JDkProxy(如果是接口)</li>
<li>Cglib(不是接口)<br>具体使用哪种方式由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDkProxy，否则使用Cglib。</li>
</ul>
</li>
<li><p>织入代理对象<br>InvocationHandler是JDk动态代理的核心，生成的代理对象的方法调用都会委托到InvocationHandler.invoke()方法而通过JdkDynamicAopProxy的签名可以看到这个类其实也实现了InvocationHandler</p>
<pre><code>* JdkDynamicAopProxy---invoke
    * 主入口
* AdvisedSupport---getInterceptorsAndDynamicInterceptionAdvice
    * 获取通知链
* AdvisorChainFactory---getInterceptorsAndDynamicInterceptionAdvice
    * 获取通知链
* DefaultAdvisorChainFactory---getInterceptorsAndDynamicInterceptionAdvice
    * 获取通知链实现
* ReflectiveMethodInvocation---proceed()
    * 触发拦截器链执行
</code></pre></li>
</ul>
<h3 id="七、Spring-JDBC设计原理及二次开发"><a href="#七、Spring-JDBC设计原理及二次开发" class="headerlink" title="七、Spring JDBC设计原理及二次开发"></a>七、Spring JDBC设计原理及二次开发</h3><ul>
<li>使用Spring进行基本的JDBC访问数据库有多种选择<ul>
<li>JdbcTmplate<ul>
<li>经典的也是最常用的Spring对于JDBC访问的方案</li>
<li>最低级别的封装</li>
<li>其他的工作模式底层的实现基础</li>
<li>JDK1.4以上</li>
<li>NamedParameterJdbcTemplate<ul>
<li>封装JdbcTemplate</li>
<li>提供了更加编辑的基于命名参数的使用方式而不是传统的JDBC所使用的?作为参数的占位符</li>
</ul>
</li>
</ul>
</li>
<li>Spring2.5中新提供的SimpleJdbc类能够更好的处理数据库元数据<ul>
<li>SimpleJdbcTemplate<ul>
<li>结合了JdbcTemplate和NamedParameterJdbcTemplate最常用的功能</li>
<li>利用了Java5的特性所带来的优势<ul>
<li>泛型</li>
<li>varargs</li>
<li>autoboxing</li>
</ul>
</li>
</ul>
</li>
<li>SimpleJdbcInsert &amp; SimpleJdbcCall<ul>
<li>这两个类可以充分利用数据库元数据的特性来简化配置</li>
<li>可以仅仅提供数据库表明或者存储过程的名称以及一个Map作为参数<ul>
<li>Map的key需要与数据库表中的字段保持一致</li>
</ul>
</li>
<li>通常和SimpleJdbcTemplate配合使用</li>
<li>JDK5</li>
<li>需要数据库提供足够的元数据信息</li>
</ul>
</li>
</ul>
</li>
<li>RDBMS Object风格的面向对象封装方式，类似于JDo的查询设计<ul>
<li>MappingSqlQuery</li>
<li>SqlUpdate and StoreProcedure</li>
<li>这种方式允许在初始化数据访问层时创建可重用并且线程安全的对象<ul>
<li>该对象在定义了查询语句，声明查询参数并编译相应的Query之后被模型化</li>
<li>一旦模型化完成，任何执行函数就可以掺入不同的参数进行多次调用</li>
</ul>
</li>
<li>JDK4<br>所有的工作模式都必须邀请JDBC2.0以上的数据库驱动的支持，其中一些高级的功能可能需要JDBC3.0以上的数据库驱动支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>异常处理</strong></p>
<ul>
<li><p>SQLExceptionTranslator</p>
<ul>
<li>接口</li>
<li>在SQLException和org.springframework.dao.DataAccessException之间作转换，必须实现该接口</li>
<li>转换器类的实现可以采用一般通用的做法<ul>
<li>JDBC—SQLState code</li>
<li>定制(精准)<ul>
<li>Oracle—error code</li>
</ul>
</li>
</ul>
</li>
<li>默认实现为SQLErrorCodeSQLExceptionTranslator<ul>
<li>使用指定数据库厂商的error code，比SQLState梗精准</li>
<li>转换过程基于一个JavaBean（类型为SQLErrorCodes）中的error code<ul>
<li>JavaBean由SQLErrorCodesFactory工厂类创建<ul>
<li>其中的内容来自于”sql-error-codes.xml”配置文件</li>
<li>该文件中的数据库厂商代码基于Database MetaData信息中的DatabaseProductName，从而配合当前数据库的使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SQLErrorCodeSQLExceptionTranslator匹配规则</p>
<ul>
<li>首先检查是否存在完成定制转换的子类实现<ul>
<li>通常此类可以作为一个具体类使用，不需要进行定制，那么这个规则将不适用</li>
</ul>
</li>
<li>接着将SQLException的error code与错误代码集中的error code进行匹配<ul>
<li>默认情况下错误代码集将从SQLErrorCodesFactory取得</li>
<li>错误代码集来自classpath下的sql-error-codes.xml文件</li>
<li>他们将与数据库metadata信息中的database name进行映射，使用fallback翻译器<ul>
<li>SQLStateSQLExceptionTranslator类是缺省的fallback翻译器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>config模块</strong></p>
<ul>
<li>NamespaceHandler接口<ul>
<li>DefalutBeanDefinitionDocumentReader使用该接口来处理在spring.xml配置文件中自定义的命名空间</li>
<li>在jdbc模块，使用JdbcNamespaceHandler来处理jdbc配置的命名空间 </li>
</ul>
</li>
<li>org.w3c.dom软件包(JdbcNamespaceHandler引用）<pre><code>* 为文档对象模型(DOM)提供接口
* 该模型是Java API for XMl Processing的组件API
* 该Document Object Model Level 2 Core API允许程序动态访问和更新文档的内容和结构
* 包下的类
    * 自行查阅相关文档
</code></pre></li>
</ul>
<p><strong>core模块</strong></p>
<ul>
<li><p>JdbcTemplate</p>
<ul>
<li>core包的核心类</li>
<li>完成了资源的创建以及释放工作，从而简化了JDBC的使用</li>
<li>避免一些常见的错误(忘记关闭数据库连接)</li>
<li>完成JDBC核心处理流程<ul>
<li>SQL语句的创建、执行，而把SQL语句的生成以及查询结果的提取工作留给应用代码</li>
<li>完成SQl查询、更新以及调用存储过程，可以对ResultSet进行遍历并加以提取</li>
<li>捕获JDBC异常并将其转换为org.springframework.dao包中定义的通用、信息丰富的异常</li>
</ul>
</li>
<li>使用JdbcTemplate进行编码只需要根据明确定义的一组契约来实现回调接口<ul>
<li>PreparedStatementCreator回调接口通过给定的Connection创建一个PreparedStatement，包含SQL和任何相关的参数</li>
<li>CallableStatementCreator实现同样的处理，创建CallableStatement</li>
<li>RowCallbackHandler接口则从数据集的每一行中提取值</li>
</ul>
</li>
<li>实例化<ul>
<li>DAO实现类中通过传递一个DataSource引用来完成<ul>
<li>DataSource bean将传递给service</li>
</ul>
</li>
<li>在Spring的IoC容器中配置一个JdbcTemplate的bean并赋予DAO实现类作为一个实例<ul>
<li>DataSource bean将传递给JdbcTemplate bean</li>
<li>需要注意的是DataSource在Spring的IoC容器中总是配置成一个bean</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>元数据metaData</p>
<ul>
<li>CallMetaDataProviderFactory创建 CallMetaDataProvider 的工厂类</li>
<li>TableMetaDataProviderFactory 创建 TableMetaDataProvider 工厂类</li>
</ul>
</li>
<li>使用SqlParameterSource提供参数值<ul>
<li>BeanPropertySqlParameterSource</li>
</ul>
</li>
<li><p>DataSource</p>
<ul>
<li>获取数据库的连接</li>
<li>jdbc规范的一部分，通过ConnectionFactory获取</li>
<li>当使用Spring的jdbc层，可以通过JNDI来获取DataSource，也可以配置第三方连接池实现来获取<ul>
<li>第三方实现<ul>
<li>apache Jakarta Commons dbcp</li>
<li>c3p0</li>
</ul>
</li>
</ul>
</li>
<li>TransactionAwareDataSourceProxy<ul>
<li>作为目标DataSource的一个代理，在对目标DataSource包装的同时，还增加了Spring的事务管理能力</li>
<li>该类几乎很少被用到，除非现有代码在被调用的时候需要一个标准的JDBC DataSource接口实现作为参数。在这种情况下，这个类可以使现有代码参与Spring的事务管理。通常最好的做法是使用更高层的抽象来对数据源进行管理，比如JdbcTemplate和DataSourceUtils等</li>
</ul>
</li>
</ul>
</li>
<li><p>Object 模块</p>
</li>
</ul>
<h3 id="八、Spring-MVC框架设计原理"><a href="#八、Spring-MVC框架设计原理" class="headerlink" title="八、Spring MVC框架设计原理"></a>八、Spring MVC框架设计原理</h3><p><strong>DispatcherServlet</strong></p>
<ul>
<li>是 springmvc 中的前端控制器(front controller),负责接收 request 并将 request 转发给对应的处理组件.</li>
<li>扩展了同一个包中的抽象类FrameworkServlet,包含一些解析器的私有静态字段<ul>
<li>用于本地化、视图、异常或上传文件</li>
<li>映射处理器HandlerMapping<ul>
<li>是springmvc中完成url到controller映射的组件.DispatcherServlet接收request, 然后从HandlerMapping查找处理request的controller</li>
</ul>
</li>
<li>处理适配器hanlderAdapter</li>
</ul>
</li>
<li>为web应用程序提供了一个中心入口点。该集中入口点将系统组件的共同特征进行重新组合。可以在那里找到安全资源、语言切换、会话管理、缓存或输入过滤的处理程序。<ul>
<li>好处是共同的入口点有助于避免代码重复</li>
</ul>
</li>
<li>对以下询问做出最佳响应<ul>
<li>如何集中授权和认证</li>
<li>如何处理正确的视图渲染</li>
<li>如何使用URL重写映射将请求发送到适当的控制器</li>
</ul>
</li>
<li>这个前台控制器模式包含的参与者<ul>
<li>客户端：发送请求</li>
<li>控制器：应用程序的中心点，捕获所有请求<ul>
<li>Controller<ul>
<li>处理 request,并返回 ModelAndView 对象,Controller 是 springmvc 中负责处理 request 的组件(类似于 struts2 中的 Action),ModelAndView 是封装结果视图的组件.<br>  度员：管理视图的选择，以呈现给客户端            </li>
</ul>
</li>
</ul>
</li>
<li>视图：表示呈现给客户端的内容<ul>
<li>ModelAndView &amp; ViewResolver &amp; View<ul>
<li>视图解析器解析 ModelAndView 对象并返回对应的视图给客户端</li>
</ul>
</li>
</ul>
</li>
<li>帮助：帮助查看和/或控制器完成请求处理</li>
</ul>
</li>
<li>前端控制器模式有自己的执行链。这意味着它有自己的逻辑来处理请求并将视图返回给客户端<ul>
<li>请求由客户端发送。它到达作为Spring的默认前端控制器的DispatcherServlet类</li>
<li>DispatcherServlet使用请求处理程序映射来发现将分析请求的控制器(controller)。接口org.springframework.web.servlet.HandlerMappingd的实现返回一个包含 org.springframework.web.servlet.HandlerExecutionChain类的实例。此实例包含可在控制器调用之前或之后调用的处理器程序拦截器数组。<ul>
<li>如果在所有定义的处理程序映射中找不到HandlerExecutionChain,这意味着Spring无法将URL与对应的控制器进行匹配。这样的话会抛出一个错误</li>
</ul>
</li>
<li>现在系统进行拦截器预处理并调用由映射处理器找到的相应的controller(其实就是在找到controller之前进行一波拦截处理)。在controller处理请求后，DispatcherServlet开始拦截器的后置处理。在此步骤结束时，它从controller接收ModelAndView实例（整个过程其实就是request请求-&gt;进入interceptors-&gt;controller-&gt;从interceptors出来-&gt;ModelAndView接收）</li>
<li>DispatcherServlet现在将使用的该视图的名称发送到视图解析器。这个解析器将决定前台的展现内容。接着，它将此视图返回给DispatcherServlet，其实也就是一个“视图成成后可调用”的拦截器。</li>
<li>最后一个操作是视图的渲染并作为客户端request请求的响应</li>
</ul>
</li>
<li><p>执行步骤</p>
<ul>
<li>策略初始化<ul>
<li>核心点<ul>
<li>DispatcherServlet—initStrategies<ul>
<li>onRefresh()时调用</li>
<li>FrameworkServlet中initServletBean—initWebApplicationContext—onRefresh(wac)<ul>
<li>通过所提供的这些策略生成所需要的应用程序上下文，其每个策略都会产生一类在DispatcherServlet中用来处理传入请求的对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>请求预处理<ul>
<li>FrameworkServlet—processRequest</li>
</ul>
</li>
<li>请求处理<ul>
<li>DispatcherServlet—doService</li>
<li>DispatcherServlet—doDispatch</li>
</ul>
</li>
<li>视图解析<ul>
<li>DispatcherServlet—applyDefaultViewName</li>
</ul>
</li>
<li>处理调度请求-视图渲染<ul>
<li>DispatcherServlet—processDispatchResult</li>
<li>在这部分，需要记住的是定义了两个上下文<ul>
<li>用于应用程序<ul>
<li>应用程序上下文包含所有通用配置，比如service定义，数据库配置</li>
</ul>
</li>
<li>用于Web应用程序<ul>
<li>定义所有与Web相关的组件，比如controllers或视图解析器<br><strong>handler</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring中存在两种handler</p>
<ul>
<li><p>handler mappings处理程序映射</p>
<ul>
<li>它们的角色定位与前面所描述的功能完全相同</li>
<li>它们尝试当前请求与相应的controller以及其中的方法相匹配</li>
<li><p>最基本的org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping类</p>
<ul>
<li>将URL与相应的bean进行匹配<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean name=&quot;/friends&quot; class&quot;com.2bai.controller.FriendsController&quot; /&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>更灵活的处理映射器org.springframework.web.servlet.handler.SimpleUrlHandleMapping</p>
<ul>
<li><p>可以创建一个映射文件，其中包含URl作为键和controller作为值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;simpleUrlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandleMapping&quot;&gt;</div><div class="line">	&lt;property name=&quot;mappings&quot;&gt;</div><div class="line">		&lt;props&gt;</div><div class="line">			&lt;prop key=&quot;/friends.html&quot;&gt;FriendsControler&lt;/props&gt;</div><div class="line">		&lt;/props&gt;</div><div class="line">	&lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>处理稍微复杂URL也是一个头疼的问题</p>
</li>
</ul>
</li>
<li>DefaultAnnotationHandlerMapping或者在Spring5中使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping<ul>
<li>映射检测是基于注解<ul>
<li>@Controller</li>
<li>@RequestMapping</li>
</ul>
</li>
<li>配置文件中定义<mvc:annotation-driven>，此处理程序将被激活</mvc:annotation-driven></li>
<li>更细粒度的处理cotroller注解<ul>
<li><context:annotation-config></context:annotation-config></li>
<li><context:component-scan base-package="path.with.my.services.and.controllers"></context:component-scan></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>handler adapter处理器适配器<ul>
<li>handler adapter从handler mappings中获取映射的controllers和方法并调用它们。</li>
<li>这种类型的适配器必须实现org.springframework.web.servlet.HandlerAdapter接口，它只有三种方法<ul>
<li>supports方法：检查传入参数的对象是否可以由此适配器处理</li>
<li>handle方法：将请求翻译称视图</li>
<li>getLastModified：返回给定HttpServletRequest的最后修改日期，以毫秒为单位</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>版本变化</p>
<ul>
<li>3.2废弃,4.x里还可以看到，5已经废弃<ul>
<li>DefaultAnnotationHandlerMapping</li>
<li>AnnotationMethodHandlerAdapter</li>
<li>AnnotationMethodHandlerExceptionResolver</li>
</ul>
</li>
<li>替代品<ul>
<li>RequestMappingHandlerMapping</li>
<li>RequestMappingHandlerAdapter</li>
<li>ExceptionHandlerExceptionResolver</li>
</ul>
</li>
<li>通过这些新类以便于自定义映射。</li>
<li>通过在Spring3.1版本中org.framework.web.mehthod.HandlerMethod类中引入，来将所处理的对象转换为其方法表示。可以通过这个方法来判断对象返回的类型或者哪些参数是所期望的。</li>
</ul>
</li>
<li><p>处理程序拦截器</p>
<ul>
<li>HTTP请求的执行链<ul>
<li>DispatcherServlet捕获每个请求。调度员做的第一件事就是将接收到的URl和相应的controller进行映射。在到达对应的controller之前，请求可以被拦截器处理。这些拦截器就像过滤器。只有当URL找到对应于它们的映射时才调用他们。在通过拦截器进行前置处理后，请求最终到达哦controller。之后，发送请求生成视图。但是在这之前，拦截器还是有可能来再次处理它（拦截器后置处理）。只有在最后一次操作之后，视图解析器才能捕获数据并输出视图。</li>
</ul>
</li>
<li>处理程序映射拦截器基于org.springframework.web.servlet.HandlerInterceptor接口<ul>
<li>方法前使用preHandle<ul>
<li>返回false，则可以在执行链中执行终端请求处理</li>
<li>afterCompletion<ul>
<li>返回true时才会在渲染视图后调用它(完成请求处理后的回调，即渲染视图后)</li>
</ul>
</li>
</ul>
</li>
<li>方法后使用postHandle</li>
</ul>
</li>
<li>在新线程中启动<ul>
<li>实现org.framework.web.servlet.AsyncHandlerInterceptor接口，它结成HandlerInterceptor并提供一个方法afterConcurrentHandlingStarted<ul>
<li>每次处理程序得到正确执行时，都会调用此方法而不是调用postHandler()和afterCompletion().</li>
<li>它也可以对发送请求进行异步处理。</li>
</ul>
</li>
</ul>
</li>
<li>默认的Springl拦截器<ul>
<li>Spring主要将拦截器用于切换动作。<ul>
<li>区域设置更改<ul>
<li>org.springframework.web.servlet.i18n.LocalChangeInterceptor</li>
<li>可以通过所定义的语言环境解析器来对HTTP请求进行分析来实现</li>
<li>所有区域设置解析器都会分析请求元素(headers,Cookie)，以确定向用户提供哪种本地化语言设置</li>
</ul>
</li>
<li>更改视图的主题<ul>
<li>org.springframework.web.servlet.theme.ThemehangeInterceptor</li>
<li>也基于请求分析<ul>
<li>cookie</li>
<li>会话</li>
<li>参数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拦截器和过滤器之间的区别</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>过滤器</th>
<th>拦截器</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用域</td>
<td>servlet容器下使用</td>
<td>Spring容器中调用</td>
</tr>
<tr>
<td>粒度</td>
<td>只能在将响应返回给最终用户之前使用</td>
<td>在controller对请求处理之前或之后被调用,也可以在将渲染视图呈现给用户之后被调用</td>
</tr>
<tr>
<td>中断链执行的难易程度</td>
<td>必须处理请求和响应对象来引发中断,需要一些额外的动作，比如将用户重定向到错误页面</td>
<td>通过在preHandler方法那返回false来简单实现</td>
</tr>
</tbody>
</table>
<p><strong>工作机制</strong></p>
<p>在容器初始化时会创建所有url和controller的对应关系，保存到Map<url,controller>中<br>tomcat启动时会通知Spring初始化容器(加载bean的定义信息和初始化所有单例bean)<br>然后SpringMVC会遍历容器中的bean，获取每一个controller中的所有方法访问的url<br>然后将url和controller保存到一个map中。</url,controller></p>
<p>这样就可以根据request快速定位到controller,因为最终处理request的是controller中的方法,Map中只保留了url和controller中的对应关系,所以要根据request的 url进一步确认controller中的method, 这一步工作的原理就是拼接controller的url(controller 上@RequestMapping的值)和方法的url(method 上 @RequestMapping 的值),与request的url进行匹配,找到匹配的那个方法;</p>
<p>确定处理请求的method后,接下来的任务就是参数绑定,把request中参数绑定到方法的形式参数上, 这一步是整个请求处理过程中最复杂的一个步骤。springmvc 提供了两种 request参数与方法形参的绑定方法:1.通过注解进行绑定,@RequestParam；2.通过参数名称进行绑定.</p>
<p>使用注解进行绑定,我们只要在方法参数前面声明@RequestParam(“a”),就可以将request中参数a的值绑定到方法的该参数上.使用参数名称进行绑定的前提是必须要获取方法中参数的名称,Java反射只提供了获取方法的参数的类型,并没有提供获取参数名称的方法.springmvc解决这个问题的方法是用asm框架读取字节码文件,来获取方法的参数名称.asm框架是一个字节码操作框架,关于 asm 更多介绍可以参考它的官网.个人建议,使用注解来完成参数绑定,这样就可以省去asm框架的读取字节码的操作.</p>
<p><strong>源码分析</strong></p>
<ul>
<li><p>源码分析分为三部分</p>
<ul>
<li>ApplicationContext初始化时建立所有url和controller类的对应关系(用map保存)</li>
<li>根据请求url找到对应的controller，并从controller中找到处理请求的方法</li>
<li>request参数绑定到方法的形参，执行方法处理请求，并返回结果视图</li>
</ul>
</li>
<li><p>建立Map<urls,controller>的关系</urls,controller></p>
<ul>
<li>ApplicationObjectSupport—setApplicationContext<ul>
<li>核心为初始化容器initApplicationContext(context)<ul>
<li>子类AbstractDetectingUrlHandlerMapping实现了该方法<ul>
<li>BeanNameUrlHandlerMapping—determineUrlsForHandler<br>到这里HandlerMapping组件就建立起所有url和contrller的对应关系</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根据访问url找到对应controller中处理的方法<br>是由请求触发的，所以入口为DispatcherServlet的核心方法为doService(),doService()中的核心逻辑由doDispatch()实现的</p>
<ul>
<li>DispatcherServlet—doService</li>
<li>DispatcherServlet—doDispatch</li>
</ul>
</li>
<li><p>反射调用处理请求的方法，返回结果视图</p>
<ul>
<li>RequestMappingHandlerAdapter—invokeHandlerMethod</li>
</ul>
</li>
</ul>
<p><strong>SpringMVC优化</strong></p>
<ul>
<li>controller如果能保持单例，尽量使用单例模式<ul>
<li>这样就减少了创建对象和回收对象的开销<ul>
<li>也就是说，如果controller的类变量和实例变量可以以方法形参声明就尽量以方法的形参声明，不要以类变量和实例变量声明，这样可以避免线程安全问题</li>
</ul>
</li>
</ul>
</li>
<li>处理request的方法中的形参务必加上@RequestParam注解，这样可以避免SpringMVC使用asm框架读取class文件获取方法参数名的过程。即便SpringMVC对读取出的方法参数名进行了缓存，如果不要读取class文件当然是更加好</li>
<li>SpringMVC并没有对处理url的方法进行缓存，也就是说每次都要根据请求url去匹配controller中的方法url。如果把url和method的关系缓存起来，会不会带来性能上的提升呢？但是！负责解析url和method对应关系的ServletHandlerMethodResolver是一个private的内部类，不能直接继承该类增强代码，必须要改代码后重新编译。当然，如果缓存起来，必须要考虑缓存的线程安全问题。</li>
</ul>
<h3 id="九、Spring事务原理详解"><a href="#九、Spring事务原理详解" class="headerlink" title="九、Spring事务原理详解"></a>九、Spring事务原理详解</h3><p><strong>什么是事务Transaction</strong></p>
<ul>
<li>是访问并可能更新数据库中各种数据项的一个程序执行单元。</li>
<li>是恢复和并发控制的基本单元</li>
<li>属性ACID<ul>
<li>原子性atomicity<ul>
<li>一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li>
</ul>
</li>
<li>一致性consistency<ul>
<li>事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li>
</ul>
</li>
<li>隔离性isolation<ul>
<li>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</li>
</ul>
</li>
<li>持久性durability<ul>
<li>持久性也称永久性(permanence)，指一个事务一旦提交，它对数据库中数据 的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>事务的基本原理</strong></p>
<ul>
<li>Spring 事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring 是无法提供事务功能的。</li>
<li><p>纯JDBC操作数据库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.获取连接</span></div><div class="line">Connection con = DriverManager.getConnection()</div><div class="line"><span class="comment">//2. 开启事务</span></div><div class="line">con.setAutoCommit(<span class="keyword">true</span>/<span class="keyword">false</span>);</div><div class="line"><span class="comment">//3. 执行 CRUD</span></div><div class="line"><span class="comment">//4. 提交事务/回滚事务 </span></div><div class="line">con.commit() / con.rollback();</div><div class="line"><span class="comment">//5. 关闭连接 </span></div><div class="line">conn.close();</div></pre></td></tr></table></figure>
</li>
<li><p>使用Spring的事务管理功能后，我们可以不再写步骤2和4的代码，而是由Spirng自动完成。那么 Spring 是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢?解决这个问题，也就可以从整体上理解 Spring 的事务管理实现原理了。下面简单地介绍下，注解方式为例子:</p>
<ul>
<li><ol>
<li>配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional 标识。</li>
</ol>
</li>
<li><ol>
<li>spring 在启动的时候会去解析生成相关的 bean，这时候会查看拥有相关注解的类和方法，并且 为这些类和方法生成代理，并根据@Transaction 的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了(开启正常提交事务，异常回滚事务)。</li>
</ol>
</li>
<li><ol>
<li>真正的数据库层的事务提交和回滚是通过 binlog 或者 redo log 实现的。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>Spring事务的传播属性</strong></p>
<p>所谓 spring 事务的传播属性，就是定义在存在多个事务同时存在的时候，spring 应该如何处理这些事 务的行为。这些属性在 TransactionDefinition 中定义，具体常量的解释见下表</p>
<table>
<thead>
<tr>
<th>常量名称</th>
<th>常量解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PROPAGATION_REQUIRED</code></td>
<td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。</td>
</tr>
<tr>
<td><code>PROPAGATION_REQUIRES_NEW</code></td>
<td><code>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</code></td>
</tr>
<tr>
<td><code>PROPAGATION_SUPPORTS</code></td>
<td><code>支持当前事务，如果当前没有事务，就以非事务方式执行。</code></td>
</tr>
<tr>
<td><code>PROPAGATION_MANDATORY</code></td>
<td><code>支持当前事务，如果当前没有事务，就抛出异常。</code></td>
</tr>
<tr>
<td><code>PROPAGATION_NOT_SUPPORTED</code></td>
<td><code>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</code></td>
</tr>
<tr>
<td><code>PROPAGATION_NEVER</code></td>
<td><code>以非事务方式执行，如果当前存在事务，则抛出异常。</code></td>
</tr>
<tr>
<td><code>PROPAGATION_NESTED</code></td>
<td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按 REQUIRED 属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager 事务管理器起效。</td>
</tr>
</tbody>
</table>
<p><strong>数据库隔离级别</strong></p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>隔离级别的值</th>
<th>导致的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Read-Uncommitted</code></td>
<td>0</td>
<td>导致脏读</td>
</tr>
<tr>
<td><code>Read-Committed</code></td>
<td>1</td>
<td><code>避免脏读，允许不可重复读和幻读</code></td>
</tr>
<tr>
<td><code>Repeatable-Read</code></td>
<td>2</td>
<td><code>避免脏读，不可重复读，允许幻读</code></td>
</tr>
<tr>
<td><code>Serializable</code></td>
<td>3</td>
<td><code>串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</code></td>
</tr>
</tbody>
</table>
<ul>
<li>脏读<ul>
<li>一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这<br>时候回滚了，那么第二个事务就读到了脏数据。</li>
</ul>
</li>
<li>不可重复读<ul>
<li>一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进<br>行了修改，这时候两次读取的数据是不一致的。</li>
</ul>
</li>
<li>幻读<ul>
<li>第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一<br>个事务就会丢失对新增数据的修改。</li>
</ul>
</li>
</ul>
<blockquote>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。<br>大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle 少数数据库默认隔离级别为:Repeatable Read 比如: MySQL InnoDB</p>
</blockquote>
<p><strong>Spring中的隔离级别</strong></p>
<table>
<thead>
<tr>
<th>常量</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ISOLATION_DEFAULT</code></td>
<td>这 是 个 PlatfromTransactionManager 默 认 的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</td>
</tr>
<tr>
<td><code>ISOLATION_READ_UNCOMMITTED</code></td>
<td><code>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</code></td>
</tr>
<tr>
<td><code>ISOLATION_READ_COMMITTED</code></td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td>
</tr>
<tr>
<td><code>ISOLATION_REPEATABLE_READ</code></td>
<td><code>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</code></td>
</tr>
<tr>
<td><code>ISOLATION_SERIALIZABLE</code></td>
<td><code>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</code></td>
</tr>
</tbody>
</table>
<p><strong>事务的嵌套</strong></p>
<p>通过上面的理论知识的铺垫，我们大致知道了数据库事务和spring事务的一些属性和特点，接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。</p>
<p>假设外层事务 Service A 的 Method A() 调用 内层 Service B 的 Method B()</p>
<p><code>PROPAGATION_REQUIRED(spring 默认)</code></p>
<ul>
<li>如果 ServiceB.methodB() 的事务级别定义为 PROPAGATION_REQUIRED，那么执行 ServiceA.methodA() 的时候 spring 已经起了事务，这时调用 ServiceB.methodB()，ServiceB.methodB() 看到自己已经运 行在 ServiceA.methodA() 的事务内部，就不再起新的事务。</li>
<li>假如 ServiceB.methodB() 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>这样，在 ServiceA.methodA() 或者在 ServiceB.methodB() 内的任何地方出现异常，事务都会被回滚。</li>
</ul>
<p><code>PROPAGATION_REQUIRES_NEW</code></p>
<ul>
<li>比如我们设计ServiceA.methodA()的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB() 的事务级别为PROPAGATION_REQUIRES_NEW。<br>那么当执行到 ServiceB.methodB() 的时候，ServiceA.methodA() 所在的事务就会挂起， ServiceB.methodB() 会起一个新的事务，等待 ServiceB.methodB() 的事务完成以后，它才继续执行。</li>
<li>它与PROPAGATION_REQUIRED的事务区别在于事务的回滚程度了。因为 ServiceB.methodB() 是新起一个事务，那么就是存在两个不同的事务。<ul>
<li>如果 ServiceB.methodB() 已经提交，那么 ServiceA.methodA() 失败回滚，ServiceB.methodB() 是不会回滚的。</li>
<li>如果 ServiceB.methodB() 失败回滚，如果他抛出的 异常被 ServiceA.methodA() 捕获，ServiceA.methodA() 事务仍然可能提交(主要看 B 抛出的异常是不 是 A 会回滚的异常)。</li>
</ul>
</li>
</ul>
<p><code>PROPAGATION_SUPPORTS</code></p>
<ul>
<li>假设 ServiceB.methodB() 的事务级别为 PROPAGATION_SUPPORTS，那么当执行到 ServiceB.methodB() 时<ul>
<li>如果发现 ServiceA.methodA()已经开启了一个事务，则加入当前的事务</li>
<li>如果发现 ServiceA.methodA()没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。</li>
</ul>
</li>
</ul>
<p><code>PROPAGATION_NESTED</code></p>
<ul>
<li>现在的情况就变得比较复杂了, ServiceB.methodB() 的事务属性被配置为 PROPAGATION_NESTED, 此时 两者之间又将如何协作呢?<ul>
<li>ServiceB#methodB如果rollback,那么内部事务(即 ServiceB#methodB) 将回滚到它执行前的 SavePoint 而外部事务(即 ServiceA#methodA) 可以有以下 两种处理方式:<ul>
<li>捕获异常，执行异常分支逻辑<ul>
<li>这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 ServiceB.methodB 失败, 那么执行 ServiceC.methodC(), 而 ServiceB.methodB 已经回滚到它执行之前的 SavePoint, 所以不 会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都没有办法做到这一点。</li>
</ul>
</li>
<li>外部事务回滚/提交 代码不做任何修改, 那么如果内部事务(ServiceB#methodB) rollback, 那么 首先 ServiceB.methodB 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 ServiceA#methodA) 将根据具体的配置决定自己是 commit 还是 rollback</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>另外三种事务传播属性基本用不到，在此不做分析。</p>
<h3 id="十、Spring事务源码分析"><a href="#十、Spring事务源码分析" class="headerlink" title="十、Spring事务源码分析"></a>十、Spring事务源码分析</h3><ul>
<li>TransactionDefinition</li>
<li>PlatformTransactionManager<ul>
<li>DataSourceTransactionManager<ul>
<li>JDBC</li>
</ul>
</li>
<li>HibernateTransactionManager<ul>
<li>Hibernate</li>
</ul>
</li>
<li>JpaTransactionManager<ul>
<li>JPA</li>
</ul>
</li>
<li>JtaTransactionManager<ul>
<li>JTA</li>
</ul>
</li>
</ul>
</li>
<li>TransactionStatus</li>
</ul>
<p><code>TransactionDefinition</code>–传参到getTransation–&gt;<code>PlatformTransactionManager</code>–getTransaction得到–&gt;<code>TransactionStatus</code></p>

            
        
        </div>
        
            
    <div class="post-reward">
        <span class="reward-btn" id="reward-btn">reward</span>
        <div class="reward-wrapper" id="reward-wrapper" style="display:none;">
            
                
                
            
                
                <div class="reward-item reward-alipay">
                    <img src="HTTPS://QR.ALIPAY.COM/FKX06998HVOXTEBPPDIXE9">
                </div>
                
            
                
                <div class="reward-item reward-wechat">
                    <img src="/">
                </div>
                
            
                
                <div class="reward-item reward-paypal">
                    <img src="/">
                </div>
                
            
        </div>
    </div>

            
        
    </article>
    
        
    <nav class="article-page">
        
            <a href="/2017/10/19/basic/" id="art-left" class="art-right">
                <span class="next-title">
                    分布式基础知识<i class="iconfont icon-right"></i> 
                </span>
            </a>
        
        
            <a href="/2017/10/17/blog/" id="art-right" class="art-left">
                <span class="prev-title"> 
                    <i class="iconfont icon-left"></i>hexo+github=blog
                </span>
            </a>
        
    </nav>

        
    <i id="com-switch" class="iconfont icon-more jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg);"></i>
    <div class="post-comments" id="post-comments" style="display: block;margin: auto 16px;">
        
        
<!-- Gitment Comments -->
<div id="gitment"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
var gitment = new Gitment({
  owner: "super2bai",
  repo: 'comment',
  oauth: {
    client_id: '37f2293730b41dcb5276',
    client_secret: 'dbab4955840d4cbc88f1563be04ab676662194e5',
  },
})
gitment.render('gitment')
</script>

        
<!-- SOHUCS Comments -->
<div id="SOHUCS"></div> 
<script type="text/javascript"> 
(function(){ 
var appid = '';
var conf = '';
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="http://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("http://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

        

    </div>

    


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
        
            <a href="https://github.com/super2bai" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2017 ~ 2018</span>
        <span>❤</span>
        <span>super2bai</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>
<script src="/script/search.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.mobileHeader();
    Nlvi.back2top();
    Nlvi.smoothScroll();
    Nlvi.onView();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward();
    Nlvi.picPos();

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
        
    <div class="post-toc">
        <span class="title">文章目录</span>
        <div class="toc-inner syuanpi back-1 fallIn-light">
            <li class="title-link"><a href="javascript:;" class="toTop">spring-framework</a></li>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、什么是IOC-DI"><span class="toc-text">一、什么是IOC/DI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Spring-IOC体系结构"><span class="toc-text">二、Spring IOC体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、IoC容器的初始化"><span class="toc-text">三、IoC容器的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、IoC容器的依赖注入"><span class="toc-text">四、IoC容器的依赖注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、IoC容器的高级特性"><span class="toc-text">五、IoC容器的高级特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、Spring-AOP设计原理及具体实践"><span class="toc-text">六、Spring AOP设计原理及具体实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#七、Spring-JDBC设计原理及二次开发"><span class="toc-text">七、Spring JDBC设计原理及二次开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#八、Spring-MVC框架设计原理"><span class="toc-text">八、Spring MVC框架设计原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#九、Spring事务原理详解"><span class="toc-text">九、Spring事务原理详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#十、Spring事务源码分析"><span class="toc-text">十、Spring事务源码分析</span></a></li></ol>
        </div>
    </div>

    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
    
</body>
</html>
