<!DOCTYPE html>
<html lang="">
<head>
    <title> NIO原理 · super2bai </title>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="super2bai">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />
<meta name="keywords" content="nlvi, Nlvi" />





    <meta name="keywords" content="NIO, Nlvi" />

<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "super2bai",
        author: "super2bai",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">









    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/GitHub-Pages/" style="font-size: 14px;">GitHub Pages</a> <a href="/tags/NIO/" style="font-size: 14px;">NIO</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 14px;">Zookeeper</a> <a href="/tags/分布式/" style="font-size: 14px;">分布式</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">super2bai</a></span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        
        
            <li class="menu-item">
                <a href="/">
                    <span>Article</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>Archives</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>Tags</span>
                    
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/about">
                    <span>About</span>
                    
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
</header>
<div class="mobile-header">
    <div class="mobile-header-body">
        <div class="mobile-header-list">
            
            
                <div class="mobile-nav-item">
                    <a href="/">
                        <span>Article</span>
                        
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/archives">
                        <span>Archives</span>
                        
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item inner-cloud">
                    <div class="mobile-nav-tag">
                        <a href="javascript:;" id="mobile-tags">
                            <span>Tags</span>
                            
                            
                        </a>
                    </div>
                    <div class="mobile-nav-tagcloud">
                        <div class="mobile-tagcloud-inner">
                            <a href="/tags/Dubbo/" style="font-size: 14px;">Dubbo</a> <a href="/tags/GitHub-Pages/" style="font-size: 14px;">GitHub Pages</a> <a href="/tags/NIO/" style="font-size: 14px;">NIO</a> <a href="/tags/Spring/" style="font-size: 14px;">Spring</a> <a href="/tags/Zookeeper/" style="font-size: 14px;">Zookeeper</a> <a href="/tags/分布式/" style="font-size: 14px;">分布式</a>
                        </div>
                    </div>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/about">
                        <span>About</span>
                        
                        
                    </a>
                </div>
            
            
        </div>
    </div>
    <div class="mobile-header-nav">
        <div class="mobile-header-item" id="mobile-left">
            <div class="header-menu-item">
                <span class="header-menu-line"></span>
            </div>
        </div>
        <h1 class="mobile-header-title">
            <a href="/">super2bai</a>
        </h1>
        <div class="mobile-header-item"></div>
    </div>
</div>

    <div class="container">
        <main class="main" id="main">
            
    
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>November 20, 2017</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                NIO原理
            
            </h1>
            
                
                    <div class="post-tags syuanpi riseIn-light back-3">
                    
                        <a href="/tags/NIO/">NIO</a>
                    
                    </div>
                
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="阻塞Block和非阻塞Non-Block"><a href="#阻塞Block和非阻塞Non-Block" class="headerlink" title="阻塞Block和非阻塞Non-Block"></a>阻塞Block和非阻塞Non-Block</h4><blockquote>
<p>进程在访问数据的时候，<strong>数据是否准备就绪</strong>的一种处理方式。</p>
<ul>
<li>当数据没有准备的时候<ul>
<li>阻塞<ul>
<li>往往需要等待缓冲区中的数据准备好过后才处理其它的事情，否则一直等待</li>
</ul>
</li>
<li>非阻塞<ul>
<li>直接返回，不回等待。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>IO模型</th>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>方式</td>
<td>从硬盘到内存</td>
<td>从内存到硬盘</td>
</tr>
<tr>
<td>通信</td>
<td>面向流(乡村公路)</td>
<td>面向缓冲区(高速公路，多路复用技术)</td>
</tr>
<tr>
<td>处理</td>
<td>阻塞IO(多线程)</td>
<td>非阻塞IO(反应堆Reactor)</td>
</tr>
<tr>
<td>触发</td>
<td>无</td>
<td>选择器(轮循机制)</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>流<ul>
<li>每次从流中读一个或多个字节，直至读取所有字节，没有被缓存在任何地方。</li>
<li>不能前后移动流中的数据<ul>
<li>需要移动从流中读区的数据，需要先将它缓存到一个缓冲区</li>
</ul>
</li>
</ul>
</li>
<li>缓冲<ul>
<li>数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动<ul>
<li>增加了处理过程中的灵活性</li>
<li>需检查是否该缓冲区中包含所有需要处理的数据</li>
<li>需确保当跟多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="同步Synchronization和异步Asynchronous"><a href="#同步Synchronization和异步Asynchronous" class="headerlink" title="同步Synchronization和异步Asynchronous"></a>同步Synchronization和异步Asynchronous</h4><blockquote>
<p>基于应用程序和操作系统<strong>处理IO事件</strong>所采用的方式。</p>
<ul>
<li>同步<ul>
<li>应用程序直接参与IO读写的操作</li>
<li>处理IO事件时，必须阻塞在某个方法上等待IO事件完成</li>
<li>阻塞IO事件或者通过轮询IO事件的方式</li>
<li>阻塞到IO事件，阻塞到read或者write，不能做其它事情</li>
<li>读写方法加入到线程里面，通过阻塞线程来实现，对线程的性能开销比较大</li>
</ul>
</li>
<li>异步<ul>
<li>所有的IO读写交给操作系统去处理，应用程序需要等待通知时，可以去做其它事情</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h4><blockquote>
<p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道。</p>
<p>这些通道里已经有可以处理的输入或者选择已准备写入的通道。</p>
<p>这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
</blockquote>
<h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><ul>
<li>对NIO或IO类的API调用</li>
<li>数据处理</li>
<li>用来处理数据的线程数<ul>
<li>NIO<ul>
<li>只使用一个或几个单线程管理多个通道（网络连接或文件）</li>
<li>代价是解析数据可能会从一个阻塞流中读取更复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流方式</span></div><div class="line">FileInputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"d://info.txt"</span>);</div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input)); </div><div class="line"><span class="comment">//返回时数据已经读完</span></div><div class="line"><span class="comment">//仅在有新数据读入时才运行，并不知道每步的数据时什么</span></div><div class="line"><span class="comment">//一旦正在运行的线程一处理过读入的某些数据</span></div><div class="line"><span class="comment">//该线程不会再回退数据</span></div><div class="line"><span class="comment">//Stream&lt;-Thread</span></div><div class="line">String nameLine = reader.readLine();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//缓冲</span></div><div class="line"><span class="comment">//Channel--(fill data)-&gt;Buffer&lt;--(check data)-Thread</span></div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</div></pre></td></tr></table></figure>
<h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><ul>
<li>NIO<ul>
<li>数据先读入缓冲区再处理</li>
</ul>
</li>
<li>IO<ul>
<li>从一个InputStream/Reader逐字节读取</li>
</ul>
</li>
</ul>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">Java NIO</a></h3><ul>
<li>Java 1.4</li>
<li>面向块</li>
</ul>
<h4 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h4><ul>
<li>缓冲区Buffer</li>
<li>通道Channel</li>
<li>选择器Selector</li>
</ul>
<h4 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/Buffer.html" target="_blank" rel="external">缓冲区Buffer</a></h4><blockquote>
<p>缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组。NIO库中，所有数据都是用缓冲区处理的。从缓冲区读，写入到缓冲区。</p>
<p>所有的缓冲区类型都继承于抽象类Buffer。</p>
</blockquote>
<ul>
<li>Buffer<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
</ul>
</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.IntBuffer;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIntBuffer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">// 分配新的 int 缓冲区，参数为缓冲区容量</span></div><div class="line">      <span class="comment">// 新缓冲区的当前位置将为零，其界限(限制位置)将为其容量。它将具有一个底层实现数组， 其数组偏移量将为零。</span></div><div class="line">      IntBuffer buffer = IntBuffer.allocate(<span class="number">8</span>);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123; </div><div class="line">          <span class="keyword">int</span> j = <span class="number">2</span> * (i + <span class="number">1</span>);</div><div class="line">          <span class="comment">// 将给定整数写入此缓冲区的当前位置，当前位置递增 </span></div><div class="line">          buffer.put(j);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 重设此缓冲区，将限制设置为当前位置，然后将当前位置设置为 0 </span></div><div class="line">      buffer.flip();</div><div class="line">      <span class="comment">// 查看在当前位置和限制位置之间是否有元素 </span></div><div class="line">      <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">          <span class="comment">// 读取此缓冲区当前位置的整数，然后当前位置递增 </span></div><div class="line">          <span class="keyword">int</span> j = buffer.get();</div><div class="line">          <span class="comment">// 2 4 6 8 10 12 14 16 </span></div><div class="line">          System.out.print(j + <span class="string">" "</span>);</div><div class="line">      &#125;</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="深入剖析Buffer"><a href="#深入剖析Buffer" class="headerlink" title="深入剖析Buffer"></a>深入剖析Buffer</h5><blockquote>
<p>一个特殊的数组，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况，如果我们使用 get()方法从缓冲区获取数据，或者使用 put()方法把数据写入缓冲区，都会引起缓冲区状态的变化。</p>
</blockquote>
<p><strong>重要属性</strong></p>
<ul>
<li>position<ul>
<li>指定了下一个将要被写入或者读取的元素索引</li>
<li>它的值由 get()/put()方法自动更新</li>
<li>在新创建一个Buffer对象时，position被初始化为0。</li>
</ul>
</li>
<li>limit<ul>
<li>指定还有多少数据需要取出(在从缓冲区写入通道时)</li>
<li>或者还有多少空间可以放入数据(在从通道读入缓冲区时)</li>
</ul>
</li>
<li>capacity<ul>
<li>指定了可以存储在缓冲区中的最大数据容量</li>
<li>实际上，它指定了底层数据的大小</li>
<li>或者至少是指定了准许使用的底层数组的容量</li>
</ul>
</li>
</ul>
<p><strong>0 &lt;=position&lt;=limit&lt;=capacity</strong></p>
<p><strong>都是在JVM允许范围内</strong></p>
<p>例子：</p>
<ul>
<li>创建一个新的容量大小为10的ByteBuffer对象<ul>
<li>初始化时<ul>
<li>position为0</li>
<li>limit和capacity被设置为10</li>
</ul>
</li>
<li>使用过程中<ul>
<li>capacity不会发生变化</li>
<li>position和limit会变化</li>
</ul>
</li>
<li>读取4个数据<ul>
<li>从通道读取数据，相当于往缓冲区中写入数据</li>
<li>position为4<ul>
<li>下一个将要被写入的字节索引为4</li>
</ul>
</li>
<li>limit依旧为10</li>
</ul>
</li>
<li>读取的数据写入到通道中，相当于从缓冲区中读取数据<ul>
<li>调用flip()<ul>
<li>把limit设置为当前的position值<ul>
<li>保证读取的数据正好是之前写入到缓冲区中的数据</li>
</ul>
</li>
<li>把position设置为0<ul>
<li>可以保证在下一步输出时读取到的是缓冲区的第一个字节</li>
</ul>
</li>
</ul>
</li>
<li>调用get()<ul>
<li>从缓冲区中读取数据写入到输出通道</li>
<li>position增加</li>
<li>limit不变</li>
<li>position不会超过limit</li>
</ul>
</li>
<li>读取之前写入到缓冲区的4个字节之后<ul>
<li>position和limit都为4</li>
</ul>
</li>
<li>从缓冲区读取数据完毕后<ul>
<li>limit的值仍然保持在调用flip()方法时的值</li>
</ul>
</li>
</ul>
</li>
<li>调用clear()能够把所有的状态变化设置为初始化时的值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileInputStream;</div><div class="line"><span class="keyword">import</span> java.nio.*;</div><div class="line"><span class="keyword">import</span> java.nio.channels.*;</div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * output:</span></div><div class="line"><span class="comment">	初始化 : </span></div><div class="line"><span class="comment">	capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment">	</span></div><div class="line"><span class="comment">	调用 read() : </span></div><div class="line"><span class="comment">	capacity: 10, position: 10, limit: 10</span></div><div class="line"><span class="comment">	</span></div><div class="line"><span class="comment">	调用 flip() : </span></div><div class="line"><span class="comment">	capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment">	</span></div><div class="line"><span class="comment">	调用 get() : </span></div><div class="line"><span class="comment">	capacity: 10, position: 10, limit: 10</span></div><div class="line"><span class="comment">	</span></div><div class="line"><span class="comment">	调用 clear() : </span></div><div class="line"><span class="comment">	capacity: 10, position: 0, limit: 10</span></div><div class="line"><span class="comment">	 */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		FileInputStream fin = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">		FileChannel fc = fin.getChannel();</div><div class="line">		ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">		output(<span class="string">"初始化"</span>, buffer);</div><div class="line">		fc.read(buffer);</div><div class="line">		output(<span class="string">"调用 read()"</span>, buffer);</div><div class="line">		buffer.flip();</div><div class="line">		output(<span class="string">"调用 flip()"</span>, buffer);</div><div class="line">		<span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">byte</span> b = buffer.get();</div><div class="line">			<span class="comment">// System.out.print(((char)b));</span></div><div class="line">		&#125;</div><div class="line">		output(<span class="string">"调用 get()"</span>, buffer);</div><div class="line"></div><div class="line">		buffer.clear();</div><div class="line">		output(<span class="string">"调用 clear()"</span>, buffer);</div><div class="line">		fin.close();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String step, Buffer buffer)</span> </span>&#123;</div><div class="line">		System.out.println(step + <span class="string">" : "</span>);</div><div class="line">		System.out.print(<span class="string">"capacity: "</span> + buffer.capacity() + <span class="string">", "</span>);</div><div class="line">		System.out.print(<span class="string">"position: "</span> + buffer.position() + <span class="string">", "</span>);</div><div class="line">		System.out.println(<span class="string">"limit: "</span> + buffer.limit());</div><div class="line">		System.out.println();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="缓冲区的分配"><a href="#缓冲区的分配" class="headerlink" title="缓冲区的分配"></a>缓冲区的分配</h5><blockquote>
<p>在创建一个缓冲区对象时，会调用静态方法allocate()来指定缓冲区的容量。其实调用allocate（）相当于创建了一个指定大小的数组，并把它包装为缓冲区对象。也可以直接将一个的数组，包装为缓冲区对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferWrap</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 分配指定大小的缓冲区</span></div><div class="line">    ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">    <span class="comment">// 包装一个现有的数组</span></div><div class="line">    <span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">    ByteBuffer buffer2 = ByteBuffer.wrap( array );</div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h5><blockquote>
<p>在NIO中，除了可以分配或者包装一个缓冲区对象外，还可以根据现有的缓冲区对象来创建一个子缓冲区，即在现有缓冲区上切出一片来作为一个新的缓冲区。</p>
<p>现有的缓冲区与创建的子缓冲区在底层数组层面上是数据共享的。</p>
<p>子缓冲区相当于是现有缓冲区的一个视图窗口。</p>
<p>调用slice()可以创建一个子缓冲区。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">0</span></div><div class="line"><span class="comment">1</span></div><div class="line"><span class="comment">2</span></div><div class="line"><span class="comment">30</span></div><div class="line"><span class="comment">40</span></div><div class="line"><span class="comment">50</span></div><div class="line"><span class="comment">60</span></div><div class="line"><span class="comment">7</span></div><div class="line"><span class="comment">8</span></div><div class="line"><span class="comment">9</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">  <span class="comment">// 缓冲区中的数据 0-9</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    buffer.put((<span class="keyword">byte</span>) i);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 创建子缓冲区</span></div><div class="line">  buffer.position(<span class="number">3</span>);</div><div class="line">  buffer.limit(<span class="number">7</span>);</div><div class="line">  ByteBuffer slice = buffer.slice();</div><div class="line">  <span class="comment">// 改变子缓冲区的内容</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; slice.capacity(); ++i) &#123;</div><div class="line">    <span class="keyword">byte</span> b = slice.get(i);</div><div class="line">    b *= <span class="number">10</span>;</div><div class="line">    slice.put(i, b);</div><div class="line">  &#125;</div><div class="line">  buffer.position(<span class="number">0</span>);</div><div class="line">  buffer.limit(buffer.capacity());</div><div class="line">  <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(buffer.get());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h5><blockquote>
<p>只能读取，不能写入。</p>
<p>通过调用asReadOnlyBuffer()，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区，并与原缓冲区共享数据，只不过是只读的。</p>
<p>如果原缓冲区的内容发生了变化，只读缓冲区的内容也随之发生变化。</p>
<p>常规缓冲区可以转换为只读缓冲区，<br>只读缓冲区不能转换为常规缓冲区。</p>
<p>常用于控制权限（回调方法），比如：在将缓冲区的引用传递给某个对象的方法时，你无法确定这个方法是否会修改缓冲区中的数据，这个时候，就可以创建一个只读缓冲区，然后把只读缓冲区的引用传递给那个方法，这样就能保证，使用那个方法的人没办法去修改缓冲区中的数据了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</div><div class="line">  <span class="comment">// 缓冲区中的数据 0-9</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    buffer.put((<span class="keyword">byte</span>) i);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 创建只读缓冲区</span></div><div class="line">  ByteBuffer readonly = buffer.asReadOnlyBuffer();</div><div class="line">  <span class="comment">// 改变原缓冲区的内容</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); ++i) &#123;</div><div class="line">    <span class="keyword">byte</span> b = buffer.get(i);</div><div class="line">    b *= <span class="number">10</span>;</div><div class="line">    buffer.put(i, b);</div><div class="line">  &#125;</div><div class="line">  readonly.position(<span class="number">0</span>);</div><div class="line">  readonly.limit(buffer.capacity());</div><div class="line">  <span class="comment">// 只读缓冲区的内容也随之改变</span></div><div class="line">  <span class="keyword">while</span> (readonly.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">    System.out.println(readonly.get());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/channels/Channel.html" target="_blank" rel="external">通道Channel</a></h4><blockquote>
<ul>
<li>通道是一个对象，可以读取和写入数据。</li>
<li>所有数据都通过Buffer对象来处理，不会将字节直接写入通道或直接从通道中读取数据。</li>
<li>所有的通道对象都实现了Channel接口。</li>
</ul>
</blockquote>
<h5 id="使用NIO读取数据"><a href="#使用NIO读取数据" class="headerlink" title="使用NIO读取数据"></a>使用NIO读取数据</h5><ul>
<li>从FileInputStream获取Channel</li>
<li>创建Buffer</li>
<li>将数据从Channel读取到Buffer中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">  FileInputStream fin = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    fin = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">    <span class="comment">// 获取通道</span></div><div class="line">    FileChannel fc = fin.getChannel(); <span class="comment">// 创建缓冲区</span></div><div class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>); <span class="comment">// 读取数据到缓冲区</span></div><div class="line">    fc.read(buffer);</div><div class="line">    buffer.flip();</div><div class="line">    <span class="keyword">while</span> (buffer.remaining() &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">byte</span> b = buffer.get();</div><div class="line">      System.out.print(((<span class="keyword">char</span>) b));</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      fin.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="使用NIO写入数据"><a href="#使用NIO写入数据" class="headerlink" title="使用NIO写入数据"></a>使用NIO写入数据</h5><ul>
<li>从FileInputStream获取Channel</li>
<li>创建Buffer</li>
<li>将数据从Channel写入到Buffer中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/2bai/Downloads/test.txt"</span>);</div><div class="line">  FileChannel fc = fout.getChannel();</div><div class="line">  ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">  buffer.put(Charset.forName(<span class="string">"utf8"</span>).encode(<span class="string">"你好你好你好你好你好"</span>));</div><div class="line">  buffer.flip();</div><div class="line">  fc.write(buffer);</div><div class="line">  fout.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="反应堆Reactor"><a href="#反应堆Reactor" class="headerlink" title="反应堆Reactor"></a><a href="http://kasunpanorama.blogspot.com/2015/04/understanding-reactor-pattern-with-java.html" target="_blank" rel="external">反应堆Reactor</a></h4><h5 id="阻塞I-O通信模型"><a href="#阻塞I-O通信模型" class="headerlink" title="阻塞I/O通信模型"></a>阻塞I/O通信模型</h5><p><strong>缺点</strong></p>
<ul>
<li>当客户端多时，会创建大量的处理线程，且每个线程都要占用栈空间和CPU时间</li>
<li>阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。在这种情况下非阻塞I/O就又了它的应用前景</li>
</ul>
<h5 id="Java-NIO原理及通信模型"><a href="#Java-NIO原理及通信模型" class="headerlink" title="Java NIO原理及通信模型"></a>Java NIO原理及通信模型</h5><ul>
<li>由一个专门的线程来处理所有的IO事件，并负责分发</li>
<li>事件驱动机制<ul>
<li>事件到的时候触发，而不是同步的去监视事件</li>
</ul>
</li>
<li>线程通讯<ul>
<li>线程之间通过wait、notify等方式通讯</li>
<li>保证每次上下文切换都是有意义的，减少无谓的线程切换</li>
</ul>
</li>
</ul>
<p><strong>客户端—&gt;Reactor(分发wait/notify)—&gt;处理线程N(read、decode、compute、encode、send)</strong></p>
<p>每个线程的处理流程大概都是读取数据、解码、计算处理、编码、发送相应。</p>
<h4 id="选择器Seletor"><a href="#选择器Seletor" class="headerlink" title="选择器Seletor"></a><a href="https://docs.oracle.com/javase/9/docs/api/java/nio/channels/Selector.html" target="_blank" rel="external">选择器Seletor</a></h4><p>传统的Server/Client模式会基于TPR(Thread per Request)，服务器会为每个客户端请求建立一个线程，由该线程单独处理一个客户请求。</p>
<p>问题：线程数量的剧增，大量线程会增大服务器开销。</p>
<p>解决：线程池。</p>
<p>产生问题：线程池中的线程都在处理，超过线程池数量的请求无法处理。</p>
<blockquote>
<p>NIO中非阻塞I/O采用了基于Reactor模式的工作方式，I/O调用不会被阻塞，可以注册感兴趣的特定I/O事件，如可读数据到达，新的Socket连接等等，在发生特定事件时，系统再通知。</p>
<p>NIO中实现非阻塞I/O的核心对象就是Selector，Selector就是注册各种I/O事件的地方。而且当事件发生时，就是Selector告诉所发生的事件。</p>
<p>当有读或写等任何注册的事件发生时，可以从Selector中获得相应的SelectorKey，同事从SelectorKey中可以找到发生的事件和该事件所发生的具体SelectableChannel，以获得客户端发送过来的数据。</p>
<p>Select是NIO的核心，底层使用epoll模型。 </p>
</blockquote>
<ul>
<li>使用NIO中非阻塞I/O编写服务器处理程序<ul>
<li>向Selector对象注册感兴趣的事件</li>
<li>从Selector中获得去感兴趣的事件</li>
<li>根据不同的事件进行相应的处理</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">关键点：</span></div><div class="line"><span class="comment">1.创建一个ServerSocketChannel，和一个Selector，并且把这个server channel 注册到 selector上，注册的时间指定，这个channel 所感觉兴趣的事件是 SelectionKey.OP_ACCEPT，这个事件代表的是有客户端发起TCP连接请求。</span></div><div class="line"><span class="comment">2.使用 select 方法阻塞住线程，当select 返回的时候，线程被唤醒。再通过selectedKeys方法得到所有可用channel的集合。</span></div><div class="line"><span class="comment">3.遍历这个集合，如果其中channel 上有连接到达，就接受新的连接，然后把这个新的连接也注册到selector中去。</span></div><div class="line"><span class="comment">4.如果有channel是读，那就把数据读出来，并且把它感兴趣的事件改成写。如果是写，就把数据写出去，并且把感兴趣的事件改成读。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 注册事件</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">getSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// 创建 Selector 对象</span></div><div class="line">  Selector sel = Selector.open();</div><div class="line">  <span class="comment">// 创建可选择通道</span></div><div class="line">  ServerSocketChannel server = ServerSocketChannel.open();</div><div class="line">  <span class="comment">// 配置为非阻塞模式</span></div><div class="line">  server.configureBlocking(<span class="keyword">false</span>);</div><div class="line">  <span class="comment">// 绑定通道到指定端口</span></div><div class="line">  ServerSocket socket = server.socket();</div><div class="line">  InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">  socket.bind(address);</div><div class="line">  <span class="comment">// 向 Selector 中注册感兴趣的事件(监听accept事件)</span></div><div class="line">  <span class="comment">// 新的连接发生时所产生的事件</span></div><div class="line">  <span class="comment">// OP option</span></div><div class="line">  server.register(sel, SelectionKey.OP_ACCEPT);</div><div class="line">  <span class="keyword">return</span> sel;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 开始监听</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</div><div class="line">  System.out.println(<span class="string">"listen on "</span> + port);</div><div class="line">  <span class="comment">// 非阻塞I/O中，内部循环模式基本都是遵循这种方式</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="comment">// 该调用会阻塞，直到至少有一个事件发生</span></div><div class="line">      selector.select();</div><div class="line">      <span class="comment">// 获取发生事件的SelectionKey</span></div><div class="line">      Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</div><div class="line">      <span class="comment">// 迭代器循环</span></div><div class="line">      Iterator&lt;SelectionKey&gt; iter = keys.iterator();</div><div class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</div><div class="line">        SelectionKey key = (SelectionKey) iter.next();</div><div class="line">        iter.remove();</div><div class="line">        process(key);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 根据不同的事件做处理</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123; </div><div class="line">  <span class="comment">// 接收请求</span></div><div class="line">  <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">    ServerSocketChannel server = (ServerSocketChannel) key.channel();</div><div class="line">    SocketChannel channel = server.accept();</div><div class="line">    channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">    channel.register(selector, SelectionKey.OP_READ);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 读信息</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    <span class="keyword">int</span> len = channel.read(buffer);</div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</div><div class="line">      buffer.flip();</div><div class="line">      String name = <span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len);</div><div class="line">      SelectionKey sKey = channel.register(selector, SelectionKey.OP_WRITE);</div><div class="line">      sKey.attach(name);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      channel.close();</div><div class="line">    &#125;</div><div class="line">    buffer.clear();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 写事件</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">    SocketChannel channel = (SocketChannel) key.channel();</div><div class="line">    String name = (String) key.attachment();</div><div class="line">    ByteBuffer block = ByteBuffer.wrap((<span class="string">"Hello "</span> + name).getBytes());</div><div class="line">    <span class="keyword">if</span> (block != <span class="keyword">null</span>) &#123;</div><div class="line">      channel.write(block);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      channel.close();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类</p>
<p><code>FileChannel</code></p>
<p><code>ServerSocketchannel</code></p>
<p><code>SocketChannel</code></p>
<p><code>ByteBuffer</code></p>
<p><code>MappedByteBuffer</code></p>
<p>方法</p>
<p><code>wrap</code></p>
<p><code>slice</code></p>
<p><code>allocate</code></p>
<p><code>allocateDirect</code></p>
<p><code>asReadOnlyBuffer</code></p>
<p>动态改变position的值(油表)</p>
<p><code>put</code></p>
<p><code>get</code></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/6-b27/" target="_blank" rel="external">源码分析</a></h3><h4 id="Selector-open"><a href="#Selector-open" class="headerlink" title="Selector.open()"></a><code>Selector.open()</code></h4><p><code>java.nio.channels.Selector#open</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">return</span> SelectorProvider.provider().openSelector();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Selector</code>是调用的<code>SelectorProvider.provider()</code>拿到的<code>provider</code>对象创建的<code>ServerSocketChannel</code>，上文的<code>Selector</code>、<code>Pipe</code>都是通过这一个<code>provider</code>对象创建的。</p>
<p><code>java.nio.channels.spi.SelectorProvider#provider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">    <span class="comment">//保证了整个server程序中只有一个provider对象</span></div><div class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</div><div class="line">      <span class="keyword">return</span> provider;</div><div class="line">    <span class="keyword">return</span> AccessController.doPrivileged(</div><div class="line">      <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">          <span class="keyword">if</span> (loadProviderFromProperty())</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">          <span class="keyword">if</span> (loadProviderAsService())</div><div class="line">            <span class="keyword">return</span> provider;</div><div class="line">          <span class="comment">//会根据操作系统来返回不同的实现类</span></div><div class="line">          <span class="comment">//windows-&gt;WindowsSelectorProvider</span></div><div class="line">          provider = sun.nio.ch.DefaultSelectorProvider.create();</div><div class="line">          <span class="keyword">return</span> provider;</div><div class="line">        &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于windows操作系统来说他的实现类就是<code>WindowsSelectorProvider</code>，而<code>WindowsSelectorProvider</code>类中只是实现了<code>openSelector</code>方法。</p>
<p><code>WindowsSelectorProvider#openSelector</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AbstractSelector <span class="title">openSelector</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">    <span class="comment">//和操作系统有关系</span></div><div class="line">    <span class="comment">//调用了操作系统底层的API</span></div><div class="line">    <span class="comment">// Windows -&gt; WindowsSelectorImpl</span></div><div class="line">    <span class="comment">// Mac     -&gt; KQueueSelectorImpl</span></div><div class="line">    <span class="comment">// Linux   -&gt; PollSelectorImpl</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>WindowsSelectorImpl(SelectorProvider)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">WindowsSelectorImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123; </div><div class="line">	<span class="keyword">super</span>(sp);</div><div class="line">    <span class="comment">//pollWrapper保存selector上注册的FD</span></div><div class="line">    <span class="comment">//包括pipe的write端FD和ServerSocketChannel所用的FD</span></div><div class="line">	pollWrapper = <span class="keyword">new</span> PollArrayWrapper(INIT_CAP);</div><div class="line">    <span class="comment">//wakeupPipi:通道</span></div><div class="line">    <span class="comment">//其实就是两个FD：一个read、一个write</span></div><div class="line">    <span class="comment">//关键点</span></div><div class="line">	wakeupPipe = Pipe.open();</div><div class="line">	wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();</div><div class="line">	<span class="comment">// Disable the Nagle algorithm so that the wakeup is more immediate</span></div><div class="line">	SinkChannelImpl sink = (SinkChannelImpl)wakeupPipe.sink();</div><div class="line">	(sink.sc).socket().setTcpNoDelay(<span class="keyword">true</span>);</div><div class="line">	wakeupSinkFd = ((SelChImpl)sink).getFDVal();</div><div class="line">	pollWrapper.addWakeupSocket(wakeupSourceFd, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>java.nio.channels.Pipe#open</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">return</span> SelectorProvider.provider().openPipe();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.SelectorProviderImpl#openPipe</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Pipe <span class="title">openPipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PipeImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.PipeImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PipeImpl(SelectorProvider sp) &#123;</div><div class="line">	<span class="keyword">int</span>[] fdes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">    <span class="comment">//关键点</span></div><div class="line">	IOUtil.initPipe(fdes, <span class="keyword">true</span>);</div><div class="line">	FileDescriptor sourcefd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">	IOUtil.setfdVal(sourcefd, fdes[<span class="number">0</span>]);</div><div class="line">	source = <span class="keyword">new</span> SourceChannelImpl(sp, sourcefd);</div><div class="line">	FileDescriptor sinkfd = <span class="keyword">new</span> FileDescriptor();</div><div class="line">	IOUtil.setfdVal(sinkfd, fdes[<span class="number">1</span>]);</div><div class="line">	sink = <span class="keyword">new</span> SinkChannelImpl(sp, sinkfd);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.IOUtil#initPipe</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">initPipe</span><span class="params">(<span class="keyword">int</span>[] fda, <span class="keyword">boolean</span> blocking)</span></span>;</div></pre></td></tr></table></figure>
<p><code>solaris/native/sun/nio/ch/IOUtil.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</div><div class="line">Java_sun_nio_ch_IOUtil_initPipe(JNIEnv *env, jobject <span class="keyword">this</span>,</div><div class="line">                                    jintArray intArray, jboolean block)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">    jint *ptr = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</div><div class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Pipe failed"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (block == JNI_FALSE) &#123;</div><div class="line">        <span class="keyword">if</span> ((configureBlocking(fd[<span class="number">0</span>], JNI_FALSE) &lt; <span class="number">0</span>)</div><div class="line">            || (configureBlocking(fd[<span class="number">1</span>], JNI_FALSE) &lt; <span class="number">0</span>)) &#123;</div><div class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">"Configure blocking failed"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ptr = (*env)-&gt;GetPrimitiveArrayCritical(env, intArray, <span class="number">0</span>);</div><div class="line">    ptr[<span class="number">0</span>] = fd[<span class="number">0</span>];</div><div class="line">    ptr[<span class="number">1</span>] = fd[<span class="number">1</span>];</div><div class="line">    (*env)-&gt;ReleasePrimitiveArrayCritical(env, intArray, ptr, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ServerSocketChannel-open"><a href="#ServerSocketChannel-open" class="headerlink" title="ServerSocketChannel.open()"></a><code>ServerSocketChannel.open()</code></h4><p><code>java.nio.channels.ServerSocketChannel#open</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">return</span> SelectorProvider.provider().openServerSocketChannel();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>openServerSocketChannel</code>方法也和<code>openPipe</code>方法一样由父类<code>SelectorProviderImpl</code>来实现的</p>
<p><code>sun.nio.ch.SelectorProviderImpl#openServerSocketChannel</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">openServerSocketChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ServerSocketChannelImpl(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.ServerSocketChannelImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ServerSocketChannelImpl(SelectorProvider sp) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    <span class="comment">//调用父类的构造方法将SelectorProvider这个对象</span></div><div class="line">    <span class="comment">//初始化到父类的父类AbstractSelectableChannel中的</span></div><div class="line">	<span class="keyword">super</span>(sp);</div><div class="line">    <span class="comment">//创建了一个文件描述符对象设置为成员属性，注意这里传入的参数是true</span></div><div class="line">    <span class="comment">//代表创建的ServerSocketChannel对应的文件描述符对象是阻塞的</span></div><div class="line">	<span class="keyword">this</span>.fd =  Net.serverSocket(<span class="keyword">true</span>);</div><div class="line">    <span class="comment">//设置fdVal值，保存的是内核中文件当前文件描述符对象的index</span></div><div class="line">	<span class="keyword">this</span>.fdVal = IOUtil.fdVal(fd);</div><div class="line">    <span class="comment">//设置一个ServerSocketChannel的状态</span></div><div class="line">	<span class="keyword">this</span>.state = ST_INUSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="server-configureBlocking-false"><a href="#server-configureBlocking-false" class="headerlink" title="server.configureBlocking(false);"></a><code>server.configureBlocking(false);</code></h4><p><code>java.nio.channels.spi.AbstractSelectableChannel#configureBlocking</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (regLock) &#123;</div><div class="line">    	<span class="keyword">if</span> (!isOpen())</div><div class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">    	<span class="keyword">if</span> (blocking == block)</div><div class="line">      		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    	<span class="keyword">if</span> (block &amp;&amp; haveValidKeys())</div><div class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</div><div class="line">        <span class="comment">//关键点</span></div><div class="line">    	implConfigureBlocking(block);</div><div class="line">    	blocking = block;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.ServerSocketChannelImpl#implConfigureBlocking</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implConfigureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  	<span class="comment">//将当前ServerSocketChannel设置为非阻塞的模式</span></div><div class="line">	IOUtil.configureBlocking(fd, block);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="server-socket"><a href="#server-socket" class="headerlink" title="server.socket();"></a><code>server.socket();</code></h4><p><code>sun.nio.ch.ServerSocketChannelImpl#socket</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ServerSocket <span class="title">socket</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (stateLock) &#123;</div><div class="line">      <span class="comment">//ServerSocketImpl中并没有看到创建ServerSocket对象的语句</span></div><div class="line">      <span class="comment">//所以if (socket == null)的判断肯定是返回的true</span></div><div class="line">      <span class="keyword">if</span> (socket == <span class="keyword">null</span>)</div><div class="line">          socket = ServerSocketAdaptor.create(<span class="keyword">this</span>);</div><div class="line">      <span class="keyword">return</span> socket;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.ServerSocketAdaptor#create</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocket <span class="title">create</span><span class="params">(ServerSocketChannelImpl ssc)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> ServerSocketAdaptor(ssc);</div><div class="line">  	&#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//ServerSocketAdaptor类的构造方法如下</span></div><div class="line"><span class="comment">//创建的ServerSocketAdaptor中保存了ServerSocketChannelImpl的引用</span></div><div class="line"><span class="comment">//ServerSocketAdaptor类是ServerSocket的子类</span></div><div class="line"><span class="comment">//它覆盖了父类中的bind，accept，close等方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServerSocketAdaptor</span><span class="params">(ServerSocketChannelImpl ssc)</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="keyword">this</span>.ssc = ssc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="socket-bind"><a href="#socket-bind" class="headerlink" title="socket.bind"></a><code>socket.bind</code></h4><p><code>sun.nio.ch.ServerSocketAdaptor#bind</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress local)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	bind(local, <span class="number">50</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">if</span> (local == <span class="keyword">null</span>)</div><div class="line">    	local = <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>);</div><div class="line">  	<span class="keyword">try</span> &#123;</div><div class="line">    	ssc.bind(local, backlog);</div><div class="line">  	&#125; <span class="keyword">catch</span> (Exception x) &#123;</div><div class="line">    	Net.translateException(x);</div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.ServerSocketChannelImpl#bind</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  	<span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">    	<span class="keyword">if</span> (!isOpen())</div><div class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">    	<span class="keyword">if</span> (isBound())</div><div class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> AlreadyBoundException();</div><div class="line">        InetSocketAddress isa = (local == <span class="keyword">null</span>) ? <span class="keyword">new</span> InetSocketAddress(<span class="number">0</span>) :</div><div class="line">        Net.checkAddress(local);</div><div class="line">        SecurityManager sm = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>)</div><div class="line">          	sm.checkListen(isa.getPort());</div><div class="line">        NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</div><div class="line">        <span class="comment">//关键点</span></div><div class="line">        <span class="comment">//底层调用的是native方法</span></div><div class="line">        Net.bind(fd, isa.getAddress(), isa.getPort());</div><div class="line">        Net.listen(fd, backlog &lt; <span class="number">1</span> ? <span class="number">50</span> : backlog);</div><div class="line">        <span class="keyword">synchronized</span> (stateLock) &#123;</div><div class="line">          	localAddress = Net.localAddress(fd);</div><div class="line">        &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="server-register"><a href="#server-register" class="headerlink" title="server.register"></a><code>server.register</code></h4><p><strong>往Selector注册Channel,通道触发了一个事件意味着该事件已经就绪</strong></p>
<p><code>java.nio.channels.SelectableChannel#register</code></p>
<ul>
<li>可以注册四种事件,<code>java.nio.channels.SelectionKey</code>内定义：<ul>
<li><code>OP_READ</code>(1)<ul>
<li>一个有数据可读的通道</li>
</ul>
</li>
<li><code>OP_WRITE</code>(4)<ul>
<li>等待写数据的通道</li>
</ul>
</li>
<li><code>OP_CONNECT</code>(8)<ul>
<li>某个channel成功连接到另一个服务器</li>
</ul>
</li>
<li><code>OP_ACCEPT</code>(16)<ul>
<li>一个server socket channel准备好接收新进入的连接</li>
</ul>
</li>
</ul>
</li>
<li>注册多个事件，用“位或|”<ul>
<li><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SelectionKey包含：</span></div><div class="line"><span class="comment">//interest集合</span></div><div class="line"><span class="comment">//ready集合</span></div><div class="line"><span class="comment">//Channel</span></div><div class="line"><span class="comment">//Selector</span></div><div class="line"><span class="comment">//附加的对象（可选）</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span> <span class="keyword">throws</span> ClosedChannelException</span>&#123;</div><div class="line">	<span class="keyword">return</span> register(sel, ops, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>java.nio.channels.spi.AbstractSelectableChannel#register</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SelectionKey保存注册时的channel、selector、event</span></div><div class="line"><span class="comment">// 以及保存在pollWrapper的偏移位置index</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops,Object att)</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (regLock) &#123;</div><div class="line">      <span class="keyword">if</span> (!isOpen())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">      <span class="keyword">if</span> ((ops &amp; ~validOps()) != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">      <span class="keyword">if</span> (blocking)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalBlockingModeException();</div><div class="line">      SelectionKey k = findKey(sel);</div><div class="line">      <span class="comment">// 1 如果该channel和selector已经注册过，则直接添加感兴趣的事件和附件</span></div><div class="line">      <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</div><div class="line">        k.interestOps(ops);</div><div class="line">        k.attach(att);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 2 否则通过selector实现注册过程，调用select的regist</span></div><div class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// New registration</span></div><div class="line">        <span class="keyword">synchronized</span> (keyLock) &#123;</div><div class="line">          <span class="keyword">if</span> (!isOpen())</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedChannelException();</div><div class="line">          <span class="comment">//关键点</span></div><div class="line">          <span class="comment">//调用select的regist</span></div><div class="line">          k = ((AbstractSelector)sel).register(<span class="keyword">this</span>, ops, att);</div><div class="line">          addKey(k);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> k;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.SelectorImpl#register</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(AbstractSelectableChannel ch,<span class="keyword">int</span> ops,Object attachment)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span> (!(ch <span class="keyword">instanceof</span> SelChImpl))</div><div class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalSelectorException();</div><div class="line">    <span class="comment">//1.创建了一个SelectionKeyImpl对象</span></div><div class="line">    <span class="comment">//注册感兴趣事件和附件</span></div><div class="line">    SelectionKeyImpl k = <span class="keyword">new</span> SelectionKeyImpl((SelChImpl)ch, <span class="keyword">this</span>);</div><div class="line">    <span class="comment">//调用attach方法将传入的附件类attachment放入到SelectionKeyImpl的属性中</span></div><div class="line">    k.attach(attachment);</div><div class="line">    <span class="keyword">synchronized</span> (publicKeys) &#123;</div><div class="line">      implRegister(k);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//调用SelectionKeyImpl的interestOps方法将感兴趣的操作（SelectionKey.OP_ACCEPT）传入</span></div><div class="line">    <span class="comment">//实际上这个interestOps方法也是将这个值放到了KQueueSelectorImpl的pollWrapper属性中</span></div><div class="line">    k.interestOps(ops);</div><div class="line">    <span class="keyword">return</span> k;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="implRegister"><a href="#implRegister" class="headerlink" title="implRegister"></a><code>implRegister</code></h5><p><code>sun.nio.ch.SelectionKeyImpl</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> SelChImpl channel;                            <span class="comment">// package-private</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> SelectorImpl selector;</div><div class="line"><span class="comment">//保存了Selector的实现类和ServerSocketChannel的实现类</span></div><div class="line"><span class="comment">//这个构造方法中接受的第一个参数是SelChImpl类</span></div><div class="line"><span class="comment">//那么ServerSocketChannel的实现类肯定实现了这个类</span></div><div class="line">SelectionKeyImpl(SelChImpl ch, SelectorImpl sel) &#123;</div><div class="line">  channel = ch;</div><div class="line">  selector = sel;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用implRegister，这个方法的实现就是Selector的实现类，系统不同，实现类不同。</p>
<p>PollSelectorImpl(Linux)，WindowsSelectorImpl(Windows)，KQueueSelectorImpl(Mac)</p>
<p><code>sun.nio.ch.AbstractPollSelectorImpl#implRegister</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">implRegister</span><span class="params">(SelectionKeyImpl ski)</span> </span>&#123;</div><div class="line">  	<span class="keyword">synchronized</span> (closeLock) &#123;</div><div class="line">            <span class="keyword">if</span> (closed)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">            <span class="comment">// Check to see if the array is large enough</span></div><div class="line">            <span class="comment">//如果totalChannels的channel数量达到了channelArray的长度（默认是8）</span></div><div class="line">      		<span class="comment">//查看pollWrapper中的pollfd数组是否足够大</span></div><div class="line">            <span class="keyword">if</span> (channelArray.length == totalChannels) &#123;</div><div class="line">                <span class="comment">// Make a larger array</span></div><div class="line">				<span class="comment">//那么channelArray 急需要扩充，扩充为2倍                </span></div><div class="line">                <span class="keyword">int</span> newSize = pollWrapper.totalChannels * <span class="number">2</span>;</div><div class="line">                SelectionKeyImpl temp[] = <span class="keyword">new</span> SelectionKeyImpl[newSize];</div><div class="line">                <span class="comment">// Copy over</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=channelOffset; i&lt;totalChannels; i++)</div><div class="line">                    temp[i] = channelArray[i];</div><div class="line">                channelArray = temp;</div><div class="line">                <span class="comment">// Grow the NativeObject poll array</span></div><div class="line">                <span class="comment">//同时保存文件描述符对象的PollArrayWrapper类也需要扩充</span></div><div class="line">                pollWrapper.grow(newSize);</div><div class="line">            &#125;</div><div class="line">      		<span class="comment">//2.把新建的SelectionKey添加到pollWrapper的channel数组</span></div><div class="line">            channelArray[totalChannels] = ski;</div><div class="line">            <span class="comment">//设置SelectionKeyImpl对象的index属性也就是他在channelArray数组中的位置</span></div><div class="line">            ski.setIndex(totalChannels);</div><div class="line">            <span class="comment">//将SelectionKeyImpl对象的channel放到pollWrapper中</span></div><div class="line">            pollWrapper.addEntry(ski.channel);</div><div class="line">            <span class="comment">//totalChannels自增</span></div><div class="line">            totalChannels++;</div><div class="line">            <span class="comment">//将SelectionKeyImpl对象放到keys属性中</span></div><div class="line">            keys.add(ski);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="interestOps"><a href="#interestOps" class="headerlink" title="interestOps"></a><code>interestOps</code></h5><p><code>sun.nio.ch.SelectionKeyImpl#interestOps</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</div><div class="line">  	ensureValid();</div><div class="line">  	<span class="keyword">return</span> nioInterestOps(ops);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.SelectionKeyImpl#nioInterestOps</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SelectionKey <span class="title">nioInterestOps</span><span class="params">(<span class="keyword">int</span> ops)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((ops &amp; ~channel().validOps()) != <span class="number">0</span>)</div><div class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    channel.translateAndSetInterestOps(ops, <span class="keyword">this</span>);</div><div class="line">    interestOps = ops;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Selector</code>和<code>ServerSocketChannel</code>都创建好了，通过<code>ServerSocketChannel</code>的<code>register</code>方法把二者绑定在一起，也就是把创建<code>ServerSocketChannel</code>时创建的<code>FD</code>(file descriptor)与Selector绑定在了一起。</p>
<p>至此，server端已经启动完成了。</p>
<h4 id="selector-select"><a href="#selector-select" class="headerlink" title="selector.select()"></a><code>selector.select()</code></h4><p><strong>监听哪些Channel已经就绪</strong></p>
<p><strong>selectNow的选择过程是非阻塞的，select(timeout)和select()的选择过程是阻塞的</strong></p>
<p><code>sun.nio.ch.SelectorImpl#select</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回值表示有多少通道已经就绪</span></div><div class="line"><span class="comment">//select()底层调用为select(0)</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative timeout"</span>);</div><div class="line">  	<span class="comment">//关键点</span></div><div class="line">  	<span class="keyword">return</span> lockAndDoSelect((timeout == <span class="number">0</span>) ? -<span class="number">1</span> : timeout);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  	<span class="keyword">return</span> select(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.SelectorImpl#lockAndDoSelect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lockAndDoSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!isOpen())</div><div class="line">          	<span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">        <span class="keyword">synchronized</span> (publicKeys) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (publicSelectedKeys) &#123;</div><div class="line">                <span class="comment">//关键点</span></div><div class="line">              	<span class="keyword">return</span> doSelect(timeout);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.PollSelectorImpl#doSelect</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doSelect</span><span class="params">(<span class="keyword">long</span> timeout)</span></span></div><div class="line"><span class="function">  <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        <span class="keyword">if</span> (channelArray == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClosedSelectorException();</div><div class="line">        <span class="comment">//处理已经不监听的事件（文件描述符或Channel）</span></div><div class="line">        processDeregisterQueue();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//标志开始一个可能会被中断的IO操作</span></div><div class="line">            begin();</div><div class="line">            <span class="comment">//核心</span></div><div class="line">            <span class="comment">//底层调用native方法poll0</span></div><div class="line">            <span class="comment">//本质上是调用了系统的epoll方法</span></div><div class="line">            <span class="comment">//调用native方法epoll获取已经就绪的pollfd</span></div><div class="line">            <span class="comment">//totalChannels：</span></div><div class="line">            <span class="comment">//The number of valid channels in this Selector's poll array</span></div><div class="line">            pollWrapper.poll(totalChannels, <span class="number">0</span>, timeout);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            end();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//处理已经不监听的事件（文件描述符或Channel）</span></div><div class="line">        processDeregisterQueue();</div><div class="line">        <span class="comment">//2 获取就绪的Key的数目，并且将就绪的Key赋值给selector的selectedKey</span></div><div class="line">        <span class="keyword">int</span> numKeysUpdated = updateSelectedKeys();</div><div class="line">        <span class="keyword">if</span> (pollWrapper.getReventOps(<span class="number">0</span>) != <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// Clear the wakeup pipe</span></div><div class="line">            <span class="comment">//清除wakeup通道</span></div><div class="line">            pollWrapper.putReventOps(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">            <span class="keyword">synchronized</span> (interruptLock) &#123;</div><div class="line">                IOUtil.drain(fd0);</div><div class="line">                interruptTriggered = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numKeysUpdated;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>sun.nio.ch.PollArrayWrapper#poll</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">int</span> numfds, <span class="keyword">int</span> offset, <span class="keyword">long</span> timeout)</span> </span>&#123;</div><div class="line">  <span class="comment">//SIZE_POLLFD:8</span></div><div class="line">  <span class="keyword">return</span> poll0(pollArrayAddress + (offset * SIZE_POLLFD),</div><div class="line">               numfds, timeout);</div><div class="line">&#125;</div><div class="line"><span class="comment">//这一方法是一个native方法，本质上是调用了系统的epoll方法</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">poll0</span><span class="params">(<span class="keyword">long</span> pollAddress, <span class="keyword">int</span> numfds, <span class="keyword">long</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>如果有已经就绪的pollfd，poll0()就会返回，没有则一直阻塞，也就是selector.select()会一直阻塞。poll0()返回后，selector.select()就会返回，所以在监听时要用while(true)，这样就可以保证在selector接收到数据并处理完后继续监听poll()。</strong></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>####<code>selector.wakeUp()</code></p>
<blockquote>
<p>某个线程调用select()方法后阻塞了，即使没有通道已经就绪，也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法，但当前没有线程阻塞在select()方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
</blockquote>
<h4 id="selector-close"><a href="#selector-close" class="headerlink" title="selector.close()"></a><code>selector.close()</code></h4><blockquote>
<p>用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
</blockquote>
<p>### </p>
<h4 id="查找native方法源码"><a href="#查找native方法源码" class="headerlink" title="查找native方法源码"></a>查找native方法源码</h4><p>一般，从JDK目录下的native目录(可能跟OS平台相关)根据包名路径去找相关的Class名.c文件即可找到对应的native方法。</p>
<p>如果间接调用了hotspot的实现(jvm会以动态库的形式被加载，prims定义了hotspot与其它模块的接口及实现)，那么从share/vm/prims/jvm.cpp文件可找到JVM_XXX函数的实现。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://grepcode.com/snapshot/repository.grepcode.com/java/root/jdk/openjdk/6-b14/" target="_blank" rel="external">grepcode-openjdk</a></p>
<p><a href="http://hg.openjdk.java.net/" target="_blank" rel="external">hg.openjdk.java.net</a></p>
<h4 id="eclipse插件"><a href="#eclipse插件" class="headerlink" title="eclipse插件"></a>eclipse插件</h4><p><a href="http://marketplace.eclipse.org/content/java-source-attacher" target="_blank" rel="external">Java Source Attacher</a></p>

            
        
        </div>
        
            
            
        
    </article>
    
        
    <nav class="article-page">
        
        
            <a href="/2017/11/11/分布式事务解决方案/" id="art-right" class="art-left">
                <span class="prev-title"> 
                    <i class="iconfont icon-left"></i>分布式事务解决方案
                </span>
            </a>
        
    </nav>

        
    


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
        
            <a href="https://github.com/super2bai" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2017 ~ 2017</span>
        <span>❤</span>
        <span>super2bai</span>
    </div>
    <div class="theme">
        <span>
            Powered by
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            Theme
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>
<script src="/script/search.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.mobileHeader();
    Nlvi.back2top();
    Nlvi.smoothScroll();
    Nlvi.onView();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward();
    Nlvi.picPos();

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
        
    <div class="post-toc">
        <span class="title">文章目录</span>
        <div class="toc-inner syuanpi back-1 fallIn-light">
            <li class="title-link"><a href="javascript:;" class="toTop">NIO原理</a></li>
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞Block和非阻塞Non-Block"><span class="toc-text">阻塞Block和非阻塞Non-Block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步Synchronization和异步Asynchronous"><span class="toc-text">同步Synchronization和异步Asynchronous</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择器Selector"><span class="toc-text">选择器Selector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO和IO如何影响应用程序的设计"><span class="toc-text">NIO和IO如何影响应用程序的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API调用"><span class="toc-text">API调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO"><span class="toc-text">Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心对象"><span class="toc-text">核心对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缓冲区Buffer"><span class="toc-text">缓冲区Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#深入剖析Buffer"><span class="toc-text">深入剖析Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓冲区的分配"><span class="toc-text">缓冲区的分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#缓冲区分片"><span class="toc-text">缓冲区分片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#只读缓冲区"><span class="toc-text">只读缓冲区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通道Channel"><span class="toc-text">通道Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用NIO读取数据"><span class="toc-text">使用NIO读取数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用NIO写入数据"><span class="toc-text">使用NIO写入数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反应堆Reactor"><span class="toc-text">反应堆Reactor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#阻塞I-O通信模型"><span class="toc-text">阻塞I/O通信模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java-NIO原理及通信模型"><span class="toc-text">Java NIO原理及通信模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择器Seletor"><span class="toc-text">选择器Seletor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector-open"><span class="toc-text">Selector.open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel-open"><span class="toc-text">ServerSocketChannel.open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server-configureBlocking-false"><span class="toc-text">server.configureBlocking(false);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server-socket"><span class="toc-text">server.socket();</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket-bind"><span class="toc-text">socket.bind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server-register"><span class="toc-text">server.register</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#implRegister"><span class="toc-text">implRegister</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#interestOps"><span class="toc-text">interestOps</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#selector-select"><span class="toc-text">selector.select()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它"><span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#selector-close"><span class="toc-text">selector.close()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找native方法源码"><span class="toc-text">查找native方法源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eclipse插件"><span class="toc-text">eclipse插件</span></a></li></ol></li></ol>
        </div>
    </div>

    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
    
</body>
</html>
